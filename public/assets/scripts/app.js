((modules, entryPoint) => {
  let global = function() {
    return this;
  }();
  let cache = {};
  let esbuildRequire = (target, arg) => {
    let type = typeof target;
    if (type === "string") {
      return require(target);
    }
    if (type === "number") {
      let module = cache[target], exports;
      if (!module) {
        module = cache[target] = {
          exports: {}
        };
        modules[target].call(global, esbuildRequire, module.exports, module);
      }
      exports = module.exports;
      if (arg && (!exports || !exports.__esModule)) {
        if (!exports || typeof exports !== "object" && typeof exports !== "function") {
          exports = {};
        }
        if (!("default" in exports)) {
          Object.defineProperty(exports, "default", {
            get: () => module.exports,
            enumerable: true
          });
        }
      }
      return exports;
    }
    Object.defineProperty(target, "__esModule", {
      value: true
    });
    for (let name in arg) {
      Object.defineProperty(target, name, {
        get: arg[name],
        enumerable: true
      });
    }
  };
  return esbuildRequire(entryPoint);
})({
  7(require) {
    // public/build/bundle.js
    (function(l, r) {
      if (l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (window.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.head.appendChild(r);
    })(window.document);
    function noop() {
    }
    function assign(tar, src) {
      for (const k in src)
        tar[k] = src[k];
      return tar;
    }
    function add_location(element2, file2, line, column, char) {
      element2.__svelte_meta = {
        loc: {
          file: file2,
          line,
          column,
          char
        }
      };
    }
    function run(fn) {
      return fn();
    }
    function blank_object() {
      return Object.create(null);
    }
    function run_all(fns) {
      fns.forEach(run);
    }
    function is_function(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
    }
    function validate_store(store, name) {
      if (!store || typeof store.subscribe !== "function") {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }
    function subscribe(store, callback) {
      const unsub = store.subscribe(callback);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty) {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i3 = 0; i3 < len; i3 += 1) {
            merged[i3] = $$scope.dirty[i3] | lets[i3];
          }
          return merged;
        }
        return lets;
      }
      return $$scope.dirty;
    }
    function set_store_value(store, ret, value2 = ret) {
      store.set(value2);
      return ret;
    }
    function append(target, node) {
      target.appendChild(node);
    }
    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }
    function detach(node) {
      node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
      for (let i3 = 0; i3 < iterations.length; i3 += 1) {
        if (iterations[i3])
          iterations[i3].d(detaching);
      }
    }
    function element(name) {
      return document.createElement(name);
    }
    function svg_element(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function text(data) {
      return document.createTextNode(data);
    }
    function space() {
      return text(" ");
    }
    function empty() {
      return text("");
    }
    function listen(node, event2, handler, options) {
      node.addEventListener(event2, handler, options);
      return () => node.removeEventListener(event2, handler, options);
    }
    function attr(node, attribute, value2) {
      if (value2 == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value2)
        node.setAttribute(attribute, value2);
    }
    function children(element2) {
      return Array.from(element2.childNodes);
    }
    function set_input_value(input, value2) {
      if (value2 != null || input.value) {
        input.value = value2;
      }
    }
    function set_style(node, key, value2, important) {
      node.style.setProperty(key, value2, important ? "important" : "");
    }
    function add_resize_listener(element2, fn) {
      if (getComputedStyle(element2).position === "static") {
        element2.style.position = "relative";
      }
      const object = document.createElement("object");
      object.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");
      object.setAttribute("aria-hidden", "true");
      object.type = "text/html";
      object.tabIndex = -1;
      let win;
      object.onload = () => {
        win = object.contentDocument.defaultView;
        win.addEventListener("resize", fn);
      };
      if (/Trident/.test(navigator.userAgent)) {
        element2.appendChild(object);
        object.data = "about:blank";
      } else {
        object.data = "about:blank";
        element2.appendChild(object);
      }
      return {
        cancel: () => {
          win && win.removeEventListener && win.removeEventListener("resize", fn);
          element2.removeChild(object);
        }
      };
    }
    function custom_event(type, detail) {
      const e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, false, false, detail);
      return e;
    }
    let current_component;
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component)
        throw new Error(`Function called outside component initialization`);
      return current_component;
    }
    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }
    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }
    function flush() {
      const seen_callbacks = new Set();
      do {
        while (dirty_components.length) {
          const component = dirty_components.shift();
          set_current_component(component);
          update(component.$$);
        }
        while (binding_callbacks.length)
          binding_callbacks.pop()();
        for (let i3 = 0; i3 < render_callbacks.length; i3 += 1) {
          const callback = render_callbacks[i3];
          if (!seen_callbacks.has(callback)) {
            callback();
            seen_callbacks.add(callback);
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
    }
    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        $$.fragment && $$.fragment.p($$.ctx, $$.dirty);
        $$.dirty = [-1];
        $$.after_update.forEach(add_render_callback);
      }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros
      };
    }
    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }
      outros = outros.p;
    }
    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }
    function transition_out(block, local, detach2, callback) {
      if (block && block.o) {
        if (outroing.has(block))
          return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);
          if (callback) {
            if (detach2)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }
    const globals = typeof window !== "undefined" ? window : global;
    function create_component(block) {
      block && block.c();
    }
    function mount_component(component, target, anchor) {
      const {fragment, on_mount, on_destroy, after_update} = component.$$;
      fragment && fragment.m(target, anchor);
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty(component, i3) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i3 / 31 | 0] |= 1 << i3 % 31;
    }
    function init(component, options, instance2, create_fragment2, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const prop_values = options.props || {};
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        callbacks: blank_object(),
        dirty
      };
      let ready = false;
      $$.ctx = instance2 ? instance2(component, prop_values, (i3, ret, value2 = ret) => {
        if ($$.ctx && not_equal($$.ctx[i3], $$.ctx[i3] = value2)) {
          if ($$.bound[i3])
            $$.bound[i3](value2);
          if (ready)
            make_dirty(component, i3);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          $$.fragment && $$.fragment.l(children(options.target));
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
      }
      set_current_component(parent_component);
    }
    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
      $on(type, callback) {
        const callbacks2 = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks2.push(callback);
        return () => {
          const index2 = callbacks2.indexOf(callback);
          if (index2 !== -1)
            callbacks2.splice(index2, 1);
        };
      }
      $set() {
      }
    }
    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, detail));
    }
    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node
      });
      append(target, node);
    }
    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node,
        anchor
      });
      insert(target, node, anchor);
    }
    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", {
        node
      });
      detach(node);
    }
    function listen_dev(node, event2, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
        modifiers.push("preventDefault");
      if (has_stop_propagation)
        modifiers.push("stopPropagation");
      dispatch_dev("SvelteDOMAddEventListener", {
        node,
        event: event2,
        handler,
        modifiers
      });
      const dispose = listen(node, event2, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", {
          node,
          event: event2,
          handler,
          modifiers
        });
        dispose();
      };
    }
    function attr_dev(node, attribute, value2) {
      attr(node, attribute, value2);
      if (value2 == null)
        dispatch_dev("SvelteDOMRemoveAttribute", {
          node,
          attribute
        });
      else
        dispatch_dev("SvelteDOMSetAttribute", {
          node,
          attribute,
          value: value2
        });
    }
    function prop_dev(node, property, value2) {
      node[property] = value2;
      dispatch_dev("SvelteDOMSetProperty", {
        node,
        property,
        value: value2
      });
    }
    function set_data_dev(text2, data) {
      data = "" + data;
      if (text2.data === data)
        return;
      dispatch_dev("SvelteDOMSetData", {
        node: text2,
        data
      });
      text2.data = data;
    }
    class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error(`'target' is a required option`);
        }
        super();
      }
      $destroy() {
        super.$destroy();
        this.$destroy = () => {
          console.warn(`Component was already destroyed`);
        };
      }
    }
    var toString = Object.prototype.toString;
    var kindOf = function kindOf2(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return val.constructor ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
    const valueOf = Symbol.prototype.valueOf;
    function clone(val, deep) {
      switch (kindOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer(val);
        case "symbol":
          return cloneSymbol(val);
        case "arraybuffer":
          return cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray(val);
        case "regexp":
          return cloneRegExp(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re2 = new val.constructor(val.source, flags);
      re2.lastIndex = val.lastIndex;
      return re2;
    }
    function cloneArrayBuffer(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer(val) {
      const len = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    var shallowClone = clone;
    var isobject = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
    function isObjectObject(o) {
      return isobject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    var isPlainObject = function isPlainObject2(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
    function cloneDeep(val, instanceClone) {
      switch (kindOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return shallowClone(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i3 = 0; i3 < val.length; i3++) {
        res[i3] = cloneDeep(val[i3], instanceClone);
      }
      return res;
    }
    var cloneDeep_1 = cloneDeep;
    const file = "src/ui/Panel.svelte";
    const get_header_slot_changes = (dirty) => ({});
    const get_header_slot_context = (ctx) => ({});
    function create_if_block(ctx) {
      let header;
      let h3;
      let t0;
      let t1;
      let current;
      const header_slot_template = ctx[5].header;
      const header_slot = create_slot(header_slot_template, ctx, ctx[4], get_header_slot_context);
      const block = {
        c: function create() {
          header = element("header");
          h3 = element("h3");
          t0 = text(ctx[3]);
          t1 = space();
          if (header_slot)
            header_slot.c();
          attr_dev(h3, "class", "title svelte-c6n1xf");
          add_location(h3, file, 3, 8, 125);
          attr_dev(header, "class", "header svelte-c6n1xf");
          add_location(header, file, 2, 4, 93);
        },
        m: function mount(target, anchor) {
          insert_dev(target, header, anchor);
          append_dev(header, h3);
          append_dev(h3, t0);
          append_dev(header, t1);
          if (header_slot) {
            header_slot.m(header, null);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (!current || dirty[0] & 8)
            set_data_dev(t0, ctx2[3]);
          if (header_slot && header_slot.p && dirty[0] & 16) {
            header_slot.p(get_slot_context(header_slot_template, ctx2, ctx2[4], get_header_slot_context), get_slot_changes(header_slot_template, ctx2[4], dirty, get_header_slot_changes));
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(header_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(header_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(header);
          if (header_slot)
            header_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block.name,
        type: "if",
        source: "(2:4) {#if title !== ''}",
        ctx
      });
      return block;
    }
    function create_fragment(ctx) {
      let div1;
      let t;
      let div0;
      let div0_style_value;
      let div1_style_value;
      let current;
      let if_block = ctx[3] !== "" && create_if_block(ctx);
      const default_slot_template = ctx[5].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
      const block = {
        c: function create() {
          div1 = element("div");
          if (if_block)
            if_block.c();
          t = space();
          div0 = element("div");
          if (default_slot)
            default_slot.c();
          attr_dev(div0, "class", "content svelte-c6n1xf");
          attr_dev(div0, "style", div0_style_value = `flex-direction: ${ctx[2]}`);
          add_location(div0, file, 7, 4, 220);
          attr_dev(div1, "class", "panel svelte-c6n1xf");
          attr_dev(div1, "style", div1_style_value = `width: ${ctx[0]}; height: ${ctx[1]};`);
          add_location(div1, file, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          if (if_block)
            if_block.m(div1, null);
          append_dev(div1, t);
          append_dev(div1, div0);
          if (default_slot) {
            default_slot.m(div0, null);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[3] !== "") {
            if (if_block) {
              if_block.p(ctx2, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, t);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
          if (default_slot && default_slot.p && dirty[0] & 16) {
            default_slot.p(get_slot_context(default_slot_template, ctx2, ctx2[4], null), get_slot_changes(default_slot_template, ctx2[4], dirty, null));
          }
          if (!current || dirty[0] & 4 && div0_style_value !== (div0_style_value = `flex-direction: ${ctx2[2]}`)) {
            attr_dev(div0, "style", div0_style_value);
          }
          if (!current || dirty[0] & 3 && div1_style_value !== (div1_style_value = `width: ${ctx2[0]}; height: ${ctx2[1]};`)) {
            attr_dev(div1, "style", div1_style_value);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block)
            if_block.d();
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance($$self, $$props, $$invalidate) {
      let {width = "100%"} = $$props;
      let {height = "100%"} = $$props;
      let {direction = "row"} = $$props;
      let {title = ""} = $$props;
      const writable_props = ["width", "height", "direction", "title"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Panel> was created with unknown prop '${key}'`);
      });
      let {$$slots = {}, $$scope} = $$props;
      $$self.$set = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(1, height = $$props2.height);
        if ("direction" in $$props2)
          $$invalidate(2, direction = $$props2.direction);
        if ("title" in $$props2)
          $$invalidate(3, title = $$props2.title);
        if ("$$scope" in $$props2)
          $$invalidate(4, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => {
        return {
          width,
          height,
          direction,
          title
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(1, height = $$props2.height);
        if ("direction" in $$props2)
          $$invalidate(2, direction = $$props2.direction);
        if ("title" in $$props2)
          $$invalidate(3, title = $$props2.title);
      };
      return [width, height, direction, title, $$scope, $$slots];
    }
    class Panel extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance, create_fragment, safe_not_equal, {
          width: 0,
          height: 1,
          direction: 2,
          title: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Panel",
          options,
          id: create_fragment.name
        });
      }
      get width() {
        throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get height() {
        throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set height(value2) {
        throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get direction() {
        throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set direction(value2) {
        throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get title() {
        throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set title(value2) {
        throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$1 = "src/ui/svg/IconArrowRight.svelte";
    function create_fragment$1(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z");
          add_location(path, file$1, 0, 98, 98);
          attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg, "width", "24");
          attr_dev(svg, "height", "24");
          attr_dev(svg, "viewBox", "0 0 24 24");
          attr_dev(svg, "fill", "#f0f0f0");
          add_location(svg, file$1, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$1.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    class IconArrowRight extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, null, create_fragment$1, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconArrowRight",
          options,
          id: create_fragment$1.name
        });
      }
    }
    const file$2 = "src/ui/svg/IconArrowBottom.svelte";
    function create_fragment$2(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M0 7.33l2.829-2.83 9.175 9.339 9.167-9.339 2.829 2.83-11.996 12.17z");
          add_location(path, file$2, 0, 98, 98);
          attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg, "width", "24");
          attr_dev(svg, "height", "24");
          attr_dev(svg, "viewBox", "0 0 24 24");
          attr_dev(svg, "fill", "#f0f0f0");
          add_location(svg, file$2, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$2.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    class IconArrowBottom extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, null, create_fragment$2, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconArrowBottom",
          options,
          id: create_fragment$2.name
        });
      }
    }
    const Storage = function Storage2() {
      function set(key, value2) {
        try {
          window.localStorage.setItem(key, value2);
        } catch (error) {
          console.warn(error);
        }
        return () => {
          unset(key);
        };
      }
      function get(key) {
        try {
          return window.localStorage.getItem(key);
        } catch (error) {
          console.warn(error);
        }
      }
      function unset(key) {
        try {
          window.localStorage.removeItem(key);
        } catch (error) {
          console.warn(error);
        }
      }
      function rehydrate(key, fn) {
        if (key.length > 0 && get(key)) {
          let parsed = JSON.parse(get(key));
          if (fn && typeof fn === "function") {
            fn(parsed);
          }
        }
      }
      return {
        set,
        get,
        unset,
        rehydrate
      };
    }();
    const file$3 = "src/ui/Dropdown.svelte";
    function create_else_block(ctx) {
      let current;
      const iconarrowright = new IconArrowRight({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(iconarrowright.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconarrowright, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconarrowright.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconarrowright.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconarrowright, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block.name,
        type: "else",
        source: "(6:12) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$1(ctx) {
      let current;
      const iconarrowbottom = new IconArrowBottom({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(iconarrowbottom.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconarrowbottom, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconarrowbottom.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconarrowbottom.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconarrowbottom, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$1.name,
        type: "if",
        source: "(4:12) {#if opened}",
        ctx
      });
      return block;
    }
    function create_fragment$3(ctx) {
      let div1;
      let button_1;
      let span0;
      let current_block_type_index;
      let if_block;
      let t0;
      let span1;
      let t1;
      let t2;
      let div0;
      let div0_class_value;
      let current;
      let dispose;
      const if_block_creators = [create_if_block$1, create_else_block];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[0])
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      const block = {
        c: function create() {
          div1 = element("div");
          button_1 = element("button");
          span0 = element("span");
          if_block.c();
          t0 = space();
          span1 = element("span");
          t1 = text(ctx[1]);
          t2 = space();
          div0 = element("div");
          if (default_slot)
            default_slot.c();
          attr_dev(span0, "class", "toggle svelte-trnn71");
          add_location(span0, file$3, 2, 8, 110);
          attr_dev(span1, "class", "label svelte-trnn71");
          add_location(span1, file$3, 9, 8, 280);
          attr_dev(button_1, "class", "button svelte-trnn71");
          add_location(button_1, file$3, 1, 4, 41);
          attr_dev(div0, "class", div0_class_value = "content " + ctx[4] + " svelte-trnn71");
          add_location(div0, file$3, 11, 4, 333);
          attr_dev(div1, "class", "dropdown svelte-trnn71");
          attr_dev(div1, "style", ctx[2]);
          add_location(div1, file$3, 0, 0, 0);
          dispose = listen_dev(button_1, "click", ctx[5], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, button_1);
          append_dev(button_1, span0);
          if_blocks[current_block_type_index].m(span0, null);
          append_dev(button_1, t0);
          append_dev(button_1, span1);
          append_dev(span1, t1);
          ctx[9](button_1);
          append_dev(div1, t2);
          append_dev(div1, div0);
          if (default_slot) {
            default_slot.m(div0, null);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index !== previous_block_index) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            }
            transition_in(if_block, 1);
            if_block.m(span0, null);
          }
          if (!current || dirty[0] & 2)
            set_data_dev(t1, ctx2[1]);
          if (default_slot && default_slot.p && dirty[0] & 128) {
            default_slot.p(get_slot_context(default_slot_template, ctx2, ctx2[7], null), get_slot_changes(default_slot_template, ctx2[7], dirty, null));
          }
          if (!current || dirty[0] & 16 && div0_class_value !== (div0_class_value = "content " + ctx2[4] + " svelte-trnn71")) {
            attr_dev(div0, "class", div0_class_value);
          }
          if (!current || dirty[0] & 4) {
            attr_dev(div1, "style", ctx2[2]);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if_blocks[current_block_type_index].d();
          ctx[9](null);
          if (default_slot)
            default_slot.d(detaching);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$3.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$1($$self, $$props, $$invalidate) {
      let {title = ""} = $$props;
      let {opened = true} = $$props;
      let {style = ""} = $$props;
      let {url: url2 = ""} = $$props;
      let button;
      function toggle() {
        $$invalidate(0, opened = !opened);
        button.blur();
      }
      const writable_props = ["title", "opened", "style", "url"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Dropdown> was created with unknown prop '${key}'`);
      });
      let {$$slots = {}, $$scope} = $$props;
      function button_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(3, button = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("title" in $$props2)
          $$invalidate(1, title = $$props2.title);
        if ("opened" in $$props2)
          $$invalidate(0, opened = $$props2.opened);
        if ("style" in $$props2)
          $$invalidate(2, style = $$props2.style);
        if ("url" in $$props2)
          $$invalidate(6, url2 = $$props2.url);
        if ("$$scope" in $$props2)
          $$invalidate(7, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => {
        return {
          title,
          opened,
          style,
          url: url2,
          button,
          classNameVisible
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("title" in $$props2)
          $$invalidate(1, title = $$props2.title);
        if ("opened" in $$props2)
          $$invalidate(0, opened = $$props2.opened);
        if ("style" in $$props2)
          $$invalidate(2, style = $$props2.style);
        if ("url" in $$props2)
          $$invalidate(6, url2 = $$props2.url);
        if ("button" in $$props2)
          $$invalidate(3, button = $$props2.button);
        if ("classNameVisible" in $$props2)
          $$invalidate(4, classNameVisible = $$props2.classNameVisible);
      };
      let classNameVisible;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 64) {
          {
            if (url2.length > 0) {
              Storage.rehydrate(url2, (value2) => {
                $$invalidate(0, opened = value2.opened);
              });
            }
          }
        }
        if ($$self.$$.dirty[0] & 1) {
          $$invalidate(4, classNameVisible = opened ? "visible" : "");
        }
        if ($$self.$$.dirty[0] & 65) {
          {
            if (url2.length > 0) {
              Storage.set(url2, JSON.stringify({
                opened
              }));
            }
          }
        }
      };
      return [opened, title, style, button, classNameVisible, toggle, url2, $$scope, $$slots, button_1_binding];
    }
    class Dropdown extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$1, create_fragment$3, safe_not_equal, {
          title: 1,
          opened: 0,
          style: 2,
          url: 6
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Dropdown",
          options,
          id: create_fragment$3.name
        });
      }
      get title() {
        throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set title(value2) {
        throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get opened() {
        throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set opened(value2) {
        throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value2) {
        throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get url() {
        throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set url(value2) {
        throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$4 = "src/ui/Window.svelte";
    const get_header_slot_changes$1 = (dirty) => ({});
    const get_header_slot_context$1 = (ctx) => ({});
    function create_fragment$4(ctx) {
      let div1;
      let header;
      let button;
      let t0;
      let h1;
      let t1;
      let t2;
      let t3;
      let div0;
      let current;
      let dispose;
      const header_slot_template = ctx[14].header;
      const header_slot = create_slot(header_slot_template, ctx, ctx[13], get_header_slot_context$1);
      const default_slot_template = ctx[14].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
      const block = {
        c: function create() {
          div1 = element("div");
          header = element("header");
          button = element("button");
          t0 = space();
          h1 = element("h1");
          t1 = text(ctx[0]);
          t2 = space();
          if (header_slot)
            header_slot.c();
          t3 = space();
          div0 = element("div");
          if (default_slot)
            default_slot.c();
          attr_dev(button, "class", "close svelte-tliws5");
          add_location(button, file$4, 2, 8, 196);
          attr_dev(h1, "class", "title svelte-tliws5");
          add_location(h1, file$4, 4, 8, 273);
          attr_dev(header, "class", "header svelte-tliws5");
          add_location(header, file$4, 1, 4, 127);
          attr_dev(div0, "class", "content");
          add_location(div0, file$4, 7, 4, 358);
          attr_dev(div1, "class", "window svelte-tliws5");
          set_style(div1, "transform", "translate3d(" + ctx[2] + "px, " + ctx[3] + "px, 0)");
          set_style(div1, "display", ctx[4]);
          add_location(div1, file$4, 0, 0, 0);
          dispose = [listen_dev(button, "click", ctx[5], false, false, false), listen_dev(header, "mousedown", ctx[6], false, false, false)];
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, header);
          append_dev(header, button);
          append_dev(header, t0);
          append_dev(header, h1);
          append_dev(h1, t1);
          append_dev(header, t2);
          if (header_slot) {
            header_slot.m(header, null);
          }
          append_dev(div1, t3);
          append_dev(div1, div0);
          if (default_slot) {
            default_slot.m(div0, null);
          }
          ctx[15](div1);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (!current || dirty[0] & 1)
            set_data_dev(t1, ctx2[0]);
          if (header_slot && header_slot.p && dirty[0] & 8192) {
            header_slot.p(get_slot_context(header_slot_template, ctx2, ctx2[13], get_header_slot_context$1), get_slot_changes(header_slot_template, ctx2[13], dirty, get_header_slot_changes$1));
          }
          if (default_slot && default_slot.p && dirty[0] & 8192) {
            default_slot.p(get_slot_context(default_slot_template, ctx2, ctx2[13], null), get_slot_changes(default_slot_template, ctx2[13], dirty, null));
          }
          if (!current || dirty[0] & 12) {
            set_style(div1, "transform", "translate3d(" + ctx2[2] + "px, " + ctx2[3] + "px, 0)");
          }
          if (!current || dirty[0] & 16) {
            set_style(div1, "display", ctx2[4]);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(header_slot, local);
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(header_slot, local);
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (header_slot)
            header_slot.d(detaching);
          if (default_slot)
            default_slot.d(detaching);
          ctx[15](null);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$4.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$2($$self, $$props, $$invalidate) {
      let {visible = true} = $$props;
      let {title = ""} = $$props;
      let {onClose = () => {
      }} = $$props;
      let container;
      let offsetX = 0;
      let offsetY = 0;
      let startX = 0;
      let startY = 0;
      onMount(() => {
        document.body.appendChild(container);
      });
      function handleClickClose() {
        $$invalidate(7, visible = false);
        onClose(visible);
      }
      function handleMouseDownHeader(event2) {
        startX = event2.clientX - offsetX;
        startY = event2.clientY - offsetY;
        document.addEventListener("mousemove", handleMouseMoveDocument);
        document.addEventListener("mouseup", handleMouseUpDocument);
      }
      function handleMouseMoveDocument(event2) {
        $$invalidate(2, offsetX = event2.clientX - startX);
        $$invalidate(3, offsetY = event2.clientY - startY);
      }
      function handleMouseUpDocument() {
        document.removeEventListener("mousemove", handleMouseMoveDocument);
        document.removeEventListener("mouseup", handleMouseUpDocument);
      }
      const writable_props = ["visible", "title", "onClose"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Window> was created with unknown prop '${key}'`);
      });
      let {$$slots = {}, $$scope} = $$props;
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(1, container = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("visible" in $$props2)
          $$invalidate(7, visible = $$props2.visible);
        if ("title" in $$props2)
          $$invalidate(0, title = $$props2.title);
        if ("onClose" in $$props2)
          $$invalidate(8, onClose = $$props2.onClose);
        if ("$$scope" in $$props2)
          $$invalidate(13, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => {
        return {
          visible,
          title,
          onClose,
          container,
          offsetX,
          offsetY,
          startX,
          startY,
          display
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("visible" in $$props2)
          $$invalidate(7, visible = $$props2.visible);
        if ("title" in $$props2)
          $$invalidate(0, title = $$props2.title);
        if ("onClose" in $$props2)
          $$invalidate(8, onClose = $$props2.onClose);
        if ("container" in $$props2)
          $$invalidate(1, container = $$props2.container);
        if ("offsetX" in $$props2)
          $$invalidate(2, offsetX = $$props2.offsetX);
        if ("offsetY" in $$props2)
          $$invalidate(3, offsetY = $$props2.offsetY);
        if ("startX" in $$props2)
          startX = $$props2.startX;
        if ("startY" in $$props2)
          startY = $$props2.startY;
        if ("display" in $$props2)
          $$invalidate(4, display = $$props2.display);
      };
      let display;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 128) {
          $$invalidate(4, display = visible ? "block" : "none");
        }
      };
      return [title, container, offsetX, offsetY, display, handleClickClose, handleMouseDownHeader, visible, onClose, startX, startY, handleMouseMoveDocument, handleMouseUpDocument, $$scope, $$slots, div1_binding];
    }
    class Window extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$2, create_fragment$4, safe_not_equal, {
          visible: 7,
          title: 0,
          onClose: 8
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Window",
          options,
          id: create_fragment$4.name
        });
      }
      get visible() {
        throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set visible(value2) {
        throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get title() {
        throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set title(value2) {
        throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onClose() {
        throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onClose(value2) {
        throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$5 = "src/ui/Button.svelte";
    function create_fragment$5(ctx) {
      let button;
      let current;
      let dispose;
      const default_slot_template = ctx[3].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
      const block = {
        c: function create() {
          button = element("button");
          if (default_slot)
            default_slot.c();
          attr_dev(button, "class", "button svelte-uw7n3z");
          attr_dev(button, "style", ctx[1]);
          add_location(button, file$5, 0, 0, 0);
          dispose = listen_dev(button, "click", ctx[0], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, button, anchor);
          if (default_slot) {
            default_slot.m(button, null);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot && default_slot.p && dirty[0] & 4) {
            default_slot.p(get_slot_context(default_slot_template, ctx2, ctx2[2], null), get_slot_changes(default_slot_template, ctx2[2], dirty, null));
          }
          if (!current || dirty[0] & 2) {
            attr_dev(button, "style", ctx2[1]);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(button);
          if (default_slot)
            default_slot.d(detaching);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$5.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$3($$self, $$props, $$invalidate) {
      let {onClick = () => {
      }} = $$props;
      let {style = ""} = $$props;
      const writable_props = ["onClick", "style"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Button> was created with unknown prop '${key}'`);
      });
      let {$$slots = {}, $$scope} = $$props;
      $$self.$set = ($$props2) => {
        if ("onClick" in $$props2)
          $$invalidate(0, onClick = $$props2.onClick);
        if ("style" in $$props2)
          $$invalidate(1, style = $$props2.style);
        if ("$$scope" in $$props2)
          $$invalidate(2, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => {
        return {
          onClick,
          style
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("onClick" in $$props2)
          $$invalidate(0, onClick = $$props2.onClick);
        if ("style" in $$props2)
          $$invalidate(1, style = $$props2.style);
      };
      return [onClick, style, $$scope, $$slots];
    }
    class Button extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$3, create_fragment$5, safe_not_equal, {
          onClick: 0,
          style: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Button",
          options,
          id: create_fragment$5.name
        });
      }
      get onClick() {
        throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onClick(value2) {
        throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value2) {
        throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$6 = "src/ui/Select.svelte";
    function get_each_context(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i3];
      return child_ctx;
    }
    function create_each_block(ctx) {
      let option;
      let t_value = ctx[6].label + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = ctx[6].key;
          option.value = option.__value;
          add_location(option, file$6, 2, 0, 93);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2 && t_value !== (t_value = ctx2[6].label + ""))
            set_data_dev(t, t_value);
          if (dirty[0] & 2 && option_value_value !== (option_value_value = ctx2[6].key)) {
            prop_dev(option, "__value", option_value_value);
          }
          option.value = option.__value;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block.name,
        type: "each",
        source: "(2:0) {#each options as option}",
        ctx
      });
      return block;
    }
    function create_fragment$6(ctx) {
      let select_1;
      let select_1_value_value;
      let dispose;
      let each_value = ctx[1];
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block(get_each_context(ctx, each_value, i3));
      }
      const block = {
        c: function create() {
          select_1 = element("select");
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          attr_dev(select_1, "class", "svelte-6q38x");
          add_location(select_1, file$6, 0, 0, 0);
          dispose = listen_dev(select_1, "change", ctx[3], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, select_1, anchor);
          for (let i4 = 0; i4 < each_blocks.length; i4 += 1) {
            each_blocks[i4].m(select_1, null);
          }
          select_1_value_value = ctx[0];
          for (var i3 = 0; i3 < select_1.options.length; i3 += 1) {
            var option = select_1.options[i3];
            if (option.__value === select_1_value_value) {
              option.selected = true;
              break;
            }
          }
          ctx[5](select_1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2) {
            each_value = ctx2[1];
            let i4;
            for (i4 = 0; i4 < each_value.length; i4 += 1) {
              const child_ctx = get_each_context(ctx2, each_value, i4);
              if (each_blocks[i4]) {
                each_blocks[i4].p(child_ctx, dirty);
              } else {
                each_blocks[i4] = create_each_block(child_ctx);
                each_blocks[i4].c();
                each_blocks[i4].m(select_1, null);
              }
            }
            for (; i4 < each_blocks.length; i4 += 1) {
              each_blocks[i4].d(1);
            }
            each_blocks.length = each_value.length;
          }
          if (dirty[0] & 1 && select_1_value_value !== (select_1_value_value = ctx2[0])) {
            for (var i3 = 0; i3 < select_1.options.length; i3 += 1) {
              var option = select_1.options[i3];
              if (option.__value === select_1_value_value) {
                option.selected = true;
                break;
              }
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(select_1);
          destroy_each(each_blocks, detaching);
          ctx[5](null);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$6.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$4($$self, $$props, $$invalidate) {
      let {options = []} = $$props;
      let {value: value2} = $$props;
      let {onChange = () => {
      }} = $$props;
      let select;
      function handleChange(event2) {
        $$invalidate(0, value2 = event2.target.value);
        for (let i3 = 0; i3 < options.length; i3++) {
          if (options[i3].key === value2) {
            onChange(options[i3]);
          }
        }
        select.blur();
      }
      const writable_props = ["options", "value", "onChange"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Select> was created with unknown prop '${key}'`);
      });
      function select_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(2, select = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("options" in $$props2)
          $$invalidate(1, options = $$props2.options);
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(4, onChange = $$props2.onChange);
      };
      $$self.$capture_state = () => {
        return {
          options,
          value: value2,
          onChange,
          select
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("options" in $$props2)
          $$invalidate(1, options = $$props2.options);
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(4, onChange = $$props2.onChange);
        if ("select" in $$props2)
          $$invalidate(2, select = $$props2.select);
      };
      return [value2, options, select, handleChange, onChange, select_1_binding];
    }
    class Select extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$4, create_fragment$6, safe_not_equal, {
          options: 1,
          value: 0,
          onChange: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Select",
          options,
          id: create_fragment$6.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("value" in props)) {
          console.warn("<Select> was created without expected prop 'value'");
        }
      }
      get options() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set options(value2) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value2) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    function clamp(value2, min, max) {
      return Math.max(min, Math.min(value2, max));
    }
    var noop$1 = () => {
    };
    const file$7 = "src/ui/TextInput.svelte";
    function create_fragment$7(ctx) {
      let input_1;
      let input_1_style_value;
      let dispose;
      const block = {
        c: function create() {
          input_1 = element("input");
          attr_dev(input_1, "type", "text");
          attr_dev(input_1, "class", "input svelte-1tiu0mw");
          input_1.disabled = ctx[3];
          attr_dev(input_1, "style", input_1_style_value = `width: ${ctx[1]}; ${ctx[2]}`);
          add_location(input_1, file$7, 0, 0, 0);
          dispose = [listen_dev(input_1, "input", ctx[20]), listen_dev(input_1, "change", ctx[6], false, false, false), listen_dev(input_1, "keyup", ctx[9], false, false, false), listen_dev(input_1, "keydown", ctx[5], false, false, false), listen_dev(input_1, "focus", ctx[7], false, false, false), listen_dev(input_1, "blur", ctx[8], false, false, false)];
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, input_1, anchor);
          set_input_value(input_1, ctx[0]);
          ctx[21](input_1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 8) {
            prop_dev(input_1, "disabled", ctx2[3]);
          }
          if (dirty[0] & 6 && input_1_style_value !== (input_1_style_value = `width: ${ctx2[1]}; ${ctx2[2]}`)) {
            attr_dev(input_1, "style", input_1_style_value);
          }
          if (dirty[0] & 1 && input_1.value !== ctx2[0]) {
            set_input_value(input_1, ctx2[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input_1);
          ctx[21](null);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$7.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$5($$self, $$props, $$invalidate) {
      let {onSubmit = noop$1} = $$props;
      let {onChange = noop$1} = $$props;
      let {onBlur = noop$1} = $$props;
      let {onFocus = noop$1} = $$props;
      let {onKeyDown = noop$1} = $$props;
      let {onKeyUp = noop$1} = $$props;
      let {width = "auto"} = $$props;
      let {value: value2} = $$props;
      let {type = typeof value2} = $$props;
      let {step = 0.1} = $$props;
      let {min = void 0} = $$props;
      let {max = void 0} = $$props;
      let {style = ""} = $$props;
      let {disabled = false} = $$props;
      let input;
      function handleKeyDown(event2) {
        if (event2.keyCode === 38) {
          if (type === "number") {
            event2.preventDefault();
            $$invalidate(0, value2 += step);
            $$invalidate(0, value2 = Math.round(value2 * (1 / step)) / (1 / step));
            if (min !== void 0 && max !== void 0) {
              $$invalidate(0, value2 = clamp(value2, min, max));
            }
          }
        }
        if (event2.keyCode === 40) {
          if (type === "number") {
            event2.preventDefault();
            $$invalidate(0, value2 -= step);
            $$invalidate(0, value2 = Math.round(value2 * (1 / step)) / (1 / step));
            if (min !== void 0 && max !== void 0) {
              $$invalidate(0, value2 = clamp(value2, min, max));
            }
          }
        }
        onKeyDown(event2);
      }
      function handleChange(event2) {
        onChange(value2);
      }
      function handleFocus(event2) {
        onFocus(event2);
      }
      function handleBlur() {
        onBlur(event);
      }
      function handleKeyUp(event2) {
        if (event2.keyCode === 13) {
          input.blur();
          if (type === "number") {
            $$invalidate(0, value2 = Number(value2));
          }
          onSubmit(value2);
        }
        onKeyUp(event2);
      }
      const writable_props = ["onSubmit", "onChange", "onBlur", "onFocus", "onKeyDown", "onKeyUp", "width", "value", "type", "step", "min", "max", "style", "disabled"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<TextInput> was created with unknown prop '${key}'`);
      });
      function input_1_input_handler() {
        value2 = this.value;
        $$invalidate(0, value2);
      }
      function input_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(4, input = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("onSubmit" in $$props2)
          $$invalidate(10, onSubmit = $$props2.onSubmit);
        if ("onChange" in $$props2)
          $$invalidate(11, onChange = $$props2.onChange);
        if ("onBlur" in $$props2)
          $$invalidate(12, onBlur = $$props2.onBlur);
        if ("onFocus" in $$props2)
          $$invalidate(13, onFocus = $$props2.onFocus);
        if ("onKeyDown" in $$props2)
          $$invalidate(14, onKeyDown = $$props2.onKeyDown);
        if ("onKeyUp" in $$props2)
          $$invalidate(15, onKeyUp = $$props2.onKeyUp);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("type" in $$props2)
          $$invalidate(16, type = $$props2.type);
        if ("step" in $$props2)
          $$invalidate(17, step = $$props2.step);
        if ("min" in $$props2)
          $$invalidate(18, min = $$props2.min);
        if ("max" in $$props2)
          $$invalidate(19, max = $$props2.max);
        if ("style" in $$props2)
          $$invalidate(2, style = $$props2.style);
        if ("disabled" in $$props2)
          $$invalidate(3, disabled = $$props2.disabled);
      };
      $$self.$capture_state = () => {
        return {
          onSubmit,
          onChange,
          onBlur,
          onFocus,
          onKeyDown,
          onKeyUp,
          width,
          value: value2,
          type,
          step,
          min,
          max,
          style,
          disabled,
          input
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("onSubmit" in $$props2)
          $$invalidate(10, onSubmit = $$props2.onSubmit);
        if ("onChange" in $$props2)
          $$invalidate(11, onChange = $$props2.onChange);
        if ("onBlur" in $$props2)
          $$invalidate(12, onBlur = $$props2.onBlur);
        if ("onFocus" in $$props2)
          $$invalidate(13, onFocus = $$props2.onFocus);
        if ("onKeyDown" in $$props2)
          $$invalidate(14, onKeyDown = $$props2.onKeyDown);
        if ("onKeyUp" in $$props2)
          $$invalidate(15, onKeyUp = $$props2.onKeyUp);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("type" in $$props2)
          $$invalidate(16, type = $$props2.type);
        if ("step" in $$props2)
          $$invalidate(17, step = $$props2.step);
        if ("min" in $$props2)
          $$invalidate(18, min = $$props2.min);
        if ("max" in $$props2)
          $$invalidate(19, max = $$props2.max);
        if ("style" in $$props2)
          $$invalidate(2, style = $$props2.style);
        if ("disabled" in $$props2)
          $$invalidate(3, disabled = $$props2.disabled);
        if ("input" in $$props2)
          $$invalidate(4, input = $$props2.input);
      };
      return [value2, width, style, disabled, input, handleKeyDown, handleChange, handleFocus, handleBlur, handleKeyUp, onSubmit, onChange, onBlur, onFocus, onKeyDown, onKeyUp, type, step, min, max, input_1_input_handler, input_1_binding];
    }
    class TextInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$5, create_fragment$7, safe_not_equal, {
          onSubmit: 10,
          onChange: 11,
          onBlur: 12,
          onFocus: 13,
          onKeyDown: 14,
          onKeyUp: 15,
          width: 1,
          value: 0,
          type: 16,
          step: 17,
          min: 18,
          max: 19,
          style: 2,
          disabled: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TextInput",
          options,
          id: create_fragment$7.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("value" in props)) {
          console.warn("<TextInput> was created without expected prop 'value'");
        }
      }
      get onSubmit() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onSubmit(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onBlur() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onBlur(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onFocus() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onFocus(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onKeyDown() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onKeyDown(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onKeyUp() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onKeyUp(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get width() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get type() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set type(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get step() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set step(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get min() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set min(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get max() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set max(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value2) {
        throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function createCommonjsModule(fn, module16) {
      return module16 = {
        exports: {}
      }, fn(module16, module16.exports), module16.exports;
    }
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    var webmidi_min = createCommonjsModule(function(module16) {
      !function(scope) {
        function WebMidi() {
          if (WebMidi.prototype._singleton)
            throw new Error("WebMidi is a singleton, it cannot be instantiated directly.");
          (WebMidi.prototype._singleton = this)._inputs = [], this._outputs = [], this._userHandlers = {}, this._stateChangeQueue = [], this._processingStateChange = false, this._midiInterfaceEvents = ["connected", "disconnected"], this._nrpnBuffer = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []], this._nrpnEventsEnabled = true, this._nrpnTypes = ["entry", "increment", "decrement"], this._notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], this._semitones = {
            C: 0,
            D: 2,
            E: 4,
            F: 5,
            G: 7,
            A: 9,
            B: 11
          }, Object.defineProperties(this, {
            MIDI_SYSTEM_MESSAGES: {
              value: {
                sysex: 240,
                timecode: 241,
                songposition: 242,
                songselect: 243,
                tuningrequest: 246,
                sysexend: 247,
                clock: 248,
                start: 250,
                continue: 251,
                stop: 252,
                activesensing: 254,
                reset: 255,
                midimessage: 0,
                unknownsystemmessage: -1
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            MIDI_CHANNEL_MESSAGES: {
              value: {
                noteoff: 8,
                noteon: 9,
                keyaftertouch: 10,
                controlchange: 11,
                channelmode: 11,
                nrpn: 11,
                programchange: 12,
                channelaftertouch: 13,
                pitchbend: 14
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            MIDI_REGISTERED_PARAMETER: {
              value: {
                pitchbendrange: [0, 0],
                channelfinetuning: [0, 1],
                channelcoarsetuning: [0, 2],
                tuningprogram: [0, 3],
                tuningbank: [0, 4],
                modulationrange: [0, 5],
                azimuthangle: [61, 0],
                elevationangle: [61, 1],
                gain: [61, 2],
                distanceratio: [61, 3],
                maximumdistance: [61, 4],
                maximumdistancegain: [61, 5],
                referencedistanceratio: [61, 6],
                panspreadangle: [61, 7],
                rollangle: [61, 8]
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            MIDI_CONTROL_CHANGE_MESSAGES: {
              value: {
                bankselectcoarse: 0,
                modulationwheelcoarse: 1,
                breathcontrollercoarse: 2,
                footcontrollercoarse: 4,
                portamentotimecoarse: 5,
                dataentrycoarse: 6,
                volumecoarse: 7,
                balancecoarse: 8,
                pancoarse: 10,
                expressioncoarse: 11,
                effectcontrol1coarse: 12,
                effectcontrol2coarse: 13,
                generalpurposeslider1: 16,
                generalpurposeslider2: 17,
                generalpurposeslider3: 18,
                generalpurposeslider4: 19,
                bankselectfine: 32,
                modulationwheelfine: 33,
                breathcontrollerfine: 34,
                footcontrollerfine: 36,
                portamentotimefine: 37,
                dataentryfine: 38,
                volumefine: 39,
                balancefine: 40,
                panfine: 42,
                expressionfine: 43,
                effectcontrol1fine: 44,
                effectcontrol2fine: 45,
                holdpedal: 64,
                portamento: 65,
                sustenutopedal: 66,
                softpedal: 67,
                legatopedal: 68,
                hold2pedal: 69,
                soundvariation: 70,
                resonance: 71,
                soundreleasetime: 72,
                soundattacktime: 73,
                brightness: 74,
                soundcontrol6: 75,
                soundcontrol7: 76,
                soundcontrol8: 77,
                soundcontrol9: 78,
                soundcontrol10: 79,
                generalpurposebutton1: 80,
                generalpurposebutton2: 81,
                generalpurposebutton3: 82,
                generalpurposebutton4: 83,
                reverblevel: 91,
                tremololevel: 92,
                choruslevel: 93,
                celestelevel: 94,
                phaserlevel: 95,
                databuttonincrement: 96,
                databuttondecrement: 97,
                nonregisteredparametercoarse: 98,
                nonregisteredparameterfine: 99,
                registeredparametercoarse: 100,
                registeredparameterfine: 101
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            MIDI_NRPN_MESSAGES: {
              value: {
                entrymsb: 6,
                entrylsb: 38,
                increment: 96,
                decrement: 97,
                paramlsb: 98,
                parammsb: 99,
                nullactiveparameter: 127
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            MIDI_CHANNEL_MODE_MESSAGES: {
              value: {
                allsoundoff: 120,
                resetallcontrollers: 121,
                localcontrol: 122,
                allnotesoff: 123,
                omnimodeoff: 124,
                omnimodeon: 125,
                monomodeon: 126,
                polymodeon: 127
              },
              writable: false,
              enumerable: true,
              configurable: false
            },
            octaveOffset: {
              value: 0,
              writable: true,
              enumerable: true,
              configurable: false
            }
          }), Object.defineProperties(this, {
            supported: {
              enumerable: true,
              get: function() {
                return "requestMIDIAccess" in navigator;
              }
            },
            enabled: {
              enumerable: true,
              get: function() {
                return void 0 !== this.interface;
              }.bind(this)
            },
            inputs: {
              enumerable: true,
              get: function() {
                return this._inputs;
              }.bind(this)
            },
            outputs: {
              enumerable: true,
              get: function() {
                return this._outputs;
              }.bind(this)
            },
            sysexEnabled: {
              enumerable: true,
              get: function() {
                return !(!this.interface || !this.interface.sysexEnabled);
              }.bind(this)
            },
            nrpnEventsEnabled: {
              enumerable: true,
              get: function() {
                return !!this._nrpnEventsEnabled;
              }.bind(this),
              set: function(enabled) {
                return this._nrpnEventsEnabled = enabled, this._nrpnEventsEnabled;
              }
            },
            nrpnTypes: {
              enumerable: true,
              get: function() {
                return this._nrpnTypes;
              }.bind(this)
            },
            time: {
              enumerable: true,
              get: function() {
                return performance.now();
              }
            }
          });
        }
        var wm = new WebMidi();
        function Input(midiInput) {
          var that = this;
          this._userHandlers = {
            channel: {},
            system: {}
          }, this._midiInput = midiInput, Object.defineProperties(this, {
            connection: {
              enumerable: true,
              get: function() {
                return that._midiInput.connection;
              }
            },
            id: {
              enumerable: true,
              get: function() {
                return that._midiInput.id;
              }
            },
            manufacturer: {
              enumerable: true,
              get: function() {
                return that._midiInput.manufacturer;
              }
            },
            name: {
              enumerable: true,
              get: function() {
                return that._midiInput.name;
              }
            },
            state: {
              enumerable: true,
              get: function() {
                return that._midiInput.state;
              }
            },
            type: {
              enumerable: true,
              get: function() {
                return that._midiInput.type;
              }
            }
          }), this._initializeUserHandlers(), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);
        }
        function Output2(midiOutput) {
          var that = this;
          this._midiOutput = midiOutput, Object.defineProperties(this, {
            connection: {
              enumerable: true,
              get: function() {
                return that._midiOutput.connection;
              }
            },
            id: {
              enumerable: true,
              get: function() {
                return that._midiOutput.id;
              }
            },
            manufacturer: {
              enumerable: true,
              get: function() {
                return that._midiOutput.manufacturer;
              }
            },
            name: {
              enumerable: true,
              get: function() {
                return that._midiOutput.name;
              }
            },
            state: {
              enumerable: true,
              get: function() {
                return that._midiOutput.state;
              }
            },
            type: {
              enumerable: true,
              get: function() {
                return that._midiOutput.type;
              }
            }
          });
        }
        WebMidi.prototype.enable = function(callback, sysex) {
          this.enabled || (this.supported ? navigator.requestMIDIAccess({
            sysex
          }).then(function(midiAccess) {
            var promiseTimeout, events = [], promises = [];
            this.interface = midiAccess, this._resetInterfaceUserHandlers(), this.interface.onstatechange = function(e) {
              events.push(e);
            };
            for (var inputs = midiAccess.inputs.values(), input = inputs.next(); input && !input.done; input = inputs.next())
              promises.push(input.value.open());
            for (var outputs = midiAccess.outputs.values(), output = outputs.next(); output && !output.done; output = outputs.next())
              promises.push(output.value.open());
            function onPortsOpen() {
              clearTimeout(promiseTimeout), this._updateInputsAndOutputs(), this.interface.onstatechange = this._onInterfaceStateChange.bind(this), "function" == typeof callback && callback.call(this), events.forEach(function(event2) {
                this._onInterfaceStateChange(event2);
              }.bind(this));
            }
            promiseTimeout = setTimeout(onPortsOpen.bind(this), 200), Promise && Promise.all(promises).catch(function(err) {
            }).then(onPortsOpen.bind(this));
          }.bind(this), function(err) {
            "function" == typeof callback && callback.call(this, err);
          }.bind(this)) : "function" == typeof callback && callback(new Error("The Web MIDI API is not supported by your browser.")));
        }, WebMidi.prototype.disable = function() {
          if (!this.supported)
            throw new Error("The Web MIDI API is not supported by your browser.");
          this.interface && (this.interface.onstatechange = void 0), this.interface = void 0, this._inputs = [], this._outputs = [], this._nrpnEventsEnabled = true, this._resetInterfaceUserHandlers();
        }, WebMidi.prototype.addListener = function(type, listener) {
          if (!this.enabled)
            throw new Error("WebMidi must be enabled before adding event listeners.");
          if ("function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (!(0 <= this._midiInterfaceEvents.indexOf(type)))
            throw new TypeError("The specified event type is not supported.");
          return this._userHandlers[type].push(listener), this;
        }, WebMidi.prototype.hasListener = function(type, listener) {
          if (!this.enabled)
            throw new Error("WebMidi must be enabled before checking event listeners.");
          if ("function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (!(0 <= this._midiInterfaceEvents.indexOf(type)))
            throw new TypeError("The specified event type is not supported.");
          for (var o = 0; o < this._userHandlers[type].length; o++)
            if (this._userHandlers[type][o] === listener)
              return true;
          return false;
        }, WebMidi.prototype.removeListener = function(type, listener) {
          if (!this.enabled)
            throw new Error("WebMidi must be enabled before removing event listeners.");
          if (void 0 !== listener && "function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (0 <= this._midiInterfaceEvents.indexOf(type))
            if (listener)
              for (var o = 0; o < this._userHandlers[type].length; o++)
                this._userHandlers[type][o] === listener && this._userHandlers[type].splice(o, 1);
            else
              this._userHandlers[type] = [];
          else {
            if (void 0 !== type)
              throw new TypeError("The specified event type is not supported.");
            this._resetInterfaceUserHandlers();
          }
          return this;
        }, WebMidi.prototype.toMIDIChannels = function(channel) {
          var channels;
          if ("all" === channel || void 0 === channel)
            channels = ["all"];
          else {
            if ("none" === channel)
              return channels = [];
            channels = Array.isArray(channel) ? channel : [channel];
          }
          return -1 < channels.indexOf("all") && (channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]), channels.map(function(ch) {
            return parseInt(ch);
          }).filter(function(ch) {
            return 1 <= ch && ch <= 16;
          });
        }, WebMidi.prototype.getInputById = function(id) {
          if (!this.enabled)
            throw new Error("WebMidi is not enabled.");
          id = String(id);
          for (var i3 = 0; i3 < this.inputs.length; i3++)
            if (this.inputs[i3].id === id)
              return this.inputs[i3];
          return false;
        }, WebMidi.prototype.getOutputById = function(id) {
          if (!this.enabled)
            throw new Error("WebMidi is not enabled.");
          id = String(id);
          for (var i3 = 0; i3 < this.outputs.length; i3++)
            if (this.outputs[i3].id === id)
              return this.outputs[i3];
          return false;
        }, WebMidi.prototype.getInputByName = function(name) {
          if (!this.enabled)
            throw new Error("WebMidi is not enabled.");
          for (var i3 = 0; i3 < this.inputs.length; i3++)
            if (~this.inputs[i3].name.indexOf(name))
              return this.inputs[i3];
          return false;
        }, WebMidi.prototype.getOctave = function(number) {
          if (null != number && 0 <= number && number <= 127)
            return Math.floor(Math.floor(number) / 12 - 1) + Math.floor(wm.octaveOffset);
        }, WebMidi.prototype.getOutputByName = function(name) {
          if (!this.enabled)
            throw new Error("WebMidi is not enabled.");
          for (var i3 = 0; i3 < this.outputs.length; i3++)
            if (~this.outputs[i3].name.indexOf(name))
              return this.outputs[i3];
          return false;
        }, WebMidi.prototype.guessNoteNumber = function(input) {
          var output = false;
          if (input && input.toFixed && 0 <= input && input <= 127 ? output = Math.round(input) : 0 <= parseInt(input) && parseInt(input) <= 127 ? output = parseInt(input) : ("string" == typeof input || input instanceof String) && (output = this.noteNameToNumber(input)), false === output)
            throw new Error("Invalid input value (" + input + ").");
          return output;
        }, WebMidi.prototype.noteNameToNumber = function(name) {
          "string" != typeof name && (name = "");
          var matches = name.match(/([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)/i);
          if (!matches)
            throw new RangeError("Invalid note name.");
          var semitones = wm._semitones[matches[1].toUpperCase()], result = 12 * (parseInt(matches[3]) + 1 - Math.floor(wm.octaveOffset)) + semitones;
          if (-1 < matches[2].toLowerCase().indexOf("b") ? result -= matches[2].length : -1 < matches[2].toLowerCase().indexOf("#") && (result += matches[2].length), result < 0 || 127 < result)
            throw new RangeError("Invalid note name or note outside valid range.");
          return result;
        }, WebMidi.prototype._updateInputsAndOutputs = function() {
          this._updateInputs(), this._updateOutputs();
        }, WebMidi.prototype._updateInputs = function() {
          for (var i3 = 0; i3 < this._inputs.length; i3++) {
            for (var remove = true, updated = this.interface.inputs.values(), input = updated.next(); input && !input.done; input = updated.next())
              if (this._inputs[i3]._midiInput === input.value) {
                remove = false;
                break;
              }
            remove && this._inputs.splice(i3, 1);
          }
          this.interface && this.interface.inputs.forEach(function(nInput) {
            for (var add = true, j = 0; j < this._inputs.length; j++)
              this._inputs[j]._midiInput === nInput && (add = false);
            add && this._inputs.push(new Input(nInput));
          }.bind(this));
        }, WebMidi.prototype._updateOutputs = function() {
          for (var i3 = 0; i3 < this._outputs.length; i3++) {
            for (var remove = true, updated = this.interface.outputs.values(), output = updated.next(); output && !output.done; output = updated.next())
              if (this._outputs[i3]._midiOutput === output.value) {
                remove = false;
                break;
              }
            remove && this._outputs.splice(i3, 1);
          }
          this.interface && this.interface.outputs.forEach(function(nOutput) {
            for (var add = true, j = 0; j < this._outputs.length; j++)
              this._outputs[j]._midiOutput === nOutput && (add = false);
            add && this._outputs.push(new Output2(nOutput));
          }.bind(this));
        }, WebMidi.prototype._onInterfaceStateChange = function(e) {
          this._updateInputsAndOutputs();
          var event2 = {
            timestamp: e.timeStamp,
            type: e.port.state
          };
          this.interface && "connected" === e.port.state ? "output" === e.port.type ? event2.port = this.getOutputById(e.port.id) : "input" === e.port.type && (event2.port = this.getInputById(e.port.id)) : event2.port = {
            connection: "closed",
            id: e.port.id,
            manufacturer: e.port.manufacturer,
            name: e.port.name,
            state: e.port.state,
            type: e.port.type
          }, this._userHandlers[e.port.state].forEach(function(handler) {
            handler(event2);
          });
        }, WebMidi.prototype._resetInterfaceUserHandlers = function() {
          for (var i3 = 0; i3 < this._midiInterfaceEvents.length; i3++)
            this._userHandlers[this._midiInterfaceEvents[i3]] = [];
        }, Input.prototype.on = Input.prototype.addListener = function(type, channel, listener) {
          var that = this;
          if (void 0 === channel && (channel = "all"), Array.isArray(channel) || (channel = [channel]), channel.forEach(function(item) {
            if ("all" !== item && !(1 <= item && item <= 16))
              throw new RangeError("The 'channel' parameter is invalid.");
          }), "function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (void 0 !== wm.MIDI_SYSTEM_MESSAGES[type])
            this._userHandlers.system[type] || (this._userHandlers.system[type] = []), this._userHandlers.system[type].push(listener);
          else {
            if (void 0 === wm.MIDI_CHANNEL_MESSAGES[type])
              throw new TypeError("The specified event type is not supported.");
            if (-1 < channel.indexOf("all")) {
              channel = [];
              for (var j = 1; j <= 16; j++)
                channel.push(j);
            }
            this._userHandlers.channel[type] || (this._userHandlers.channel[type] = []), channel.forEach(function(ch) {
              that._userHandlers.channel[type][ch] || (that._userHandlers.channel[type][ch] = []), that._userHandlers.channel[type][ch].push(listener);
            });
          }
          return this;
        }, Input.prototype.hasListener = function(type, channel, listener) {
          var that = this;
          if ("function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (void 0 === channel && (channel = "all"), channel.constructor !== Array && (channel = [channel]), void 0 !== wm.MIDI_SYSTEM_MESSAGES[type]) {
            for (var o = 0; o < this._userHandlers.system[type].length; o++)
              if (this._userHandlers.system[type][o] === listener)
                return true;
          } else if (void 0 !== wm.MIDI_CHANNEL_MESSAGES[type]) {
            if (-1 < channel.indexOf("all")) {
              channel = [];
              for (var j = 1; j <= 16; j++)
                channel.push(j);
            }
            return !!this._userHandlers.channel[type] && channel.every(function(chNum) {
              var listeners = that._userHandlers.channel[type][chNum];
              return listeners && -1 < listeners.indexOf(listener);
            });
          }
          return false;
        }, Input.prototype.removeListener = function(type, channel, listener) {
          var that = this;
          if (void 0 !== listener && "function" != typeof listener)
            throw new TypeError("The 'listener' parameter must be a function.");
          if (void 0 === channel && (channel = "all"), channel.constructor !== Array && (channel = [channel]), void 0 !== wm.MIDI_SYSTEM_MESSAGES[type])
            if (void 0 === listener)
              this._userHandlers.system[type] = [];
            else
              for (var o = 0; o < this._userHandlers.system[type].length; o++)
                this._userHandlers.system[type][o] === listener && this._userHandlers.system[type].splice(o, 1);
          else if (void 0 !== wm.MIDI_CHANNEL_MESSAGES[type]) {
            if (-1 < channel.indexOf("all")) {
              channel = [];
              for (var j = 1; j <= 16; j++)
                channel.push(j);
            }
            if (!this._userHandlers.channel[type])
              return this;
            channel.forEach(function(chNum) {
              var listeners = that._userHandlers.channel[type][chNum];
              if (listeners)
                if (void 0 === listener)
                  that._userHandlers.channel[type][chNum] = [];
                else
                  for (var l = 0; l < listeners.length; l++)
                    listeners[l] === listener && listeners.splice(l, 1);
            });
          } else {
            if (void 0 !== type)
              throw new TypeError("The specified event type is not supported.");
            this._initializeUserHandlers();
          }
          return this;
        }, Input.prototype._initializeUserHandlers = function() {
          for (var prop1 in wm.MIDI_CHANNEL_MESSAGES)
            wm.MIDI_CHANNEL_MESSAGES.hasOwnProperty(prop1) && (this._userHandlers.channel[prop1] = {});
          for (var prop2 in wm.MIDI_SYSTEM_MESSAGES)
            wm.MIDI_SYSTEM_MESSAGES.hasOwnProperty(prop2) && (this._userHandlers.system[prop2] = []);
        }, Input.prototype._onMidiMessage = function(e) {
          if (0 < this._userHandlers.system.midimessage.length) {
            var event2 = {
              target: this,
              data: e.data,
              timestamp: e.timeStamp,
              type: "midimessage"
            };
            this._userHandlers.system.midimessage.forEach(function(callback) {
              callback(event2);
            });
          }
          e.data[0] < 240 ? (this._parseChannelEvent(e), this._parseNrpnEvent(e)) : e.data[0] <= 255 && this._parseSystemEvent(e);
        }, Input.prototype._parseNrpnEvent = function(e) {
          var data1, data2, command = e.data[0] >> 4, channelBufferIndex = 15 & e.data[0], channel = 1 + channelBufferIndex;
          if (1 < e.data.length && (data1 = e.data[1], data2 = 2 < e.data.length ? e.data[2] : void 0), wm.nrpnEventsEnabled && command === wm.MIDI_CHANNEL_MESSAGES.controlchange && (data1 >= wm.MIDI_NRPN_MESSAGES.increment && data1 <= wm.MIDI_NRPN_MESSAGES.parammsb || data1 === wm.MIDI_NRPN_MESSAGES.entrymsb || data1 === wm.MIDI_NRPN_MESSAGES.entrylsb)) {
            var ccEvent = {
              target: this,
              type: "controlchange",
              data: e.data,
              timestamp: e.timeStamp,
              channel,
              controller: {
                number: data1,
                name: this.getCcNameByNumber(data1)
              },
              value: data2
            };
            if (ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.parammsb && ccEvent.value != wm.MIDI_NRPN_MESSAGES.nullactiveparameter)
              wm._nrpnBuffer[channelBufferIndex] = [], wm._nrpnBuffer[channelBufferIndex][0] = ccEvent;
            else if (1 === wm._nrpnBuffer[channelBufferIndex].length && ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.paramlsb)
              wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
            else if (2 !== wm._nrpnBuffer[channelBufferIndex].length || ccEvent.controller.number !== wm.MIDI_NRPN_MESSAGES.increment && ccEvent.controller.number !== wm.MIDI_NRPN_MESSAGES.decrement && ccEvent.controller.number !== wm.MIDI_NRPN_MESSAGES.entrymsb)
              if (3 === wm._nrpnBuffer[channelBufferIndex].length && wm._nrpnBuffer[channelBufferIndex][2].number === wm.MIDI_NRPN_MESSAGES.entrymsb && ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.entrylsb)
                wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
              else if (3 <= wm._nrpnBuffer[channelBufferIndex].length && wm._nrpnBuffer[channelBufferIndex].length <= 4 && ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.parammsb && ccEvent.value === wm.MIDI_NRPN_MESSAGES.nullactiveparameter)
                wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
              else if (4 <= wm._nrpnBuffer[channelBufferIndex].length && wm._nrpnBuffer[channelBufferIndex].length <= 5 && ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.paramlsb && ccEvent.value === wm.MIDI_NRPN_MESSAGES.nullactiveparameter) {
                wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
                var rawData = [];
                wm._nrpnBuffer[channelBufferIndex].forEach(function(ev) {
                  rawData.push(ev.data);
                });
                var nrpnNumber = wm._nrpnBuffer[channelBufferIndex][0].value << 7 | wm._nrpnBuffer[channelBufferIndex][1].value, nrpnValue = wm._nrpnBuffer[channelBufferIndex][2].value;
                6 === wm._nrpnBuffer[channelBufferIndex].length && (nrpnValue = wm._nrpnBuffer[channelBufferIndex][2].value << 7 | wm._nrpnBuffer[channelBufferIndex][3].value);
                var nrpnControllerType = "";
                switch (wm._nrpnBuffer[channelBufferIndex][2].controller.number) {
                  case wm.MIDI_NRPN_MESSAGES.entrymsb:
                    nrpnControllerType = wm._nrpnTypes[0];
                    break;
                  case wm.MIDI_NRPN_MESSAGES.increment:
                    nrpnControllerType = wm._nrpnTypes[1];
                    break;
                  case wm.MIDI_NRPN_MESSAGES.decrement:
                    nrpnControllerType = wm._nrpnTypes[2];
                    break;
                  default:
                    throw new Error("The NPRN type was unidentifiable.");
                }
                var nrpnEvent = {
                  timestamp: ccEvent.timestamp,
                  channel: ccEvent.channel,
                  type: "nrpn",
                  data: rawData,
                  controller: {
                    number: nrpnNumber,
                    type: nrpnControllerType,
                    name: "Non-Registered Parameter " + nrpnNumber
                  },
                  value: nrpnValue
                };
                wm._nrpnBuffer[channelBufferIndex] = [], this._userHandlers.channel[nrpnEvent.type] && this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel] && this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel].forEach(function(callback) {
                  callback(nrpnEvent);
                });
              } else
                wm._nrpnBuffer[channelBufferIndex] = [];
            else
              wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
          }
        }, Input.prototype._parseChannelEvent = function(e) {
          var data1, data2, command = e.data[0] >> 4, channel = 1 + (15 & e.data[0]);
          1 < e.data.length && (data1 = e.data[1], data2 = 2 < e.data.length ? e.data[2] : void 0);
          var event2 = {
            target: this,
            data: e.data,
            timestamp: e.timeStamp,
            channel
          };
          command === wm.MIDI_CHANNEL_MESSAGES.noteoff || command === wm.MIDI_CHANNEL_MESSAGES.noteon && 0 === data2 ? (event2.type = "noteoff", event2.note = {
            number: data1,
            name: wm._notes[data1 % 12],
            octave: wm.getOctave(data1)
          }, event2.velocity = data2 / 127, event2.rawVelocity = data2) : command === wm.MIDI_CHANNEL_MESSAGES.noteon ? (event2.type = "noteon", event2.note = {
            number: data1,
            name: wm._notes[data1 % 12],
            octave: wm.getOctave(data1)
          }, event2.velocity = data2 / 127, event2.rawVelocity = data2) : command === wm.MIDI_CHANNEL_MESSAGES.keyaftertouch ? (event2.type = "keyaftertouch", event2.note = {
            number: data1,
            name: wm._notes[data1 % 12],
            octave: wm.getOctave(data1)
          }, event2.value = data2 / 127) : command === wm.MIDI_CHANNEL_MESSAGES.controlchange && 0 <= data1 && data1 <= 119 ? (event2.type = "controlchange", event2.controller = {
            number: data1,
            name: this.getCcNameByNumber(data1)
          }, event2.value = data2) : command === wm.MIDI_CHANNEL_MESSAGES.channelmode && 120 <= data1 && data1 <= 127 ? (event2.type = "channelmode", event2.controller = {
            number: data1,
            name: this.getChannelModeByNumber(data1)
          }, event2.value = data2) : command === wm.MIDI_CHANNEL_MESSAGES.programchange ? (event2.type = "programchange", event2.value = data1) : command === wm.MIDI_CHANNEL_MESSAGES.channelaftertouch ? (event2.type = "channelaftertouch", event2.value = data1 / 127) : command === wm.MIDI_CHANNEL_MESSAGES.pitchbend ? (event2.type = "pitchbend", event2.value = ((data2 << 7) + data1 - 8192) / 8192) : event2.type = "unknownchannelmessage", this._userHandlers.channel[event2.type] && this._userHandlers.channel[event2.type][channel] && this._userHandlers.channel[event2.type][channel].forEach(function(callback) {
            callback(event2);
          });
        }, Input.prototype.getCcNameByNumber = function(number) {
          if (!(0 <= (number = Math.floor(number)) && number <= 119))
            throw new RangeError("The control change number must be between 0 and 119.");
          for (var cc in wm.MIDI_CONTROL_CHANGE_MESSAGES)
            if (wm.MIDI_CONTROL_CHANGE_MESSAGES.hasOwnProperty(cc) && number === wm.MIDI_CONTROL_CHANGE_MESSAGES[cc])
              return cc;
        }, Input.prototype.getChannelModeByNumber = function(number) {
          if (!(120 <= (number = Math.floor(number)) && status <= 127))
            throw new RangeError("The control change number must be between 120 and 127.");
          for (var cm in wm.MIDI_CHANNEL_MODE_MESSAGES)
            if (wm.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(cm) && number === wm.MIDI_CHANNEL_MODE_MESSAGES[cm])
              return cm;
        }, Input.prototype._parseSystemEvent = function(e) {
          var command = e.data[0], event2 = {
            target: this,
            data: e.data,
            timestamp: e.timeStamp
          };
          command === wm.MIDI_SYSTEM_MESSAGES.sysex ? event2.type = "sysex" : command === wm.MIDI_SYSTEM_MESSAGES.timecode ? event2.type = "timecode" : command === wm.MIDI_SYSTEM_MESSAGES.songposition ? event2.type = "songposition" : command === wm.MIDI_SYSTEM_MESSAGES.songselect ? (event2.type = "songselect", event2.song = e.data[1]) : command === wm.MIDI_SYSTEM_MESSAGES.tuningrequest ? event2.type = "tuningrequest" : command === wm.MIDI_SYSTEM_MESSAGES.clock ? event2.type = "clock" : command === wm.MIDI_SYSTEM_MESSAGES.start ? event2.type = "start" : command === wm.MIDI_SYSTEM_MESSAGES.continue ? event2.type = "continue" : command === wm.MIDI_SYSTEM_MESSAGES.stop ? event2.type = "stop" : command === wm.MIDI_SYSTEM_MESSAGES.activesensing ? event2.type = "activesensing" : command === wm.MIDI_SYSTEM_MESSAGES.reset ? event2.type = "reset" : event2.type = "unknownsystemmessage", this._userHandlers.system[event2.type] && this._userHandlers.system[event2.type].forEach(function(callback) {
            callback(event2);
          });
        }, Output2.prototype.send = function(status2, data, timestamp) {
          if (!(128 <= status2 && status2 <= 255))
            throw new RangeError("The status byte must be an integer between 128 (0x80) and 255 (0xFF).");
          void 0 === data && (data = []), Array.isArray(data) || (data = [data]);
          var message = [];
          return data.forEach(function(item) {
            var parsed = Math.floor(item);
            if (!(0 <= parsed && parsed <= 255))
              throw new RangeError("Data bytes must be integers between 0 (0x00) and 255 (0xFF).");
            message.push(parsed);
          }), this._midiOutput.send([status2].concat(message), parseFloat(timestamp) || 0), this;
        }, Output2.prototype.sendSysex = function(manufacturer, data, options) {
          if (!wm.sysexEnabled)
            throw new Error("Sysex message support must first be activated.");
          return options = options || {}, manufacturer = [].concat(manufacturer), data.forEach(function(item) {
            if (item < 0 || 127 < item)
              throw new RangeError("The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).");
          }), data = manufacturer.concat(data, wm.MIDI_SYSTEM_MESSAGES.sysexend), this.send(wm.MIDI_SYSTEM_MESSAGES.sysex, data, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendTimecodeQuarterFrame = function(value2, options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.timecode, value2, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendSongPosition = function(value2, options) {
          options = options || {};
          var msb = (value2 = Math.floor(value2) || 0) >> 7 & 127, lsb = 127 & value2;
          return this.send(wm.MIDI_SYSTEM_MESSAGES.songposition, [msb, lsb], this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendSongSelect = function(value2, options) {
          if (options = options || {}, !(0 <= (value2 = Math.floor(value2)) && value2 <= 127))
            throw new RangeError("The song number must be between 0 and 127.");
          return this.send(wm.MIDI_SYSTEM_MESSAGES.songselect, [value2], this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendTuningRequest = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.tuningrequest, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendClock = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.clock, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendStart = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.start, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendContinue = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.continue, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendStop = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.stop, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendActiveSensing = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.activesensing, [], this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.sendReset = function(options) {
          return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.reset, void 0, this._parseTimeParameter(options.time)), this;
        }, Output2.prototype.stopNote = function(note2, channel, options) {
          if ("all" === note2)
            return this.sendChannelMode("allnotesoff", 0, channel, options);
          var nVelocity = 64;
          return (options = options || {}).rawVelocity ? !isNaN(options.velocity) && 0 <= options.velocity && options.velocity <= 127 && (nVelocity = options.velocity) : !isNaN(options.velocity) && 0 <= options.velocity && options.velocity <= 1 && (nVelocity = 127 * options.velocity), this._convertNoteToArray(note2).forEach(function(item) {
            wm.toMIDIChannels(channel).forEach(function(ch) {
              this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (ch - 1), [item, Math.round(nVelocity)], this._parseTimeParameter(options.time));
            }.bind(this));
          }.bind(this)), this;
        }, Output2.prototype.playNote = function(note2, channel, options) {
          var time2, nVelocity = 64;
          if ((options = options || {}).rawVelocity ? !isNaN(options.velocity) && 0 <= options.velocity && options.velocity <= 127 && (nVelocity = options.velocity) : !isNaN(options.velocity) && 0 <= options.velocity && options.velocity <= 1 && (nVelocity = 127 * options.velocity), time2 = this._parseTimeParameter(options.time), this._convertNoteToArray(note2).forEach(function(item) {
            wm.toMIDIChannels(channel).forEach(function(ch) {
              this.send((wm.MIDI_CHANNEL_MESSAGES.noteon << 4) + (ch - 1), [item, Math.round(nVelocity)], time2);
            }.bind(this));
          }.bind(this)), !isNaN(options.duration)) {
            options.duration <= 0 && (options.duration = 0);
            var nRelease = 64;
            options.rawVelocity ? !isNaN(options.release) && 0 <= options.release && options.release <= 127 && (nRelease = options.release) : !isNaN(options.release) && 0 <= options.release && options.release <= 1 && (nRelease = 127 * options.release), this._convertNoteToArray(note2).forEach(function(item) {
              wm.toMIDIChannels(channel).forEach(function(ch) {
                this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (ch - 1), [item, Math.round(nRelease)], (time2 || wm.time) + options.duration);
              }.bind(this));
            }.bind(this));
          }
          return this;
        }, Output2.prototype.sendKeyAftertouch = function(note2, channel, pressure, options) {
          var that = this;
          if (options = options || {}, channel < 1 || 16 < channel)
            throw new RangeError("The channel must be between 1 and 16.");
          (isNaN(pressure) || pressure < 0 || 1 < pressure) && (pressure = 0.5);
          var nPressure = Math.round(127 * pressure);
          return this._convertNoteToArray(note2).forEach(function(item) {
            wm.toMIDIChannels(channel).forEach(function(ch) {
              that.send((wm.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (ch - 1), [item, nPressure], that._parseTimeParameter(options.time));
            });
          }), this;
        }, Output2.prototype.sendControlChange = function(controller, value2, channel, options) {
          if (options = options || {}, "string" == typeof controller) {
            if (void 0 === (controller = wm.MIDI_CONTROL_CHANGE_MESSAGES[controller]))
              throw new TypeError("Invalid controller name.");
          } else if (!(0 <= (controller = Math.floor(controller)) && controller <= 119))
            throw new RangeError("Controller numbers must be between 0 and 119.");
          if (!(0 <= (value2 = Math.floor(value2) || 0) && value2 <= 127))
            throw new RangeError("Controller value must be between 0 and 127.");
          return wm.toMIDIChannels(channel).forEach(function(ch) {
            this.send((wm.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (ch - 1), [controller, value2], this._parseTimeParameter(options.time));
          }.bind(this)), this;
        }, Output2.prototype._selectRegisteredParameter = function(parameter, channel, time2) {
          var that = this;
          if (parameter[0] = Math.floor(parameter[0]), !(0 <= parameter[0] && parameter[0] <= 127))
            throw new RangeError("The control65 value must be between 0 and 127");
          if (parameter[1] = Math.floor(parameter[1]), !(0 <= parameter[1] && parameter[1] <= 127))
            throw new RangeError("The control64 value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.sendControlChange(101, parameter[0], channel, {
              time: time2
            }), that.sendControlChange(100, parameter[1], channel, {
              time: time2
            });
          }), this;
        }, Output2.prototype._selectNonRegisteredParameter = function(parameter, channel, time2) {
          var that = this;
          if (parameter[0] = Math.floor(parameter[0]), !(0 <= parameter[0] && parameter[0] <= 127))
            throw new RangeError("The control63 value must be between 0 and 127");
          if (parameter[1] = Math.floor(parameter[1]), !(0 <= parameter[1] && parameter[1] <= 127))
            throw new RangeError("The control62 value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.sendControlChange(99, parameter[0], channel, {
              time: time2
            }), that.sendControlChange(98, parameter[1], channel, {
              time: time2
            });
          }), this;
        }, Output2.prototype._setCurrentRegisteredParameter = function(data, channel, time2) {
          var that = this;
          if ((data = [].concat(data))[0] = Math.floor(data[0]), !(0 <= data[0] && data[0] <= 127))
            throw new RangeError("The msb value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.sendControlChange(6, data[0], channel, {
              time: time2
            });
          }), data[1] = Math.floor(data[1]), 0 <= data[1] && data[1] <= 127 && wm.toMIDIChannels(channel).forEach(function() {
            that.sendControlChange(38, data[1], channel, {
              time: time2
            });
          }), this;
        }, Output2.prototype._deselectRegisteredParameter = function(channel, time2) {
          var that = this;
          return wm.toMIDIChannels(channel).forEach(function() {
            that.sendControlChange(101, 127, channel, {
              time: time2
            }), that.sendControlChange(100, 127, channel, {
              time: time2
            });
          }), this;
        }, Output2.prototype.setRegisteredParameter = function(parameter, data, channel, options) {
          var that = this;
          if (options = options || {}, !Array.isArray(parameter)) {
            if (!wm.MIDI_REGISTERED_PARAMETER[parameter])
              throw new Error("The specified parameter is not available.");
            parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
          }
          return wm.toMIDIChannels(channel).forEach(function() {
            that._selectRegisteredParameter(parameter, channel, options.time), that._setCurrentRegisteredParameter(data, channel, options.time), that._deselectRegisteredParameter(channel, options.time);
          }), this;
        }, Output2.prototype.setNonRegisteredParameter = function(parameter, data, channel, options) {
          var that = this;
          if (options = options || {}, !(0 <= parameter[0] && parameter[0] <= 127 && 0 <= parameter[1] && parameter[1] <= 127))
            throw new Error("Position 0 and 1 of the 2-position parameter array must both be between 0 and 127.");
          return data = [].concat(data), wm.toMIDIChannels(channel).forEach(function() {
            that._selectNonRegisteredParameter(parameter, channel, options.time), that._setCurrentRegisteredParameter(data, channel, options.time), that._deselectRegisteredParameter(channel, options.time);
          }), this;
        }, Output2.prototype.incrementRegisteredParameter = function(parameter, channel, options) {
          var that = this;
          if (options = options || {}, !Array.isArray(parameter)) {
            if (!wm.MIDI_REGISTERED_PARAMETER[parameter])
              throw new Error("The specified parameter is not available.");
            parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
          }
          return wm.toMIDIChannels(channel).forEach(function() {
            that._selectRegisteredParameter(parameter, channel, options.time), that.sendControlChange(96, 0, channel, {
              time: options.time
            }), that._deselectRegisteredParameter(channel, options.time);
          }), this;
        }, Output2.prototype.decrementRegisteredParameter = function(parameter, channel, options) {
          if (options = options || {}, !Array.isArray(parameter)) {
            if (!wm.MIDI_REGISTERED_PARAMETER[parameter])
              throw new TypeError("The specified parameter is not available.");
            parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
          }
          return wm.toMIDIChannels(channel).forEach(function() {
            this._selectRegisteredParameter(parameter, channel, options.time), this.sendControlChange(97, 0, channel, {
              time: options.time
            }), this._deselectRegisteredParameter(channel, options.time);
          }.bind(this)), this;
        }, Output2.prototype.setPitchBendRange = function(semitones, cents, channel, options) {
          var that = this;
          if (options = options || {}, !(0 <= (semitones = Math.floor(semitones) || 0) && semitones <= 127))
            throw new RangeError("The semitones value must be between 0 and 127");
          if (!(0 <= (cents = Math.floor(cents) || 0) && cents <= 127))
            throw new RangeError("The cents value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.setRegisteredParameter("pitchbendrange", [semitones, cents], channel, {
              time: options.time
            });
          }), this;
        }, Output2.prototype.setModulationRange = function(semitones, cents, channel, options) {
          var that = this;
          if (options = options || {}, !(0 <= (semitones = Math.floor(semitones) || 0) && semitones <= 127))
            throw new RangeError("The semitones value must be between 0 and 127");
          if (!(0 <= (cents = Math.floor(cents) || 0) && cents <= 127))
            throw new RangeError("The cents value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.setRegisteredParameter("modulationrange", [semitones, cents], channel, {
              time: options.time
            });
          }), this;
        }, Output2.prototype.setMasterTuning = function(value2, channel, options) {
          var that = this;
          if (options = options || {}, (value2 = parseFloat(value2) || 0) <= -65 || 64 <= value2)
            throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
          var coarse = Math.floor(value2) + 64, fine = value2 - Math.floor(value2), msb = (fine = Math.round((fine + 1) / 2 * 16383)) >> 7 & 127, lsb = 127 & fine;
          return wm.toMIDIChannels(channel).forEach(function() {
            that.setRegisteredParameter("channelcoarsetuning", coarse, channel, {
              time: options.time
            }), that.setRegisteredParameter("channelfinetuning", [msb, lsb], channel, {
              time: options.time
            });
          }), this;
        }, Output2.prototype.setTuningProgram = function(value2, channel, options) {
          var that = this;
          if (options = options || {}, !(0 <= (value2 = Math.floor(value2)) && value2 <= 127))
            throw new RangeError("The program value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.setRegisteredParameter("tuningprogram", value2, channel, {
              time: options.time
            });
          }), this;
        }, Output2.prototype.setTuningBank = function(value2, channel, options) {
          var that = this;
          if (options = options || {}, !(0 <= (value2 = Math.floor(value2) || 0) && value2 <= 127))
            throw new RangeError("The bank value must be between 0 and 127");
          return wm.toMIDIChannels(channel).forEach(function() {
            that.setRegisteredParameter("tuningbank", value2, channel, {
              time: options.time
            });
          }), this;
        }, Output2.prototype.sendChannelMode = function(command, value2, channel, options) {
          if (options = options || {}, "string" == typeof command) {
            if (!(command = wm.MIDI_CHANNEL_MODE_MESSAGES[command]))
              throw new TypeError("Invalid channel mode message name.");
          } else if (!(120 <= (command = Math.floor(command)) && command <= 127))
            throw new RangeError("Channel mode numerical identifiers must be between 120 and 127.");
          if ((value2 = Math.floor(value2) || 0) < 0 || 127 < value2)
            throw new RangeError("Value must be an integer between 0 and 127.");
          return wm.toMIDIChannels(channel).forEach(function(ch) {
            this.send((wm.MIDI_CHANNEL_MESSAGES.channelmode << 4) + (ch - 1), [command, value2], this._parseTimeParameter(options.time));
          }.bind(this)), this;
        }, Output2.prototype.sendProgramChange = function(program, channel, options) {
          var that = this;
          if (options = options || {}, program = Math.floor(program), isNaN(program) || program < 0 || 127 < program)
            throw new RangeError("Program numbers must be between 0 and 127.");
          return wm.toMIDIChannels(channel).forEach(function(ch) {
            that.send((wm.MIDI_CHANNEL_MESSAGES.programchange << 4) + (ch - 1), [program], that._parseTimeParameter(options.time));
          }), this;
        }, Output2.prototype.sendChannelAftertouch = function(pressure, channel, options) {
          var that = this;
          options = options || {}, pressure = parseFloat(pressure), (isNaN(pressure) || pressure < 0 || 1 < pressure) && (pressure = 0.5);
          var nPressure = Math.round(127 * pressure);
          return wm.toMIDIChannels(channel).forEach(function(ch) {
            that.send((wm.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (ch - 1), [nPressure], that._parseTimeParameter(options.time));
          }), this;
        }, Output2.prototype.sendPitchBend = function(bend, channel, options) {
          var that = this;
          if (options = options || {}, isNaN(bend) || bend < -1 || 1 < bend)
            throw new RangeError("Pitch bend value must be between -1 and 1.");
          var nLevel = Math.round((bend + 1) / 2 * 16383), msb = nLevel >> 7 & 127, lsb = 127 & nLevel;
          return wm.toMIDIChannels(channel).forEach(function(ch) {
            that.send((wm.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (ch - 1), [lsb, msb], that._parseTimeParameter(options.time));
          }), this;
        }, Output2.prototype._parseTimeParameter = function(time2) {
          var value2, parsed = parseFloat(time2);
          return "string" == typeof time2 && "+" === time2.substring(0, 1) ? parsed && 0 < parsed && (value2 = wm.time + parsed) : parsed > wm.time && (value2 = parsed), value2;
        }, Output2.prototype._convertNoteToArray = function(note2) {
          var notes = [];
          return Array.isArray(note2) || (note2 = [note2]), note2.forEach(function(item) {
            notes.push(wm.guessNoteNumber(item));
          }), notes;
        }, module16.exports ? module16.exports = wm : scope.WebMidi || (scope.WebMidi = wm);
      }(commonjsGlobal);
    });
    let TRIGGER_ID = 0;
    class Trigger {
      constructor(type, value2, enabled = true) {
        this.id = TRIGGER_ID++;
        this.type = type;
        this.enabled = enabled;
        this.value = Array.isArray(value2) ? value2 : [value2];
        this.triggersFn = [];
      }
      enable(value2) {
        this.enabled = value2;
        return this;
      }
      trigger(params2) {
        for (let i3 = 0; i3 < this.triggersFn.length; i3++) {
          this.triggersFn[i3](params2);
        }
      }
      onTrigger(fn) {
        this.triggersFn.push(fn);
        return this;
      }
    }
    function map(value2, min, max, nmin, nmax) {
      return (value2 - min) / (max - min) * (nmax - nmin) + nmin;
    }
    const TRIGGER_KNOB = "Midi-Knob";
    const TRIGGER_KEY_DOWN = "Midi-KeyDown";
    const TRIGGER_KEY_UP = "Midi-KeyUp";
    const TRIGGER_NOTE_ON = "Midi-NoteOn";
    const TRIGGER_NOTE_OFF = "Midi-NoteOff";
    const Midi = function() {
      let inputs = [];
      let triggersKeyDown = [];
      let triggersKeyUp = [];
      let triggersNoteOn = [];
      let triggersNoteOff = [];
      let triggersKnob = [];
      let input;
      function loadDevices(fn) {
      }
      function refresh() {
        inputs.length = 0;
        inputs.push(...webmidi_min.inputs);
      }
      function setInput(value2) {
        if (input) {
          console.log("dispose prev input");
        }
        console.log("Midi :: setInput", value2);
        input = value2;
        input.addListener("noteon", "all", onNoteOn);
        input.addListener("noteoff", "all", onNoteOff);
        input.addListener("controlchange", "all", onControlChange);
      }
      function onNoteOn(e) {
        const {number} = e.note;
        for (let i3 = 0; i3 < triggersKeyDown.length; i3++) {
          let trigger2 = triggersKeyDown[i3];
          if (trigger2.value.includes(number) && trigger2.enabled) {
            trigger2.trigger(e);
          }
        }
        for (let i3 = 0; i3 < triggersNoteOn.length; i3++) {
          let trigger2 = triggersNoteOn[i3];
          if ((trigger2.value.includes(e.note.name) || trigger2.value.includes("*")) && trigger2.enabled) {
            trigger2.trigger(e);
          }
        }
      }
      function onNoteOff(e) {
        const {number} = e.note;
        for (let i3 = 0; i3 < triggersKeyUp.length; i3++) {
          let trigger2 = triggersKeyUp[i3];
          if (trigger2.value.includes(number) && trigger2.enabled) {
            trigger2.trigger(e);
          }
        }
      }
      function onControlChange(e) {
        let {number} = e.controller;
        let {value: value2} = e;
        let normalized = map(value2, 0, 127, 0, 1);
        for (let i3 = 0; i3 < triggersKnob.length; i3++) {
          let trigger2 = triggersKnob[i3];
          if (trigger2.value.includes(number) && trigger2.enabled) {
            trigger2.trigger({
              value: normalized
            });
          }
        }
      }
      function knob(knobNumber) {
        let trigger2 = new Trigger(TRIGGER_KNOB, knobNumber);
        let index2 = triggersKnob.length;
        triggersKnob.push(trigger2);
        trigger2.destroy = () => {
          triggersKnob.splice(index2, 1);
        };
        return trigger2;
      }
      function keydown(keyNumber) {
        let trigger2 = new Trigger(TRIGGER_KEY_DOWN, keyNumber);
        addTriggerKeyDown(trigger2);
        return trigger2;
      }
      function addTriggerKeyDown(trigger2) {
        let index2 = triggersKeyDown.length;
        triggersKeyDown.push(trigger2);
        trigger2.destroy = () => {
          triggersKeyDown.splice(index2, 1);
        };
      }
      function keyup(keyNumber) {
        let trigger2 = new Trigger(TRIGGER_KEY_UP, keyNumber);
        addTriggerKeyUp(trigger2);
        return trigger2;
      }
      function addTriggerKeyUp(trigger2) {
        let index2 = triggersKeyUp.length;
        triggersKeyUp.push(trigger2);
        trigger2.destroy = () => {
          triggersKeyUp.splice(index2, 1);
        };
      }
      function noteon(note2) {
        let trigger2 = new Trigger(TRIGGER_NOTE_ON, note2);
        addTriggerNoteOn(trigger2);
        return trigger2;
      }
      function addTriggerNoteOn(trigger2) {
        let index2 = triggersNoteOn.length;
        triggersNoteOn.push(trigger2);
        trigger2.destroy = () => {
          triggersNoteOn.splice(index2, 1);
        };
      }
      function noteoff() {
        let trigger2 = new Trigger(TRIGGER_NOTE_OFF, note);
        addTriggerNoteOff();
        return trigger2;
      }
      function addTriggerNoteOff() {
        let index2 = triggersNoteOff.length;
        triggersNoteOff.push(trigger);
        trigger.destroy = () => {
          triggersNoteOff.splice(index2, 1);
        };
      }
      function addTrigger(trigger2) {
        let triggerTypes = {
          [`${TRIGGER_KEY_DOWN}`]: addTriggerKeyDown,
          [`${TRIGGER_KEY_UP}`]: addTriggerKeyUp,
          [`${TRIGGER_NOTE_ON}`]: addTriggerNoteOn,
          [`${TRIGGER_NOTE_OFF}`]: addTriggerNoteOff
        };
        if (triggerTypes[trigger2.type]) {
          console.log("Midi->addTrigger :: trigger added.", trigger2);
          triggerTypes[trigger2.type](trigger2);
        } else {
          console.warn("Midi->addTrigger :: type not found.", trigger2.type);
        }
      }
      return {
        inputs,
        knob,
        keydown,
        keyup,
        noteon,
        noteoff,
        refresh,
        loadDevices,
        setInput,
        addTrigger,
        TRIGGER_KEY_DOWN,
        TRIGGER_KEY_UP,
        TRIGGER_NOTE_ON,
        TRIGGER_NOTE_OFF,
        TRIGGER_KNOB
      };
    }();
    function Emitter(all = {}) {
      function on2(type, handler) {
        (all[type] || (all[type] = [])).push(handler);
      }
      function off2(type, handler) {
        if (all[type]) {
          all[type].splice(all[type].indexOf(handler) >>> 0, 1);
        }
      }
      function emit2(type, data = {}) {
        (all[type] || []).slice().map((handler) => {
          handler(data);
        });
        (all["*"] || []).slice().map((handler) => {
          handler(type, data);
        });
      }
      function emitAsync2(event2, data = {}) {
        return new Promise((resolve, reject) => {
          emit2(event2, {
            ...data,
            resolve,
            reject
          });
        });
      }
      return {
        on: on2,
        off: off2,
        emit: emit2,
        emitAsync: emitAsync2
      };
    }
    const {on, off, emit, emitAsync} = Emitter();
    const TRIGGER_BEAT = "Audio-beat";
    let BEAT_HOLD_TIME = 300;
    let BEAT_DECAY_RATE = 0.992;
    let BEAT_MIN = 0.1;
    function FrequencyRange(index2, start, end) {
      let volume = 0;
      let beatCutOff = 0;
      let beatTime = 0;
      let triggers = [];
      function update2(freqByteData, deltaTime2) {
        volume = 0;
        for (let i3 = start; i3 < end; i3++) {
          volume += freqByteData[i3];
        }
        volume /= (end - start) * 256;
        if (beatTime >= BEAT_HOLD_TIME && volume > beatCutOff && volume > BEAT_MIN) {
          for (let i3 = 0; i3 < triggers.length; i3++) {
            if (triggers[i3].enabled) {
              triggers[i3].trigger({
                index: index2
              });
            }
          }
          beatCutOff = volume * 1.15;
          beatTime = 0;
        } else {
          if (beatTime <= BEAT_HOLD_TIME) {
            beatTime += deltaTime2 * 1000;
          } else {
            beatCutOff *= BEAT_DECAY_RATE;
            beatCutOff = Math.max(beatCutOff, BEAT_MIN);
          }
        }
      }
      function addTrigger(trigger2) {
        triggers.push(trigger2);
      }
      function removeTrigger(trigger2) {
        for (let i3 = 0; i3 < triggers.length; i3++) {
          if (trigger2.id === triggers[i3].id) {
            triggers.splice(i3, 1);
          }
        }
      }
      return {
        addTrigger,
        removeTrigger,
        triggers,
        update: update2,
        volume: () => volume
      };
    }
    const Audio2 = function() {
      let context = new AudioContext();
      let masterGain = context.createGain();
      let analyser = context.createAnalyser();
      analyser.smoothingTimeConstant = 0.3;
      analyser.fftSize = 512;
      masterGain.connect(analyser);
      let {frequencyBinCount} = analyser;
      let freqByteData = new Uint8Array(frequencyBinCount);
      let ranges = [];
      let rangeCount = 8;
      let audioSource = null;
      let volume = 0;
      let globalVolume = 1;
      let audio = null;
      function init3() {
        createRangesAnalysers();
        {
          masterGain.connect(context.destination);
        }
        on("frame", update2);
      }
      function createRangesAnalysers() {
        let step = Math.floor(frequencyBinCount / rangeCount);
        let globalRange = createRangeAnalyser(0, frequencyBinCount);
        let s2 = 0;
        for (let i3 = 0; i3 < rangeCount; i3++) {
          createRangeAnalyser(s2, s2 + step);
          s2 += step;
        }
      }
      function createRangeAnalyser(start, end) {
        let range = FrequencyRange(ranges.length, start, end);
        ranges.push(range);
        return range;
      }
      function attachStream(stream) {
        masterGain.disconnect(context.destination);
        audioSource = context.createMediaStreamSource(stream);
        audioSource.connect(masterGain);
      }
      function detachStream() {
        disconnectSource();
        masterGain.connect(context.destination);
      }
      function update2({deltaTime: deltaTime2}) {
        analyser.getByteFrequencyData(freqByteData);
        for (let i3 = 0; i3 < ranges.length; i3++) {
          ranges[i3].update(freqByteData, deltaTime2);
        }
        volume = ranges[0].volume() * globalVolume;
      }
      function setGlobalVolume(value2) {
        globalVolume = value2 * 4;
      }
      function setHold(value2) {
        BEAT_HOLD_TIME = value2 * 1000;
      }
      function setDecay(value2) {
        BEAT_DECAY_RATE = 0.95 + value2 * 0.0499;
      }
      function setMin(value2) {
        BEAT_MIN = value2;
      }
      function play(source, {onEnd = () => {
      }} = {}) {
        audio = document.createElement("audio");
        audio.loop = false;
        audio.addEventListener("loadedmetadata", () => {
          console.log("loaded metadata");
        });
        audio.addEventListener("ended", () => {
          onEnd();
        });
        audio.src = source;
        audioSource = context.createMediaElementSource(audio);
        audioSource.connect(masterGain);
        audio.play();
      }
      function pause() {
        audio.pause();
      }
      function getRange(index2 = 0) {
        return ranges[index2];
      }
      function disconnectSource() {
        if (audioSource) {
          audioSource.disconnect(masterGain);
          audioSource = null;
        }
      }
      function beat(range = 0) {
        let rangeIndex = Number(range);
        if (rangeIndex < ranges.length) {
          let trigger2 = new Trigger(TRIGGER_BEAT, rangeIndex);
          addTrigger(trigger2);
          return trigger2;
        }
      }
      function addTrigger(trigger2) {
        for (let i3 = 0; i3 < trigger2.value.length; i3++) {
          let rangeIndex = trigger2.value[i3];
          ranges[rangeIndex].addTrigger(trigger2);
          trigger2.destroy = () => {
            ranges[rangeIndex].removeTrigger(trigger2);
          };
        }
      }
      init3();
      return {
        masterGain,
        attachStream,
        detachStream,
        setDecay,
        setGlobalVolume,
        setHold,
        setMin,
        play,
        pause,
        beat,
        getRange,
        disconnectSource,
        addTrigger,
        volume: () => volume
      };
    }();
    Audio2.TRIGGER_BEAT = TRIGGER_BEAT;
    const TRIGGER_KEY_PRESS = "Keyboard-KeyPress";
    const TRIGGER_KEY_DOWN$1 = "Keyboard-KeyDown";
    const TRIGGER_KEY_UP$1 = "Keyboard-KeyUp";
    const Keyboard = function() {
      let triggersKeyDown = [];
      let triggersKeyPress = [];
      let triggersKeyUp = [];
      window.addEventListener("keypress", onKeyPress);
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      function onKeyPress(event2) {
        checkTriggers(triggersKeyPress, event2);
      }
      function onKeyDown(event2) {
        checkTriggers(triggersKeyDown, event2);
      }
      function onKeyUp(event2) {
        checkTriggers(triggersKeyUp, event2);
      }
      function checkTriggers(collection, event2) {
        for (let i3 = 0; i3 < collection.length; i3++) {
          if (collection[i3].value.includes(event2.key) && collection[i3].enabled) {
            collection[i3].trigger(event2);
          }
        }
      }
      function key(value2) {
        return keypress(value2);
      }
      function keypress(value2) {
        let trigger2 = new Trigger(TRIGGER_KEY_PRESS, value2);
        addTrigger(trigger2, triggersKeyPress);
        return trigger2;
      }
      function keydown() {
        let trigger2 = new Trigger(TRIGGER_KEY_DOWN$1, value);
        addTrigger(trigger2, triggersKeyDown);
        return trigger2;
      }
      function keyup() {
        let trigger2 = new Trigger(TRIGGER_KEY_UP$1, value);
        addTrigger(trigger2, triggersKeyUp);
        return trigger2;
      }
      function addTrigger(trigger2, collection) {
        if (collection === void 0) {
          collection = trigger2.type === TRIGGER_KEY_UP$1 ? triggersKeyUp : trigger2.type === TRIGGER_KEY_DOWN$1 ? triggersKeyDown : triggersKeyPress;
        }
        collection.push(trigger2);
        trigger2.destroy = () => {
          for (let i3 = 0; i3 < collection.length; i3++) {
            if (trigger2.id === collection[i3].id) {
              collection.splice(i3, 1);
            }
          }
        };
      }
      return {
        key,
        keydown,
        keyup,
        keypress,
        addTrigger,
        TRIGGER_KEY_DOWN: TRIGGER_KEY_DOWN$1,
        TRIGGER_KEY_PRESS,
        TRIGGER_KEY_UP: TRIGGER_KEY_UP$1
      };
    }();
    const {console: console_1} = globals;
    const file$8 = "src/ui/TriggerInput.svelte";
    function create_default_slot(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text(ctx[1]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2)
            set_data_dev(t, ctx2[1]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot.name,
        type: "slot",
        source: '(4:4) <Button style=\\"width: 60px; line-height: 10px; margin: 0;\\" onClick={handleClickToggle}>',
        ctx
      });
      return block;
    }
    function create_fragment$8(ctx) {
      let div;
      let t0;
      let t1;
      let current;
      const select = new Select({
        props: {
          options: ctx[3],
          value: ctx[0].type,
          onChange: ctx[6]
        },
        $$inline: true
      });
      const textinput = new TextInput({
        props: {
          width: "40px",
          value: ctx[2],
          onSubmit: ctx[4]
        },
        $$inline: true
      });
      const button = new Button({
        props: {
          style: "width: 60px; line-height: 10px; margin: 0;",
          onClick: ctx[5],
          $$slots: {
            default: [create_default_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(select.$$.fragment);
          t0 = space();
          create_component(textinput.$$.fragment);
          t1 = space();
          create_component(button.$$.fragment);
          attr_dev(div, "class", "trigger svelte-1opnvvo");
          add_location(div, file$8, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(select, div, null);
          append_dev(div, t0);
          mount_component(textinput, div, null);
          append_dev(div, t1);
          mount_component(button, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const select_changes = {};
          if (dirty[0] & 1)
            select_changes.value = ctx2[0].type;
          select.$set(select_changes);
          const textinput_changes = {};
          if (dirty[0] & 4)
            textinput_changes.value = ctx2[2];
          textinput.$set(textinput_changes);
          const button_changes = {};
          if (dirty[0] & 4098) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(select.$$.fragment, local);
          transition_in(textinput.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(select.$$.fragment, local);
          transition_out(textinput.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(select);
          destroy_component(textinput);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$8.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$6($$self, $$props, $$invalidate) {
      let {trigger: trigger2 = {
        type: "keyboard",
        value: ["h", "H"],
        enabled: true
      }} = $$props;
      let {onDelete = () => {
      }} = $$props;
      let all = [Keyboard.TRIGGER_KEY_PRESS, Keyboard.TRIGGER_KEY_UP, Keyboard.TRIGGER_KEY_DOWN, Midi.TRIGGER_KEY_DOWN, Midi.TRIGGER_KEY_UP, Midi.TRIGGER_NOTE_ON, Midi.TRIGGER_NOTE_OFF, Midi.TRIGGER_KNOB, Audio2.TRIGGER_BEAT];
      let options = all.map((opt) => ({
        label: opt,
        key: opt
      }));
      let type = trigger2.type;
      function handleSubmit(newValue) {
        let values = newValue.split(",");
        values = values.map((v) => {
          if (Number(v) == v) {
            return Number(v);
          }
          return v;
        });
        $$invalidate(0, trigger2.value = values, trigger2);
        onTriggerTypeChange();
      }
      function handleClickToggle() {
        $$invalidate(0, trigger2.enabled = !trigger2.enabled, trigger2);
      }
      function handleChangeType({key}) {
        console.log("Trigger :: handleChangeType");
        $$invalidate(0, trigger2.type = key, trigger2);
        onTriggerTypeChange();
      }
      function onTriggerTypeChange() {
        trigger2.destroy();
        type = trigger2.type;
        if ([Keyboard.TRIGGER_KEY_UP, Keyboard.TRIGGER_KEY_DOWN, Keyboard.TRIGGER_KEY_PRESS].includes(trigger2.type)) {
          Keyboard.addTrigger(trigger2);
        } else if ([Audio2.TRIGGER_BEAT].includes(trigger2.type)) {
          Audio2.addTrigger(trigger2);
        } else {
          Midi.addTrigger(trigger2);
        }
      }
      const writable_props = ["trigger", "onDelete"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console_1.warn(`<TriggerInput> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("trigger" in $$props2)
          $$invalidate(0, trigger2 = $$props2.trigger);
        if ("onDelete" in $$props2)
          $$invalidate(7, onDelete = $$props2.onDelete);
      };
      $$self.$capture_state = () => {
        return {
          trigger: trigger2,
          onDelete,
          all,
          options,
          type,
          label,
          inputValue
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("trigger" in $$props2)
          $$invalidate(0, trigger2 = $$props2.trigger);
        if ("onDelete" in $$props2)
          $$invalidate(7, onDelete = $$props2.onDelete);
        if ("all" in $$props2)
          all = $$props2.all;
        if ("options" in $$props2)
          $$invalidate(3, options = $$props2.options);
        if ("type" in $$props2)
          type = $$props2.type;
        if ("label" in $$props2)
          $$invalidate(1, label = $$props2.label);
        if ("inputValue" in $$props2)
          $$invalidate(2, inputValue = $$props2.inputValue);
      };
      let label;
      let inputValue;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 1) {
          $$invalidate(1, label = trigger2.enabled ? "Disable" : "Enable");
        }
        if ($$self.$$.dirty[0] & 1) {
          $$invalidate(2, inputValue = Array.isArray(trigger2) ? trigger2.value.join(",") : trigger2.value);
        }
      };
      return [trigger2, label, inputValue, options, handleSubmit, handleClickToggle, handleChangeType, onDelete];
    }
    class TriggerInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$6, create_fragment$8, safe_not_equal, {
          trigger: 0,
          onDelete: 7
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TriggerInput",
          options,
          id: create_fragment$8.name
        });
      }
      get trigger() {
        throw new Error("<TriggerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set trigger(value2) {
        throw new Error("<TriggerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onDelete() {
        throw new Error("<TriggerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onDelete(value2) {
        throw new Error("<TriggerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$9 = "src/ui/ColorInput.svelte";
    function create_fragment$9(ctx) {
      let div;
      let input;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          input = element("input");
          attr_dev(input, "type", "color");
          attr_dev(input, "class", "input svelte-12a0dlg");
          input.value = ctx[0];
          add_location(input, file$9, 1, 4, 62);
          attr_dev(div, "class", "container svelte-12a0dlg");
          set_style(div, "background-color", ctx[0]);
          add_location(div, file$9, 0, 0, 0);
          dispose = listen_dev(input, "change", ctx[1], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1) {
            prop_dev(input, "value", ctx2[0]);
          }
          if (dirty[0] & 1) {
            set_style(div, "background-color", ctx2[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$7($$self, $$props, $$invalidate) {
      let {value: value2} = $$props;
      let {onChange = noop$1} = $$props;
      function handleChange(event2) {
        onChange(event2.currentTarget.value);
      }
      const writable_props = ["value", "onChange"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<ColorInput> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(2, onChange = $$props2.onChange);
      };
      $$self.$capture_state = () => {
        return {
          value: value2,
          onChange
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(2, onChange = $$props2.onChange);
      };
      return [value2, handleChange, onChange];
    }
    class ColorInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$7, create_fragment$9, safe_not_equal, {
          value: 0,
          onChange: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ColorInput",
          options,
          id: create_fragment$9.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("value" in props)) {
          console.warn("<ColorInput> was created without expected prop 'value'");
        }
      }
      get value() {
        throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value2) {
        throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$a = "src/ui/ProgressInput.svelte";
    function create_fragment$a(ctx) {
      let div1;
      let div0;
      let dispose;
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          attr_dev(div0, "class", "fill svelte-1afkcej");
          set_style(div0, "transform", "scaleX(" + map(ctx[0], ctx[1], ctx[2], 0, 1) + ")");
          add_location(div0, file$a, 1, 4, 78);
          attr_dev(div1, "class", "progress svelte-1afkcej");
          add_location(div1, file$a, 0, 0, 0);
          dispose = listen_dev(div1, "mousedown", ctx[4], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          ctx[10](div1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 7) {
            set_style(div0, "transform", "scaleX(" + map(ctx2[0], ctx2[1], ctx2[2], 0, 1) + ")");
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          ctx[10](null);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$8($$self, $$props, $$invalidate) {
      let {value: value2} = $$props;
      let {min} = $$props;
      let {max} = $$props;
      let {step} = $$props;
      let {onChange = noop$1} = $$props;
      let element2;
      function handleMouseDown(event2) {
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        onDrag(event2);
      }
      function handleMouseMove(event2) {
        onDrag(event2);
      }
      function onDrag(event2) {
        let rect = element2.getBoundingClientRect();
        let v = clamp(map(event2.clientX, rect.left, rect.right, min, max), min, max);
        v = Math.floor(v * (1 / step)) / (1 / step);
        onChange(v);
      }
      function handleMouseUp() {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      }
      const writable_props = ["value", "min", "max", "step", "onChange"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<ProgressInput> was created with unknown prop '${key}'`);
      });
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(3, element2 = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("min" in $$props2)
          $$invalidate(1, min = $$props2.min);
        if ("max" in $$props2)
          $$invalidate(2, max = $$props2.max);
        if ("step" in $$props2)
          $$invalidate(5, step = $$props2.step);
        if ("onChange" in $$props2)
          $$invalidate(6, onChange = $$props2.onChange);
      };
      $$self.$capture_state = () => {
        return {
          value: value2,
          min,
          max,
          step,
          onChange,
          element: element2
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("min" in $$props2)
          $$invalidate(1, min = $$props2.min);
        if ("max" in $$props2)
          $$invalidate(2, max = $$props2.max);
        if ("step" in $$props2)
          $$invalidate(5, step = $$props2.step);
        if ("onChange" in $$props2)
          $$invalidate(6, onChange = $$props2.onChange);
        if ("element" in $$props2)
          $$invalidate(3, element2 = $$props2.element);
      };
      return [value2, min, max, element2, handleMouseDown, step, onChange, handleMouseMove, onDrag, handleMouseUp, div1_binding];
    }
    class ProgressInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$8, create_fragment$a, safe_not_equal, {
          value: 0,
          min: 1,
          max: 2,
          step: 5,
          onChange: 6
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ProgressInput",
          options,
          id: create_fragment$a.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("value" in props)) {
          console.warn("<ProgressInput> was created without expected prop 'value'");
        }
        if (ctx[1] === void 0 && !("min" in props)) {
          console.warn("<ProgressInput> was created without expected prop 'min'");
        }
        if (ctx[2] === void 0 && !("max" in props)) {
          console.warn("<ProgressInput> was created without expected prop 'max'");
        }
        if (ctx[5] === void 0 && !("step" in props)) {
          console.warn("<ProgressInput> was created without expected prop 'step'");
        }
      }
      get value() {
        throw new Error("<ProgressInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value2) {
        throw new Error("<ProgressInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get min() {
        throw new Error("<ProgressInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set min(value2) {
        throw new Error("<ProgressInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get max() {
        throw new Error("<ProgressInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set max(value2) {
        throw new Error("<ProgressInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get step() {
        throw new Error("<ProgressInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set step(value2) {
        throw new Error("<ProgressInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<ProgressInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<ProgressInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    async function loadImage(src, onLoad = noop$1) {
      let response = await fetch(src);
      let blob2 = await response.blob();
      let dataURL = URL.createObjectURL(blob2);
      let image = new Image();
      image.addEventListener("load", () => {
        onLoad(image);
      });
      image.src = dataURL;
    }
    const file$b = "src/ui/ImageInput.svelte";
    function create_fragment$b(ctx) {
      let div;
      let input_1;
      let div_style_value;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          input_1 = element("input");
          attr_dev(input_1, "type", "file");
          attr_dev(input_1, "class", "input svelte-1nf8qv1");
          add_location(input_1, file$b, 1, 4, 124);
          attr_dev(div, "class", "container svelte-1nf8qv1");
          attr_dev(div, "style", div_style_value = ctx[0] && ctx[0].src ? `background-image: url(${ctx[0].src})` : "");
          add_location(div, file$b, 0, 0, 0);
          dispose = [listen_dev(input_1, "change", ctx[3], false, false, false), listen_dev(div, "click", ctx[2], false, false, false)];
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input_1);
          ctx[5](input_1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1 && div_style_value !== (div_style_value = ctx2[0] && ctx2[0].src ? `background-image: url(${ctx2[0].src})` : "")) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          ctx[5](null);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$9($$self, $$props, $$invalidate) {
      let {value: value2} = $$props;
      let {onChange = noop$1} = $$props;
      let input;
      if (value2 && !value2.src && typeof value2 === "string") {
        loadImage(value2, (image) => {
          onChange({
            image,
            name: value2
          });
        });
      }
      function handleClick() {
        input.click();
      }
      function handleUpload(event2) {
        let file2 = event2.target.files[0];
        let name = file2.name;
        let reader = new FileReader();
        reader.onload = (e) => {
          loadImage(e.target.result, (image) => {
            onChange({
              image,
              name
            });
          });
        };
        reader.readAsDataURL(file2);
      }
      const writable_props = ["value", "onChange"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<ImageInput> was created with unknown prop '${key}'`);
      });
      function input_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(1, input = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(4, onChange = $$props2.onChange);
      };
      $$self.$capture_state = () => {
        return {
          value: value2,
          onChange,
          input
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("onChange" in $$props2)
          $$invalidate(4, onChange = $$props2.onChange);
        if ("input" in $$props2)
          $$invalidate(1, input = $$props2.input);
      };
      return [value2, input, handleClick, handleUpload, onChange, input_1_binding];
    }
    class ImageInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$9, create_fragment$b, safe_not_equal, {
          value: 0,
          onChange: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ImageInput",
          options,
          id: create_fragment$b.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("value" in props)) {
          console.warn("<ImageInput> was created without expected prop 'value'");
        }
      }
      get value() {
        throw new Error("<ImageInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value2) {
        throw new Error("<ImageInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<ImageInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<ImageInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$c = "src/ui/Checkbox.svelte";
    function create_fragment$c(ctx) {
      let div1;
      let input;
      let t;
      let div0;
      let dispose;
      const block = {
        c: function create() {
          div1 = element("div");
          input = element("input");
          t = space();
          div0 = element("div");
          attr_dev(input, "class", "input svelte-ooy3fa");
          attr_dev(input, "type", "checkbox");
          input.disabled = ctx[1];
          add_location(input, file$c, 1, 4, 27);
          attr_dev(div0, "class", "checked svelte-ooy3fa");
          add_location(div0, file$c, 2, 4, 142);
          attr_dev(div1, "class", "checkbox svelte-ooy3fa");
          add_location(div1, file$c, 0, 0, 0);
          dispose = [listen_dev(input, "change", ctx[4]), listen_dev(input, "change", ctx[2], false, false, false)];
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, input);
          input.checked = ctx[0].value;
          append_dev(div1, t);
          append_dev(div1, div0);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2) {
            prop_dev(input, "disabled", ctx2[1]);
          }
          if (dirty[0] & 1) {
            input.checked = ctx2[0].value;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$a($$self, $$props, $$invalidate) {
      let {prop = {}} = $$props;
      let {disabled = false} = $$props;
      let {onChange = () => {
      }} = $$props;
      function handleChange(event2) {
        onChange(event2.target.checked);
      }
      const writable_props = ["prop", "disabled", "onChange"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Checkbox> was created with unknown prop '${key}'`);
      });
      function input_change_handler() {
        prop.value = this.checked;
        $$invalidate(0, prop);
      }
      $$self.$set = ($$props2) => {
        if ("prop" in $$props2)
          $$invalidate(0, prop = $$props2.prop);
        if ("disabled" in $$props2)
          $$invalidate(1, disabled = $$props2.disabled);
        if ("onChange" in $$props2)
          $$invalidate(3, onChange = $$props2.onChange);
      };
      $$self.$capture_state = () => {
        return {
          prop,
          disabled,
          onChange
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("prop" in $$props2)
          $$invalidate(0, prop = $$props2.prop);
        if ("disabled" in $$props2)
          $$invalidate(1, disabled = $$props2.disabled);
        if ("onChange" in $$props2)
          $$invalidate(3, onChange = $$props2.onChange);
      };
      return [prop, disabled, handleChange, onChange, input_change_handler];
    }
    class Checkbox extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$a, create_fragment$c, safe_not_equal, {
          prop: 0,
          disabled: 1,
          onChange: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Checkbox",
          options,
          id: create_fragment$c.name
        });
      }
      get prop() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set prop(value2) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value2) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get onChange() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set onChange(value2) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    let noop$2 = () => {
    };
    const Webcam = function() {
      let video = document.createElement("video");
      let canvas = document.createElement("canvas");
      let stream, context;
      async function request({video: video2 = true, audio = true, onSuccess = noop$2, onError = noop$2} = {}) {
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: video2,
            audio
          });
          handleSuccess(stream);
          onSuccess(stream);
        } catch (error) {
          handleError(error);
          onError(error);
        }
      }
      function stop() {
        if (stream) {
          let tracks = stream.getTracks();
          for (let i3 = 0; i3 < tracks.length; i3++) {
            let track = tracks[i3];
            track.stop();
          }
        }
      }
      function handleSuccess(stream2) {
        video.addEventListener("canplay", () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          context = canvas.getContext("2d");
          draw();
        });
        video.srcObject = stream2;
        video.play();
      }
      function draw() {
        requestAnimationFrame(draw);
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
      }
      function handleError(error) {
        console.error("Webcam: error while trying to request access.");
        console.error(error);
      }
      return {
        video,
        canvas,
        request,
        stop
      };
    }();
    const file$d = "src/ui/svg/IconSettings.svelte";
    function create_fragment$d(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z");
          add_location(path, file$d, 0, 98, 98);
          attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg, "width", "24");
          attr_dev(svg, "height", "24");
          attr_dev(svg, "viewBox", "0 0 24 24");
          attr_dev(svg, "fill", "#f0f0f0");
          add_location(svg, file$d, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    class IconSettings extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, null, create_fragment$d, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconSettings",
          options,
          id: create_fragment$d.name
        });
      }
    }
    const file$e = "src/ui/svg/IconTrigger.svelte";
    function create_fragment$e(ctx) {
      let svg;
      let path;
      let svg_style_value;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M6 16h-6v-3h6v3zm-2-5v-10h-2v10h2zm-2 7v5h2v-5h-2zm13-7h-6v-3h6v3zm-2-5v-5h-2v5h2zm-2 7v10h2v-10h-2zm13 3h-6v-3h6v3zm-2-5v-10h-2v10h2zm-2 7v5h2v-5h-2z");
          add_location(path, file$e, 0, 125, 125);
          attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg, "width", "24");
          attr_dev(svg, "height", "24");
          attr_dev(svg, "viewBox", "0 0 24 24");
          attr_dev(svg, "fill", ctx[0]);
          attr_dev(svg, "style", svg_style_value = `opacity: ${ctx[1]}`);
          add_location(svg, file$e, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1) {
            attr_dev(svg, "fill", ctx2[0]);
          }
          if (dirty[0] & 2 && svg_style_value !== (svg_style_value = `opacity: ${ctx2[1]}`)) {
            attr_dev(svg, "style", svg_style_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$b($$self, $$props, $$invalidate) {
      let {fill = "#f0f0f0"} = $$props;
      let {opacity = 1} = $$props;
      const writable_props = ["fill", "opacity"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<IconTrigger> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("fill" in $$props2)
          $$invalidate(0, fill = $$props2.fill);
        if ("opacity" in $$props2)
          $$invalidate(1, opacity = $$props2.opacity);
      };
      $$self.$capture_state = () => {
        return {
          fill,
          opacity
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("fill" in $$props2)
          $$invalidate(0, fill = $$props2.fill);
        if ("opacity" in $$props2)
          $$invalidate(1, opacity = $$props2.opacity);
      };
      return [fill, opacity];
    }
    class IconTrigger extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$b, create_fragment$e, safe_not_equal, {
          fill: 0,
          opacity: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconTrigger",
          options,
          id: create_fragment$e.name
        });
      }
      get fill() {
        throw new Error("<IconTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set fill(value2) {
        throw new Error("<IconTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get opacity() {
        throw new Error("<IconTrigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set opacity(value2) {
        throw new Error("<IconTrigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    function getFilename(filepath) {
      let parts2 = filepath.split("/");
      return parts2[parts2.length - 1];
    }
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
    var parseuri = function parseuri2(str) {
      var src = str, b = str.indexOf("["), e = str.indexOf("]");
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
      }
      var m2 = re.exec(str || ""), uri = {}, i3 = 14;
      while (i3--) {
        uri[parts[i3]] = m2[i3] || "";
      }
      if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      return uri;
    };
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable2;
      createDebug.enabled = enabled;
      createDebug.humanize = ms;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return match;
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.enabled = createDebug.enabled(namespace);
        debug2.useColors = createDebug.useColors();
        debug2.color = selectColor(namespace);
        debug2.destroy = destroy;
        debug2.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        createDebug.instances.push(debug2);
        return debug2;
      }
      function destroy() {
        const index2 = createDebug.instances.indexOf(this);
        if (index2 !== -1) {
          createDebug.instances.splice(index2, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable2(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i3;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i3 = 0; i3 < len; i3++) {
          if (!split[i3]) {
            continue;
          }
          namespaces = split[i3].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i3 = 0; i3 < createDebug.instances.length; i3++) {
          const instance2 = createDebug.instances[i3];
          instance2.enabled = createDebug.enabled(instance2.namespace);
        }
      }
      function disable2() {
        const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i3;
        let len;
        for (i3 = 0, len = createDebug.skips.length; i3 < len; i3++) {
          if (createDebug.skips[i3].test(name)) {
            return false;
          }
        }
        for (i3 = 0, len = createDebug.names.length; i3 < len; i3++) {
          if (createDebug.names[i3].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common2 = setup;
    var browser = createCommonjsModule(function(module16, exports2) {
      exports2.log = log;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module16.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index2++;
          if (match === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log(...args) {
        return typeof console === "object" && console.log && console.log(...args);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module16.exports = common2(exports2);
      const {formatters} = module16.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    });
    var browser_1 = browser.log;
    var browser_2 = browser.formatArgs;
    var browser_3 = browser.save;
    var browser_4 = browser.load;
    var browser_5 = browser.useColors;
    var browser_6 = browser.storage;
    var browser_7 = browser.colors;
    var debug = browser("socket.io-client:url");
    var url_1 = url;
    function url(uri, loc) {
      var obj = uri;
      loc = loc || typeof location !== "undefined" && location;
      if (null == uri)
        uri = loc.protocol + "//" + loc.host;
      if ("string" === typeof uri) {
        if ("/" === uri.charAt(0)) {
          if ("/" === uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug("protocol-less url %s", uri);
          if ("undefined" !== typeof loc) {
            uri = loc.protocol + "//" + uri;
          } else {
            uri = "https://" + uri;
          }
        }
        debug("parse %s", uri);
        obj = parseuri(uri);
      }
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = "443";
        }
      }
      obj.path = obj.path || "/";
      var ipv6 = obj.host.indexOf(":") !== -1;
      var host = ipv6 ? "[" + obj.host + "]" : obj.host;
      obj.id = obj.protocol + "://" + host + ":" + obj.port;
      obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
    }
    var s$1 = 1000;
    var m$1 = s$1 * 60;
    var h$1 = m$1 * 60;
    var d$1 = h$1 * 24;
    var y$1 = d$1 * 365.25;
    var ms$1 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$1(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong$1(val) : fmtShort$1(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$1(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y$1;
        case "days":
        case "day":
        case "d":
          return n * d$1;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h$1;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s$1;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort$1(ms2) {
      if (ms2 >= d$1) {
        return Math.round(ms2 / d$1) + "d";
      }
      if (ms2 >= h$1) {
        return Math.round(ms2 / h$1) + "h";
      }
      if (ms2 >= m$1) {
        return Math.round(ms2 / m$1) + "m";
      }
      if (ms2 >= s$1) {
        return Math.round(ms2 / s$1) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong$1(ms2) {
      return plural$1(ms2, d$1, "day") || plural$1(ms2, h$1, "hour") || plural$1(ms2, m$1, "minute") || plural$1(ms2, s$1, "second") || ms2 + " ms";
    }
    function plural$1(ms2, n, name) {
      if (ms2 < n) {
        return;
      }
      if (ms2 < n * 1.5) {
        return Math.floor(ms2 / n) + " " + name;
      }
      return Math.ceil(ms2 / n) + " " + name + "s";
    }
    var debug$1 = createCommonjsModule(function(module16, exports2) {
      exports2 = module16.exports = createDebug.debug = createDebug["default"] = createDebug;
      exports2.coerce = coerce;
      exports2.disable = disable2;
      exports2.enable = enable2;
      exports2.enabled = enabled;
      exports2.humanize = ms$1;
      exports2.instances = [];
      exports2.names = [];
      exports2.skips = [];
      exports2.formatters = {};
      function selectColor(namespace) {
        var hash = 0, i3;
        for (i3 in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return exports2.colors[Math.abs(hash) % exports2.colors.length];
      }
      function createDebug(namespace) {
        var prevTime;
        function debug2() {
          if (!debug2.enabled)
            return;
          var self2 = debug2;
          var curr = +new Date();
          var ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          var args = new Array(arguments.length);
          for (var i3 = 0; i3 < args.length; i3++) {
            args[i3] = arguments[i3];
          }
          args[0] = exports2.coerce(args[0]);
          if ("string" !== typeof args[0]) {
            args.unshift("%O");
          }
          var index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%")
              return match;
            index2++;
            var formatter = exports2.formatters[format];
            if ("function" === typeof formatter) {
              var val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          exports2.formatArgs.call(self2, args);
          var logFn = debug2.log || exports2.log || console.log.bind(console);
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.enabled = exports2.enabled(namespace);
        debug2.useColors = exports2.useColors();
        debug2.color = selectColor(namespace);
        debug2.destroy = destroy;
        if ("function" === typeof exports2.init) {
          exports2.init(debug2);
        }
        exports2.instances.push(debug2);
        return debug2;
      }
      function destroy() {
        var index2 = exports2.instances.indexOf(this);
        if (index2 !== -1) {
          exports2.instances.splice(index2, 1);
          return true;
        } else {
          return false;
        }
      }
      function enable2(namespaces) {
        exports2.save(namespaces);
        exports2.names = [];
        exports2.skips = [];
        var i3;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i3 = 0; i3 < len; i3++) {
          if (!split[i3])
            continue;
          namespaces = split[i3].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i3 = 0; i3 < exports2.instances.length; i3++) {
          var instance2 = exports2.instances[i3];
          instance2.enabled = exports2.enabled(instance2.namespace);
        }
      }
      function disable2() {
        exports2.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i3, len;
        for (i3 = 0, len = exports2.skips.length; i3 < len; i3++) {
          if (exports2.skips[i3].test(name)) {
            return false;
          }
        }
        for (i3 = 0, len = exports2.names.length; i3 < len; i3++) {
          if (exports2.names[i3].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
    });
    var debug_1 = debug$1.coerce;
    var debug_2 = debug$1.disable;
    var debug_3 = debug$1.enable;
    var debug_4 = debug$1.enabled;
    var debug_5 = debug$1.humanize;
    var debug_6 = debug$1.instances;
    var debug_7 = debug$1.names;
    var debug_8 = debug$1.skips;
    var debug_9 = debug$1.formatters;
    var browser$1 = createCommonjsModule(function(module16, exports2) {
      exports2 = module16.exports = debug$1;
      exports2.log = log;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      exports2.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };
      function formatArgs(args) {
        var useColors2 = this.useColors;
        args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
        if (!useColors2)
          return;
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index2 = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
          if ("%%" === match)
            return;
          index2++;
          if ("%c" === match) {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log() {
        return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports2.storage.removeItem("debug");
          } else {
            exports2.storage.debug = namespaces;
          }
        } catch (e) {
        }
      }
      function load() {
        var r;
        try {
          r = exports2.storage.debug;
        } catch (e) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      exports2.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {
        }
      }
    });
    var browser_1$1 = browser$1.log;
    var browser_2$1 = browser$1.formatArgs;
    var browser_3$1 = browser$1.save;
    var browser_4$1 = browser$1.load;
    var browser_5$1 = browser$1.useColors;
    var browser_6$1 = browser$1.storage;
    var browser_7$1 = browser$1.colors;
    var componentEmitter = createCommonjsModule(function(module16) {
      {
        module16.exports = Emitter2;
      }
      function Emitter2(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key in Emitter2.prototype) {
          obj[key] = Emitter2.prototype[key];
        }
        return obj;
      }
      Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event2, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + event2] = this._callbacks["$" + event2] || []).push(fn);
        return this;
      };
      Emitter2.prototype.once = function(event2, fn) {
        function on2() {
          this.off(event2, on2);
          fn.apply(this, arguments);
        }
        on2.fn = fn;
        this.on(event2, on2);
        return this;
      };
      Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event2, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks2 = this._callbacks["$" + event2];
        if (!callbacks2)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks["$" + event2];
          return this;
        }
        var cb;
        for (var i3 = 0; i3 < callbacks2.length; i3++) {
          cb = callbacks2[i3];
          if (cb === fn || cb.fn === fn) {
            callbacks2.splice(i3, 1);
            break;
          }
        }
        return this;
      };
      Emitter2.prototype.emit = function(event2) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks2 = this._callbacks["$" + event2];
        if (callbacks2) {
          callbacks2 = callbacks2.slice(0);
          for (var i3 = 0, len = callbacks2.length; i3 < len; ++i3) {
            callbacks2[i3].apply(this, args);
          }
        }
        return this;
      };
      Emitter2.prototype.listeners = function(event2) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + event2] || [];
      };
      Emitter2.prototype.hasListeners = function(event2) {
        return !!this.listeners(event2).length;
      };
    });
    var toString$1 = {}.toString;
    var isarray = Array.isArray || function(arr) {
      return toString$1.call(arr) == "[object Array]";
    };
    var isBuffer$1 = isBuf;
    var withNativeBuffer = typeof Buffer === "function" && typeof Buffer.isBuffer === "function";
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = function(obj) {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    function isBuf(obj) {
      return withNativeBuffer && Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
    }
    var toString$2 = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$2.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$2.call(File) === "[object FileConstructor]";
    var deconstructPacket = function(packet) {
      var buffers = [];
      var packetData = packet.data;
      var pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length;
      return {
        packet: pack,
        buffers
      };
    };
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (isBuffer$1(data)) {
        var placeholder = {
          _placeholder: true,
          num: buffers.length
        };
        buffers.push(data);
        return placeholder;
      } else if (isarray(data)) {
        var newData = new Array(data.length);
        for (var i3 = 0; i3 < data.length; i3++) {
          newData[i3] = _deconstructPacket(data[i3], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        var newData = {};
        for (var key in data) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
        return newData;
      }
      return data;
    }
    var reconstructPacket = function(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = void 0;
      return packet;
    };
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder) {
        return buffers[data.num];
      } else if (isarray(data)) {
        for (var i3 = 0; i3 < data.length; i3++) {
          data[i3] = _reconstructPacket(data[i3], buffers);
        }
      } else if (typeof data === "object") {
        for (var key in data) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
      return data;
    }
    var removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj)
          return obj;
        if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
          pendingBlobs++;
          var fileReader = new FileReader();
          fileReader.onload = function() {
            if (containingObject) {
              containingObject[curKey] = this.result;
            } else {
              bloblessData = this.result;
            }
            if (!--pendingBlobs) {
              callback(bloblessData);
            }
          };
          fileReader.readAsArrayBuffer(obj);
        } else if (isarray(obj)) {
          for (var i3 = 0; i3 < obj.length; i3++) {
            _removeBlobs(obj[i3], i3, obj);
          }
        } else if (typeof obj === "object" && !isBuffer$1(obj)) {
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }
      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };
    var binary = {
      deconstructPacket,
      reconstructPacket,
      removeBlobs
    };
    var socket_ioParser = createCommonjsModule(function(module16, exports2) {
      var debug2 = browser$1("socket.io-parser");
      exports2.protocol = 4;
      exports2.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"];
      exports2.CONNECT = 0;
      exports2.DISCONNECT = 1;
      exports2.EVENT = 2;
      exports2.ACK = 3;
      exports2.ERROR = 4;
      exports2.BINARY_EVENT = 5;
      exports2.BINARY_ACK = 6;
      exports2.Encoder = Encoder;
      exports2.Decoder = Decoder;
      function Encoder() {
      }
      var ERROR_PACKET = exports2.ERROR + '"encode error"';
      Encoder.prototype.encode = function(obj, callback) {
        debug2("encoding packet %j", obj);
        if (exports2.BINARY_EVENT === obj.type || exports2.BINARY_ACK === obj.type) {
          encodeAsBinary(obj, callback);
        } else {
          var encoding = encodeAsString(obj);
          callback([encoding]);
        }
      };
      function encodeAsString(obj) {
        var str = "" + obj.type;
        if (exports2.BINARY_EVENT === obj.type || exports2.BINARY_ACK === obj.type) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        }
        if (null != obj.id) {
          str += obj.id;
        }
        if (null != obj.data) {
          var payload = tryStringify(obj.data);
          if (payload !== false) {
            str += payload;
          } else {
            return ERROR_PACKET;
          }
        }
        debug2("encoded %j as %s", obj, str);
        return str;
      }
      function tryStringify(str) {
        try {
          return JSON.stringify(str);
        } catch (e) {
          return false;
        }
      }
      function encodeAsBinary(obj, callback) {
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);
          var pack = encodeAsString(deconstruction.packet);
          var buffers = deconstruction.buffers;
          buffers.unshift(pack);
          callback(buffers);
        }
        binary.removeBlobs(obj, writeEncoding);
      }
      function Decoder() {
        this.reconstructor = null;
      }
      componentEmitter(Decoder.prototype);
      Decoder.prototype.add = function(obj) {
        var packet;
        if (typeof obj === "string") {
          packet = decodeString(obj);
          if (exports2.BINARY_EVENT === packet.type || exports2.BINARY_ACK === packet.type) {
            this.reconstructor = new BinaryReconstructor(packet);
            if (this.reconstructor.reconPack.attachments === 0) {
              this.emit("decoded", packet);
            }
          } else {
            this.emit("decoded", packet);
          }
        } else if (isBuffer$1(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              this.emit("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      };
      function decodeString(str) {
        var i3 = 0;
        var p = {
          type: Number(str.charAt(0))
        };
        if (null == exports2.types[p.type]) {
          return error("unknown packet type " + p.type);
        }
        if (exports2.BINARY_EVENT === p.type || exports2.BINARY_ACK === p.type) {
          var buf = "";
          while (str.charAt(++i3) !== "-") {
            buf += str.charAt(i3);
            if (i3 == str.length)
              break;
          }
          if (buf != Number(buf) || str.charAt(i3) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if ("/" === str.charAt(i3 + 1)) {
          p.nsp = "";
          while (++i3) {
            var c = str.charAt(i3);
            if ("," === c)
              break;
            p.nsp += c;
            if (i3 === str.length)
              break;
          }
        } else {
          p.nsp = "/";
        }
        var next = str.charAt(i3 + 1);
        if ("" !== next && Number(next) == next) {
          p.id = "";
          while (++i3) {
            var c = str.charAt(i3);
            if (null == c || Number(c) != c) {
              --i3;
              break;
            }
            p.id += str.charAt(i3);
            if (i3 === str.length)
              break;
          }
          p.id = Number(p.id);
        }
        if (str.charAt(++i3)) {
          var payload = tryParse(str.substr(i3));
          var isPayloadValid = payload !== false && (p.type === exports2.ERROR || isarray(payload));
          if (isPayloadValid) {
            p.data = payload;
          } else {
            return error("invalid payload");
          }
        }
        debug2("decoded %s as %j", str, p);
        return p;
      }
      function tryParse(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return false;
        }
      }
      Decoder.prototype.destroy = function() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      };
      function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
      }
      BinaryReconstructor.prototype.takeBinaryData = function(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      };
      BinaryReconstructor.prototype.finishedReconstruction = function() {
        this.reconPack = null;
        this.buffers = [];
      };
      function error(msg) {
        return {
          type: exports2.ERROR,
          data: "parser error: " + msg
        };
      }
    });
    var socket_ioParser_1 = socket_ioParser.protocol;
    var socket_ioParser_2 = socket_ioParser.types;
    var socket_ioParser_3 = socket_ioParser.CONNECT;
    var socket_ioParser_4 = socket_ioParser.DISCONNECT;
    var socket_ioParser_5 = socket_ioParser.EVENT;
    var socket_ioParser_6 = socket_ioParser.ACK;
    var socket_ioParser_7 = socket_ioParser.ERROR;
    var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
    var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
    var socket_ioParser_10 = socket_ioParser.Encoder;
    var socket_ioParser_11 = socket_ioParser.Decoder;
    var hasCors = createCommonjsModule(function(module16) {
      try {
        module16.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
      } catch (err) {
        module16.exports = false;
      }
    });
    var xmlhttprequest = function(opts) {
      var xdomain = opts.xdomain;
      var xscheme = opts.xscheme;
      var enablesXDR = opts.enablesXDR;
      try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
          return new XMLHttpRequest();
        }
      } catch (e) {
      }
      try {
        if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
          return new XDomainRequest();
        }
      } catch (e) {
      }
      if (!xdomain) {
        try {
          return new self[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {
        }
      }
    };
    var keys = Object.keys || function keys2(obj) {
      var arr = [];
      var has2 = Object.prototype.hasOwnProperty;
      for (var i3 in obj) {
        if (has2.call(obj, i3)) {
          arr.push(i3);
        }
      }
      return arr;
    };
    var toString$3 = {}.toString;
    var isarray$1 = Array.isArray || function(arr) {
      return toString$3.call(arr) == "[object Array]";
    };
    var toString$4 = Object.prototype.toString;
    var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && toString$4.call(Blob) === "[object BlobConstructor]";
    var withNativeFile$1 = typeof File === "function" || typeof File !== "undefined" && toString$4.call(File) === "[object FileConstructor]";
    var hasBinary2 = hasBinary;
    function hasBinary(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (isarray$1(obj)) {
        for (var i3 = 0, l = obj.length; i3 < l; i3++) {
          if (hasBinary(obj[i3])) {
            return true;
          }
        }
        return false;
      }
      if (typeof Buffer === "function" && Buffer.isBuffer && Buffer.isBuffer(obj) || typeof ArrayBuffer === "function" && obj instanceof ArrayBuffer || withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    var arraybuffer_slice = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
      if (arraybuffer.slice) {
        return arraybuffer.slice(start, end);
      }
      if (start < 0) {
        start += bytes;
      }
      if (end < 0) {
        end += bytes;
      }
      if (end > bytes) {
        end = bytes;
      }
      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i3 = start, ii = 0; i3 < end; i3++, ii++) {
        result[ii] = abv[i3];
      }
      return result.buffer;
    };
    var after_1 = after;
    function after(count, callback, err_cb) {
      var bail = false;
      err_cb = err_cb || noop$3;
      proxy.count = count;
      return count === 0 ? callback() : proxy;
      function proxy(err, result) {
        if (proxy.count <= 0) {
          throw new Error("after called too many times");
        }
        --proxy.count;
        if (err) {
          bail = true;
          callback(err);
          callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
          callback(null, result);
        }
      }
    }
    function noop$3() {
    }
    var stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length2 = string.length;
      var value2;
      var extra;
      while (counter < length2) {
        value2 = string.charCodeAt(counter++);
        if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      var length2 = array.length;
      var index2 = -1;
      var value2;
      var output = "";
      while (++index2 < length2) {
        value2 = array[index2];
        if (value2 > 65535) {
          value2 -= 65536;
          output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
          value2 = 56320 | value2 & 1023;
        }
        output += stringFromCharCode(value2);
      }
      return output;
    }
    function checkScalarValue(codePoint, strict) {
      if (codePoint >= 55296 && codePoint <= 57343) {
        if (strict) {
          throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
        }
        return false;
      }
      return true;
    }
    function createByte(codePoint, shift) {
      return stringFromCharCode(codePoint >> shift & 63 | 128);
    }
    function encodeCodePoint(codePoint, strict) {
      if ((codePoint & 4294967168) == 0) {
        return stringFromCharCode(codePoint);
      }
      var symbol = "";
      if ((codePoint & 4294965248) == 0) {
        symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
      } else if ((codePoint & 4294901760) == 0) {
        if (!checkScalarValue(codePoint, strict)) {
          codePoint = 65533;
        }
        symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
        symbol += createByte(codePoint, 6);
      } else if ((codePoint & 4292870144) == 0) {
        symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
      }
      symbol += stringFromCharCode(codePoint & 63 | 128);
      return symbol;
    }
    function utf8encode(string, opts) {
      opts = opts || {};
      var strict = false !== opts.strict;
      var codePoints = ucs2decode(string);
      var length2 = codePoints.length;
      var index2 = -1;
      var codePoint;
      var byteString = "";
      while (++index2 < length2) {
        codePoint = codePoints[index2];
        byteString += encodeCodePoint(codePoint, strict);
      }
      return byteString;
    }
    function readContinuationByte() {
      if (byteIndex >= byteCount) {
        throw Error("Invalid byte index");
      }
      var continuationByte = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((continuationByte & 192) == 128) {
        return continuationByte & 63;
      }
      throw Error("Invalid continuation byte");
    }
    function decodeSymbol(strict) {
      var byte1;
      var byte2;
      var byte3;
      var byte4;
      var codePoint;
      if (byteIndex > byteCount) {
        throw Error("Invalid byte index");
      }
      if (byteIndex == byteCount) {
        return false;
      }
      byte1 = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((byte1 & 128) == 0) {
        return byte1;
      }
      if ((byte1 & 224) == 192) {
        byte2 = readContinuationByte();
        codePoint = (byte1 & 31) << 6 | byte2;
        if (codePoint >= 128) {
          return codePoint;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 240) == 224) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
        if (codePoint >= 2048) {
          return checkScalarValue(codePoint, strict) ? codePoint : 65533;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 248) == 240) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (codePoint >= 65536 && codePoint <= 1114111) {
          return codePoint;
        }
      }
      throw Error("Invalid UTF-8 detected");
    }
    var byteArray;
    var byteCount;
    var byteIndex;
    function utf8decode(byteString, opts) {
      opts = opts || {};
      var strict = false !== opts.strict;
      byteArray = ucs2decode(byteString);
      byteCount = byteArray.length;
      byteIndex = 0;
      var codePoints = [];
      var tmp2;
      while ((tmp2 = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp2);
      }
      return ucs2encode(codePoints);
    }
    var utf8 = {
      version: "2.1.2",
      encode: utf8encode,
      decode: utf8decode
    };
    var base64Arraybuffer = createCommonjsModule(function(module16, exports2) {
      (function() {
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = new Uint8Array(256);
        for (var i3 = 0; i3 < chars.length; i3++) {
          lookup[chars.charCodeAt(i3)] = i3;
        }
        exports2.encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer), i4, len = bytes.length, base64 = "";
          for (i4 = 0; i4 < len; i4 += 3) {
            base64 += chars[bytes[i4] >> 2];
            base64 += chars[(bytes[i4] & 3) << 4 | bytes[i4 + 1] >> 4];
            base64 += chars[(bytes[i4 + 1] & 15) << 2 | bytes[i4 + 2] >> 6];
            base64 += chars[bytes[i4 + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports2.decode = function(base64) {
          var bufferLength = base64.length * 0.75, len = base64.length, i4, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
          for (i4 = 0; i4 < len; i4 += 4) {
            encoded1 = lookup[base64.charCodeAt(i4)];
            encoded2 = lookup[base64.charCodeAt(i4 + 1)];
            encoded3 = lookup[base64.charCodeAt(i4 + 2)];
            encoded4 = lookup[base64.charCodeAt(i4 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
      })();
    });
    var base64Arraybuffer_1 = base64Arraybuffer.encode;
    var base64Arraybuffer_2 = base64Arraybuffer.decode;
    var BlobBuilder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof WebKitBlobBuilder !== "undefined" ? WebKitBlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : false;
    var blobSupported = function() {
      try {
        var a = new Blob(["hi"]);
        return a.size === 2;
      } catch (e) {
        return false;
      }
    }();
    var blobSupportsArrayBufferView = blobSupported && function() {
      try {
        var b = new Blob([new Uint8Array([1, 2])]);
        return b.size === 2;
      } catch (e) {
        return false;
      }
    }();
    var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
    function mapArrayBufferViews(ary) {
      return ary.map(function(chunk) {
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }
          return buf;
        }
        return chunk;
      });
    }
    function BlobBuilderConstructor(ary, options) {
      options = options || {};
      var bb = new BlobBuilder();
      mapArrayBufferViews(ary).forEach(function(part) {
        bb.append(part);
      });
      return options.type ? bb.getBlob(options.type) : bb.getBlob();
    }
    function BlobConstructor(ary, options) {
      return new Blob(mapArrayBufferViews(ary), options || {});
    }
    if (typeof Blob !== "undefined") {
      BlobBuilderConstructor.prototype = Blob.prototype;
      BlobConstructor.prototype = Blob.prototype;
    }
    var blob = function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return void 0;
      }
    }();
    var browser$2 = createCommonjsModule(function(module16, exports2) {
      var base64encoder;
      if (typeof ArrayBuffer !== "undefined") {
        base64encoder = base64Arraybuffer;
      }
      var isAndroid = typeof navigator !== "undefined" && /Android/i.test(navigator.userAgent);
      var isPhantomJS = typeof navigator !== "undefined" && /PhantomJS/i.test(navigator.userAgent);
      var dontSendBlobs = isAndroid || isPhantomJS;
      exports2.protocol = 3;
      var packets = exports2.packets = {
        open: 0,
        close: 1,
        ping: 2,
        pong: 3,
        message: 4,
        upgrade: 5,
        noop: 6
      };
      var packetslist = keys(packets);
      var err = {
        type: "error",
        data: "parser error"
      };
      exports2.encodePacket = function(packet, supportsBinary, utf8encode2, callback) {
        if (typeof supportsBinary === "function") {
          callback = supportsBinary;
          supportsBinary = false;
        }
        if (typeof utf8encode2 === "function") {
          callback = utf8encode2;
          utf8encode2 = null;
        }
        var data = packet.data === void 0 ? void 0 : packet.data.buffer || packet.data;
        if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) {
          return encodeArrayBuffer(packet, supportsBinary, callback);
        } else if (typeof blob !== "undefined" && data instanceof blob) {
          return encodeBlob(packet, supportsBinary, callback);
        }
        if (data && data.base64) {
          return encodeBase64Object(packet, callback);
        }
        var encoded = packets[packet.type];
        if (void 0 !== packet.data) {
          encoded += utf8encode2 ? utf8.encode(String(packet.data), {
            strict: false
          }) : String(packet.data);
        }
        return callback("" + encoded);
      };
      function encodeBase64Object(packet, callback) {
        var message = "b" + exports2.packets[packet.type] + packet.data.data;
        return callback(message);
      }
      function encodeArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports2.encodeBase64Packet(packet, callback);
        }
        var data = packet.data;
        var contentArray = new Uint8Array(data);
        var resultBuffer = new Uint8Array(1 + data.byteLength);
        resultBuffer[0] = packets[packet.type];
        for (var i3 = 0; i3 < contentArray.length; i3++) {
          resultBuffer[i3 + 1] = contentArray[i3];
        }
        return callback(resultBuffer.buffer);
      }
      function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports2.encodeBase64Packet(packet, callback);
        }
        var fr = new FileReader();
        fr.onload = function() {
          exports2.encodePacket({
            type: packet.type,
            data: fr.result
          }, supportsBinary, true, callback);
        };
        return fr.readAsArrayBuffer(packet.data);
      }
      function encodeBlob(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports2.encodeBase64Packet(packet, callback);
        }
        if (dontSendBlobs) {
          return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
        }
        var length2 = new Uint8Array(1);
        length2[0] = packets[packet.type];
        var blob$1 = new blob([length2.buffer, packet.data]);
        return callback(blob$1);
      }
      exports2.encodeBase64Packet = function(packet, callback) {
        var message = "b" + exports2.packets[packet.type];
        if (typeof blob !== "undefined" && packet.data instanceof blob) {
          var fr = new FileReader();
          fr.onload = function() {
            var b64 = fr.result.split(",")[1];
            callback(message + b64);
          };
          return fr.readAsDataURL(packet.data);
        }
        var b64data;
        try {
          b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
        } catch (e) {
          var typed = new Uint8Array(packet.data);
          var basic = new Array(typed.length);
          for (var i3 = 0; i3 < typed.length; i3++) {
            basic[i3] = typed[i3];
          }
          b64data = String.fromCharCode.apply(null, basic);
        }
        message += btoa(b64data);
        return callback(message);
      };
      exports2.decodePacket = function(data, binaryType, utf8decode2) {
        if (data === void 0) {
          return err;
        }
        if (typeof data === "string") {
          if (data.charAt(0) === "b") {
            return exports2.decodeBase64Packet(data.substr(1), binaryType);
          }
          if (utf8decode2) {
            data = tryDecode(data);
            if (data === false) {
              return err;
            }
          }
          var type = data.charAt(0);
          if (Number(type) != type || !packetslist[type]) {
            return err;
          }
          if (data.length > 1) {
            return {
              type: packetslist[type],
              data: data.substring(1)
            };
          } else {
            return {
              type: packetslist[type]
            };
          }
        }
        var asArray = new Uint8Array(data);
        var type = asArray[0];
        var rest = arraybuffer_slice(data, 1);
        if (blob && binaryType === "blob") {
          rest = new blob([rest]);
        }
        return {
          type: packetslist[type],
          data: rest
        };
      };
      function tryDecode(data) {
        try {
          data = utf8.decode(data, {
            strict: false
          });
        } catch (e) {
          return false;
        }
        return data;
      }
      exports2.decodeBase64Packet = function(msg, binaryType) {
        var type = packetslist[msg.charAt(0)];
        if (!base64encoder) {
          return {
            type,
            data: {
              base64: true,
              data: msg.substr(1)
            }
          };
        }
        var data = base64encoder.decode(msg.substr(1));
        if (binaryType === "blob" && blob) {
          data = new blob([data]);
        }
        return {
          type,
          data
        };
      };
      exports2.encodePayload = function(packets2, supportsBinary, callback) {
        if (typeof supportsBinary === "function") {
          callback = supportsBinary;
          supportsBinary = null;
        }
        var isBinary = hasBinary2(packets2);
        if (supportsBinary && isBinary) {
          if (blob && !dontSendBlobs) {
            return exports2.encodePayloadAsBlob(packets2, callback);
          }
          return exports2.encodePayloadAsArrayBuffer(packets2, callback);
        }
        if (!packets2.length) {
          return callback("0:");
        }
        function setLengthHeader(message) {
          return message.length + ":" + message;
        }
        function encodeOne(packet, doneCallback) {
          exports2.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
            doneCallback(null, setLengthHeader(message));
          });
        }
        map2(packets2, encodeOne, function(err2, results) {
          return callback(results.join(""));
        });
      };
      function map2(ary, each, done) {
        var result = new Array(ary.length);
        var next = after_1(ary.length, done);
        var eachWithIndex = function(i4, el, cb) {
          each(el, function(error, msg) {
            result[i4] = msg;
            cb(error, result);
          });
        };
        for (var i3 = 0; i3 < ary.length; i3++) {
          eachWithIndex(i3, ary[i3], next);
        }
      }
      exports2.decodePayload = function(data, binaryType, callback) {
        if (typeof data !== "string") {
          return exports2.decodePayloadAsBinary(data, binaryType, callback);
        }
        if (typeof binaryType === "function") {
          callback = binaryType;
          binaryType = null;
        }
        var packet;
        if (data === "") {
          return callback(err, 0, 1);
        }
        var length2 = "", n, msg;
        for (var i3 = 0, l = data.length; i3 < l; i3++) {
          var chr = data.charAt(i3);
          if (chr !== ":") {
            length2 += chr;
            continue;
          }
          if (length2 === "" || length2 != (n = Number(length2))) {
            return callback(err, 0, 1);
          }
          msg = data.substr(i3 + 1, n);
          if (length2 != msg.length) {
            return callback(err, 0, 1);
          }
          if (msg.length) {
            packet = exports2.decodePacket(msg, binaryType, false);
            if (err.type === packet.type && err.data === packet.data) {
              return callback(err, 0, 1);
            }
            var ret = callback(packet, i3 + n, l);
            if (false === ret)
              return;
          }
          i3 += n;
          length2 = "";
        }
        if (length2 !== "") {
          return callback(err, 0, 1);
        }
      };
      exports2.encodePayloadAsArrayBuffer = function(packets2, callback) {
        if (!packets2.length) {
          return callback(new ArrayBuffer(0));
        }
        function encodeOne(packet, doneCallback) {
          exports2.encodePacket(packet, true, true, function(data) {
            return doneCallback(null, data);
          });
        }
        map2(packets2, encodeOne, function(err2, encodedPackets) {
          var totalLength = encodedPackets.reduce(function(acc, p) {
            var len;
            if (typeof p === "string") {
              len = p.length;
            } else {
              len = p.byteLength;
            }
            return acc + len.toString().length + len + 2;
          }, 0);
          var resultArray = new Uint8Array(totalLength);
          var bufferIndex = 0;
          encodedPackets.forEach(function(p) {
            var isString = typeof p === "string";
            var ab = p;
            if (isString) {
              var view = new Uint8Array(p.length);
              for (var i3 = 0; i3 < p.length; i3++) {
                view[i3] = p.charCodeAt(i3);
              }
              ab = view.buffer;
            }
            if (isString) {
              resultArray[bufferIndex++] = 0;
            } else {
              resultArray[bufferIndex++] = 1;
            }
            var lenStr = ab.byteLength.toString();
            for (var i3 = 0; i3 < lenStr.length; i3++) {
              resultArray[bufferIndex++] = parseInt(lenStr[i3]);
            }
            resultArray[bufferIndex++] = 255;
            var view = new Uint8Array(ab);
            for (var i3 = 0; i3 < view.length; i3++) {
              resultArray[bufferIndex++] = view[i3];
            }
          });
          return callback(resultArray.buffer);
        });
      };
      exports2.encodePayloadAsBlob = function(packets2, callback) {
        function encodeOne(packet, doneCallback) {
          exports2.encodePacket(packet, true, true, function(encoded) {
            var binaryIdentifier = new Uint8Array(1);
            binaryIdentifier[0] = 1;
            if (typeof encoded === "string") {
              var view = new Uint8Array(encoded.length);
              for (var i3 = 0; i3 < encoded.length; i3++) {
                view[i3] = encoded.charCodeAt(i3);
              }
              encoded = view.buffer;
              binaryIdentifier[0] = 0;
            }
            var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
            var lenStr = len.toString();
            var lengthAry = new Uint8Array(lenStr.length + 1);
            for (var i3 = 0; i3 < lenStr.length; i3++) {
              lengthAry[i3] = parseInt(lenStr[i3]);
            }
            lengthAry[lenStr.length] = 255;
            if (blob) {
              var blob$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
              doneCallback(null, blob$1);
            }
          });
        }
        map2(packets2, encodeOne, function(err2, results) {
          return callback(new blob(results));
        });
      };
      exports2.decodePayloadAsBinary = function(data, binaryType, callback) {
        if (typeof binaryType === "function") {
          callback = binaryType;
          binaryType = null;
        }
        var bufferTail = data;
        var buffers = [];
        while (bufferTail.byteLength > 0) {
          var tailArray = new Uint8Array(bufferTail);
          var isString = tailArray[0] === 0;
          var msgLength = "";
          for (var i3 = 1; ; i3++) {
            if (tailArray[i3] === 255)
              break;
            if (msgLength.length > 310) {
              return callback(err, 0, 1);
            }
            msgLength += tailArray[i3];
          }
          bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
          msgLength = parseInt(msgLength);
          var msg = arraybuffer_slice(bufferTail, 0, msgLength);
          if (isString) {
            try {
              msg = String.fromCharCode.apply(null, new Uint8Array(msg));
            } catch (e) {
              var typed = new Uint8Array(msg);
              msg = "";
              for (var i3 = 0; i3 < typed.length; i3++) {
                msg += String.fromCharCode(typed[i3]);
              }
            }
          }
          buffers.push(msg);
          bufferTail = arraybuffer_slice(bufferTail, msgLength);
        }
        var total = buffers.length;
        buffers.forEach(function(buffer, i4) {
          callback(exports2.decodePacket(buffer, binaryType, true), i4, total);
        });
      };
    });
    var browser_1$2 = browser$2.protocol;
    var browser_2$2 = browser$2.packets;
    var browser_3$2 = browser$2.encodePacket;
    var browser_4$2 = browser$2.encodeBase64Packet;
    var browser_5$2 = browser$2.decodePacket;
    var browser_6$2 = browser$2.decodeBase64Packet;
    var browser_7$2 = browser$2.encodePayload;
    var browser_8 = browser$2.decodePayload;
    var browser_9 = browser$2.encodePayloadAsArrayBuffer;
    var browser_10 = browser$2.encodePayloadAsBlob;
    var browser_11 = browser$2.decodePayloadAsBinary;
    var componentEmitter$1 = createCommonjsModule(function(module16) {
      {
        module16.exports = Emitter2;
      }
      function Emitter2(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key in Emitter2.prototype) {
          obj[key] = Emitter2.prototype[key];
        }
        return obj;
      }
      Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event2, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + event2] = this._callbacks["$" + event2] || []).push(fn);
        return this;
      };
      Emitter2.prototype.once = function(event2, fn) {
        function on2() {
          this.off(event2, on2);
          fn.apply(this, arguments);
        }
        on2.fn = fn;
        this.on(event2, on2);
        return this;
      };
      Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event2, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks2 = this._callbacks["$" + event2];
        if (!callbacks2)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks["$" + event2];
          return this;
        }
        var cb;
        for (var i3 = 0; i3 < callbacks2.length; i3++) {
          cb = callbacks2[i3];
          if (cb === fn || cb.fn === fn) {
            callbacks2.splice(i3, 1);
            break;
          }
        }
        return this;
      };
      Emitter2.prototype.emit = function(event2) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks2 = this._callbacks["$" + event2];
        if (callbacks2) {
          callbacks2 = callbacks2.slice(0);
          for (var i3 = 0, len = callbacks2.length; i3 < len; ++i3) {
            callbacks2[i3].apply(this, args);
          }
        }
        return this;
      };
      Emitter2.prototype.listeners = function(event2) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + event2] || [];
      };
      Emitter2.prototype.hasListeners = function(event2) {
        return !!this.listeners(event2).length;
      };
    });
    var transport = Transport;
    function Transport(opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = "";
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;
      this.isReactNative = opts.isReactNative;
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }
    componentEmitter$1(Transport.prototype);
    Transport.prototype.onError = function(msg, desc) {
      var err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    };
    Transport.prototype.open = function() {
      if ("closed" === this.readyState || "" === this.readyState) {
        this.readyState = "opening";
        this.doOpen();
      }
      return this;
    };
    Transport.prototype.close = function() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.doClose();
        this.onClose();
      }
      return this;
    };
    Transport.prototype.send = function(packets) {
      if ("open" === this.readyState) {
        this.write(packets);
      } else {
        throw new Error("Transport not open");
      }
    };
    Transport.prototype.onOpen = function() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    };
    Transport.prototype.onData = function(data) {
      var packet = browser$2.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };
    Transport.prototype.onPacket = function(packet) {
      this.emit("packet", packet);
    };
    Transport.prototype.onClose = function() {
      this.readyState = "closed";
      this.emit("close");
    };
    var encode = function(obj) {
      var str = "";
      for (var i3 in obj) {
        if (obj.hasOwnProperty(i3)) {
          if (str.length)
            str += "&";
          str += encodeURIComponent(i3) + "=" + encodeURIComponent(obj[i3]);
        }
      }
      return str;
    };
    var decode = function(qs) {
      var qry = {};
      var pairs = qs.split("&");
      for (var i3 = 0, l = pairs.length; i3 < l; i3++) {
        var pair = pairs[i3].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
    var parseqs = {
      encode,
      decode
    };
    var componentInherit = function(a, b) {
      var fn = function() {
      };
      fn.prototype = b.prototype;
      a.prototype = new fn();
      a.prototype.constructor = a;
    };
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$1 = {}, seed = 0, i2 = 0, prev;
    function encode$1(num) {
      var encoded = "";
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    function decode$1(str) {
      var decoded = 0;
      for (i2 = 0; i2 < str.length; i2++) {
        decoded = decoded * length + map$1[str.charAt(i2)];
      }
      return decoded;
    }
    function yeast() {
      var now = encode$1(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode$1(seed++);
    }
    for (; i2 < length; i2++)
      map$1[alphabet[i2]] = i2;
    yeast.encode = encode$1;
    yeast.decode = decode$1;
    var yeast_1 = yeast;
    var s$2 = 1000;
    var m$2 = s$2 * 60;
    var h$2 = m$2 * 60;
    var d$2 = h$2 * 24;
    var w$1 = d$2 * 7;
    var y$2 = d$2 * 365.25;
    var ms$2 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong$2(val) : fmtShort$2(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y$2;
        case "weeks":
        case "week":
        case "w":
          return n * w$1;
        case "days":
        case "day":
        case "d":
          return n * d$2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h$2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m$2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s$2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort$2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d$2) {
        return Math.round(ms2 / d$2) + "d";
      }
      if (msAbs >= h$2) {
        return Math.round(ms2 / h$2) + "h";
      }
      if (msAbs >= m$2) {
        return Math.round(ms2 / m$2) + "m";
      }
      if (msAbs >= s$2) {
        return Math.round(ms2 / s$2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong$2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d$2) {
        return plural$2(ms2, msAbs, d$2, "day");
      }
      if (msAbs >= h$2) {
        return plural$2(ms2, msAbs, h$2, "hour");
      }
      if (msAbs >= m$2) {
        return plural$2(ms2, msAbs, m$2, "minute");
      }
      if (msAbs >= s$2) {
        return plural$2(ms2, msAbs, s$2, "second");
      }
      return ms2 + " ms";
    }
    function plural$2(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
    function setup$1(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable2;
      createDebug.enabled = enabled;
      createDebug.humanize = ms$2;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return match;
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.enabled = createDebug.enabled(namespace);
        debug2.useColors = createDebug.useColors();
        debug2.color = selectColor(namespace);
        debug2.destroy = destroy;
        debug2.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        createDebug.instances.push(debug2);
        return debug2;
      }
      function destroy() {
        const index2 = createDebug.instances.indexOf(this);
        if (index2 !== -1) {
          createDebug.instances.splice(index2, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable2(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i3;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i3 = 0; i3 < len; i3++) {
          if (!split[i3]) {
            continue;
          }
          namespaces = split[i3].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i3 = 0; i3 < createDebug.instances.length; i3++) {
          const instance2 = createDebug.instances[i3];
          instance2.enabled = createDebug.enabled(instance2.namespace);
        }
      }
      function disable2() {
        const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i3;
        let len;
        for (i3 = 0, len = createDebug.skips.length; i3 < len; i3++) {
          if (createDebug.skips[i3].test(name)) {
            return false;
          }
        }
        for (i3 = 0, len = createDebug.names.length; i3 < len; i3++) {
          if (createDebug.names[i3].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common$1 = setup$1;
    var browser$3 = createCommonjsModule(function(module16, exports2) {
      exports2.log = log;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module16.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index2++;
          if (match === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log(...args) {
        return typeof console === "object" && console.log && console.log(...args);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module16.exports = common$1(exports2);
      const {formatters} = module16.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    });
    var browser_1$3 = browser$3.log;
    var browser_2$3 = browser$3.formatArgs;
    var browser_3$3 = browser$3.save;
    var browser_4$3 = browser$3.load;
    var browser_5$3 = browser$3.useColors;
    var browser_6$3 = browser$3.storage;
    var browser_7$3 = browser$3.colors;
    var debug$2 = browser$3("engine.io-client:polling");
    var polling = Polling;
    var hasXHR2 = function() {
      var XMLHttpRequest2 = xmlhttprequest;
      var xhr = new XMLHttpRequest2({
        xdomain: false
      });
      return null != xhr.responseType;
    }();
    function Polling(opts) {
      var forceBase64 = opts && opts.forceBase64;
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      transport.call(this, opts);
    }
    componentInherit(Polling, transport);
    Polling.prototype.name = "polling";
    Polling.prototype.doOpen = function() {
      this.poll();
    };
    Polling.prototype.pause = function(onPause) {
      var self2 = this;
      this.readyState = "pausing";
      function pause() {
        debug$2("paused");
        self2.readyState = "paused";
        onPause();
      }
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug$2("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug$2("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug$2("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug$2("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };
    Polling.prototype.poll = function() {
      debug$2("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    };
    Polling.prototype.onData = function(data) {
      var self2 = this;
      debug$2("polling got data %s", data);
      var callback = function(packet, index2, total) {
        if ("opening" === self2.readyState) {
          self2.onOpen();
        }
        if ("close" === packet.type) {
          self2.onClose();
          return false;
        }
        self2.onPacket(packet);
      };
      browser$2.decodePayload(data, this.socket.binaryType, callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emit("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug$2('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };
    Polling.prototype.doClose = function() {
      var self2 = this;
      function close() {
        debug$2("writing close packet");
        self2.write([{
          type: "close"
        }]);
      }
      if ("open" === this.readyState) {
        debug$2("transport open - closing");
        close();
      } else {
        debug$2("transport not open - deferring close");
        this.once("open", close);
      }
    };
    Polling.prototype.write = function(packets) {
      var self2 = this;
      this.writable = false;
      var callbackfn = function() {
        self2.writable = true;
        self2.emit("drain");
      };
      browser$2.encodePayload(packets, this.supportsBinary, function(data) {
        self2.doWrite(data, callbackfn);
      });
    };
    Polling.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? "https" : "http";
      var port = "";
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast_1();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.port && ("https" === schema && Number(this.port) !== 443 || "http" === schema && Number(this.port) !== 80)) {
        port = ":" + this.port;
      }
      if (query.length) {
        query = "?" + query;
      }
      var ipv6 = this.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
    };
    var debug$3 = browser$3("engine.io-client:polling-xhr");
    var pollingXhr = XHR;
    var Request_1 = Request;
    function empty$1() {
    }
    function XHR(opts) {
      polling.call(this, opts);
      this.requestTimeout = opts.requestTimeout;
      this.extraHeaders = opts.extraHeaders;
      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
    }
    componentInherit(XHR, polling);
    XHR.prototype.supportsBinary = true;
    XHR.prototype.request = function(opts) {
      opts = opts || {};
      opts.uri = this.uri();
      opts.xd = this.xd;
      opts.xs = this.xs;
      opts.agent = this.agent || false;
      opts.supportsBinary = this.supportsBinary;
      opts.enablesXDR = this.enablesXDR;
      opts.withCredentials = this.withCredentials;
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      opts.requestTimeout = this.requestTimeout;
      opts.extraHeaders = this.extraHeaders;
      return new Request(opts);
    };
    XHR.prototype.doWrite = function(data, fn) {
      var isBinary = typeof data !== "string" && data !== void 0;
      var req = this.request({
        method: "POST",
        data,
        isBinary
      });
      var self2 = this;
      req.on("success", fn);
      req.on("error", function(err) {
        self2.onError("xhr post error", err);
      });
      this.sendXhr = req;
    };
    XHR.prototype.doPoll = function() {
      debug$3("xhr poll");
      var req = this.request();
      var self2 = this;
      req.on("data", function(data) {
        self2.onData(data);
      });
      req.on("error", function(err) {
        self2.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    };
    function Request(opts) {
      this.method = opts.method || "GET";
      this.uri = opts.uri;
      this.xd = !!opts.xd;
      this.xs = !!opts.xs;
      this.async = false !== opts.async;
      this.data = void 0 !== opts.data ? opts.data : null;
      this.agent = opts.agent;
      this.isBinary = opts.isBinary;
      this.supportsBinary = opts.supportsBinary;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.requestTimeout = opts.requestTimeout;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.extraHeaders = opts.extraHeaders;
      this.create();
    }
    componentEmitter$1(Request.prototype);
    Request.prototype.create = function() {
      var opts = {
        agent: this.agent,
        xdomain: this.xd,
        xscheme: this.xs,
        enablesXDR: this.enablesXDR
      };
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      var xhr = this.xhr = new xmlhttprequest(opts);
      var self2 = this;
      try {
        debug$3("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i3 in this.extraHeaders) {
              if (this.extraHeaders.hasOwnProperty(i3)) {
                xhr.setRequestHeader(i3, this.extraHeaders[i3]);
              }
            }
          }
        } catch (e) {
        }
        if ("POST" === this.method) {
          try {
            if (this.isBinary) {
              xhr.setRequestHeader("Content-type", "application/octet-stream");
            } else {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            }
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.withCredentials;
        }
        if (this.requestTimeout) {
          xhr.timeout = this.requestTimeout;
        }
        if (this.hasXDR()) {
          xhr.onload = function() {
            self2.onLoad();
          };
          xhr.onerror = function() {
            self2.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function() {
            if (xhr.readyState === 2) {
              try {
                var contentType = xhr.getResponseHeader("Content-Type");
                if (self2.supportsBinary && contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
                  xhr.responseType = "arraybuffer";
                }
              } catch (e) {
              }
            }
            if (4 !== xhr.readyState)
              return;
            if (200 === xhr.status || 1223 === xhr.status) {
              self2.onLoad();
            } else {
              setTimeout(function() {
                self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }
        debug$3("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        setTimeout(function() {
          self2.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    };
    Request.prototype.onSuccess = function() {
      this.emit("success");
      this.cleanup();
    };
    Request.prototype.onData = function(data) {
      this.emit("data", data);
      this.onSuccess();
    };
    Request.prototype.onError = function(err) {
      this.emit("error", err);
      this.cleanup(true);
    };
    Request.prototype.cleanup = function(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty$1;
      } else {
        this.xhr.onreadystatechange = empty$1;
      }
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    };
    Request.prototype.onLoad = function() {
      var data;
      try {
        var contentType;
        try {
          contentType = this.xhr.getResponseHeader("Content-Type");
        } catch (e) {
        }
        if (contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
          data = this.xhr.response || this.xhr.responseText;
        } else {
          data = this.xhr.responseText;
        }
      } catch (e) {
        this.onError(e);
      }
      if (null != data) {
        this.onData(data);
      }
    };
    Request.prototype.hasXDR = function() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    };
    Request.prototype.abort = function() {
      this.cleanup();
    };
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        var terminationEvent = "onpagehide" in self ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    function unloadHandler() {
      for (var i3 in Request.requests) {
        if (Request.requests.hasOwnProperty(i3)) {
          Request.requests[i3].abort();
        }
      }
    }
    pollingXhr.Request = Request_1;
    var pollingJsonp = JSONPPolling;
    var rNewline = /\n/g;
    var rEscapedNewline = /\\n/g;
    var callbacks;
    function empty$2() {
    }
    function glob() {
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : {};
    }
    function JSONPPolling(opts) {
      polling.call(this, opts);
      this.query = this.query || {};
      if (!callbacks) {
        var global2 = glob();
        callbacks = global2.___eio = global2.___eio || [];
      }
      this.index = callbacks.length;
      var self2 = this;
      callbacks.push(function(msg) {
        self2.onData(msg);
      });
      this.query.j = this.index;
      if (typeof addEventListener === "function") {
        addEventListener("beforeunload", function() {
          if (self2.script)
            self2.script.onerror = empty$2;
        }, false);
      }
    }
    componentInherit(JSONPPolling, polling);
    JSONPPolling.prototype.supportsBinary = false;
    JSONPPolling.prototype.doClose = function() {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }
      polling.prototype.doClose.call(this);
    };
    JSONPPolling.prototype.doPoll = function() {
      var self2 = this;
      var script = document.createElement("script");
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      script.async = true;
      script.src = this.uri();
      script.onerror = function(e) {
        self2.onError("jsonp poll error", e);
      };
      var insertAt = document.getElementsByTagName("script")[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;
      var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
      if (isUAgecko) {
        setTimeout(function() {
          var iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    };
    JSONPPolling.prototype.doWrite = function(data, fn) {
      var self2 = this;
      if (!this.form) {
        var form = document.createElement("form");
        var area2 = document.createElement("textarea");
        var id = this.iframeId = "eio_iframe_" + this.index;
        var iframe;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area2.name = "d";
        form.appendChild(area2);
        document.body.appendChild(form);
        this.form = form;
        this.area = area2;
      }
      this.form.action = this.uri();
      function complete() {
        initIframe();
        fn();
      }
      function initIframe() {
        if (self2.iframe) {
          try {
            self2.form.removeChild(self2.iframe);
          } catch (e) {
            self2.onError("jsonp polling iframe removal error", e);
          }
        }
        try {
          var html = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = self2.iframeId;
          iframe.src = "javascript:0";
        }
        iframe.id = self2.iframeId;
        self2.form.appendChild(iframe);
        self2.iframe = iframe;
      }
      initIframe();
      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");
      try {
        this.form.submit();
      } catch (e) {
      }
      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function() {
          if (self2.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    };
    var _nodeResolve_empty = {};
    var _nodeResolve_empty$1 = Object.freeze({
      __proto__: null,
      default: _nodeResolve_empty
    });
    var require$$1 = getCjsExportFromNamespace(_nodeResolve_empty$1);
    var debug$4 = browser$3("engine.io-client:websocket");
    var BrowserWebSocket, NodeWebSocket;
    if (typeof WebSocket !== "undefined") {
      BrowserWebSocket = WebSocket;
    } else if (typeof self !== "undefined") {
      BrowserWebSocket = self.WebSocket || self.MozWebSocket;
    }
    if (typeof window === "undefined") {
      try {
        NodeWebSocket = require$$1;
      } catch (e) {
      }
    }
    var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
    var websocket = WS;
    function WS(opts) {
      var forceBase64 = opts && opts.forceBase64;
      if (forceBase64) {
        this.supportsBinary = false;
      }
      this.perMessageDeflate = opts.perMessageDeflate;
      this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
      this.protocols = opts.protocols;
      if (!this.usingBrowserWebSocket) {
        WebSocketImpl = NodeWebSocket;
      }
      transport.call(this, opts);
    }
    componentInherit(WS, transport);
    WS.prototype.name = "websocket";
    WS.prototype.supportsBinary = true;
    WS.prototype.doOpen = function() {
      if (!this.check()) {
        return;
      }
      var uri = this.uri();
      var protocols = this.protocols;
      var opts = {
        agent: this.agent,
        perMessageDeflate: this.perMessageDeflate
      };
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      if (this.extraHeaders) {
        opts.headers = this.extraHeaders;
      }
      if (this.localAddress) {
        opts.localAddress = this.localAddress;
      }
      try {
        this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }
      if (this.ws.binaryType === void 0) {
        this.supportsBinary = false;
      }
      if (this.ws.supports && this.ws.supports.binary) {
        this.supportsBinary = true;
        this.ws.binaryType = "nodebuffer";
      } else {
        this.ws.binaryType = "arraybuffer";
      }
      this.addEventListeners();
    };
    WS.prototype.addEventListeners = function() {
      var self2 = this;
      this.ws.onopen = function() {
        self2.onOpen();
      };
      this.ws.onclose = function() {
        self2.onClose();
      };
      this.ws.onmessage = function(ev) {
        self2.onData(ev.data);
      };
      this.ws.onerror = function(e) {
        self2.onError("websocket error", e);
      };
    };
    WS.prototype.write = function(packets) {
      var self2 = this;
      this.writable = false;
      var total = packets.length;
      for (var i3 = 0, l = total; i3 < l; i3++) {
        (function(packet) {
          browser$2.encodePacket(packet, self2.supportsBinary, function(data) {
            if (!self2.usingBrowserWebSocket) {
              var opts = {};
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (self2.perMessageDeflate) {
                var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                if (len < self2.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (self2.usingBrowserWebSocket) {
                self2.ws.send(data);
              } else {
                self2.ws.send(data, opts);
              }
            } catch (e) {
              debug$4("websocket closed before onclose event");
            }
            --total || done();
          });
        })(packets[i3]);
      }
      function done() {
        self2.emit("flush");
        setTimeout(function() {
          self2.writable = true;
          self2.emit("drain");
        }, 0);
      }
    };
    WS.prototype.onClose = function() {
      transport.prototype.onClose.call(this);
    };
    WS.prototype.doClose = function() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
      }
    };
    WS.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? "wss" : "ws";
      var port = "";
      if (this.port && ("wss" === schema && Number(this.port) !== 443 || "ws" === schema && Number(this.port) !== 80)) {
        port = ":" + this.port;
      }
      if (this.timestampRequests) {
        query[this.timestampParam] = yeast_1();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (query.length) {
        query = "?" + query;
      }
      var ipv6 = this.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
    };
    WS.prototype.check = function() {
      return !!WebSocketImpl && !("__initialize" in WebSocketImpl && this.name === WS.prototype.name);
    };
    var polling_1 = polling$1;
    var websocket_1 = websocket;
    function polling$1(opts) {
      var xhr;
      var xd = false;
      var xs = false;
      var jsonp = false !== opts.jsonp;
      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        xd = opts.hostname !== location.hostname || port !== opts.port;
        xs = opts.secure !== isSSL;
      }
      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new xmlhttprequest(opts);
      if ("open" in xhr && !opts.forceJSONP) {
        return new pollingXhr(opts);
      } else {
        if (!jsonp)
          throw new Error("JSONP disabled");
        return new pollingJsonp(opts);
      }
    }
    var transports = {
      polling: polling_1,
      websocket: websocket_1
    };
    var indexOf = [].indexOf;
    var indexof = function(arr, obj) {
      if (indexOf)
        return arr.indexOf(obj);
      for (var i3 = 0; i3 < arr.length; ++i3) {
        if (arr[i3] === obj)
          return i3;
      }
      return -1;
    };
    var debug$5 = browser$3("engine.io-client:socket");
    var socket = Socket;
    function Socket(uri, opts) {
      if (!(this instanceof Socket))
        return new Socket(uri, opts);
      opts = opts || {};
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }
      this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.agent = opts.agent || false;
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
      this.query = opts.query || {};
      if ("string" === typeof this.query)
        this.query = parseqs.decode(this.query);
      this.upgrade = false !== opts.upgrade;
      this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/";
      this.forceJSONP = !!opts.forceJSONP;
      this.jsonp = false !== opts.jsonp;
      this.forceBase64 = !!opts.forceBase64;
      this.enablesXDR = !!opts.enablesXDR;
      this.withCredentials = false !== opts.withCredentials;
      this.timestampParam = opts.timestampParam || "t";
      this.timestampRequests = opts.timestampRequests;
      this.transports = opts.transports || ["polling", "websocket"];
      this.transportOptions = opts.transportOptions || {};
      this.readyState = "";
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.policyPort = opts.policyPort || 843;
      this.rememberUpgrade = opts.rememberUpgrade || false;
      this.binaryType = null;
      this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
      this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
      if (true === this.perMessageDeflate)
        this.perMessageDeflate = {};
      if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
        this.perMessageDeflate.threshold = 1024;
      }
      this.pfx = opts.pfx || null;
      this.key = opts.key || null;
      this.passphrase = opts.passphrase || null;
      this.cert = opts.cert || null;
      this.ca = opts.ca || null;
      this.ciphers = opts.ciphers || null;
      this.rejectUnauthorized = opts.rejectUnauthorized === void 0 ? true : opts.rejectUnauthorized;
      this.forceNode = !!opts.forceNode;
      this.isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
      if (typeof self === "undefined" || this.isReactNative) {
        if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
          this.extraHeaders = opts.extraHeaders;
        }
        if (opts.localAddress) {
          this.localAddress = opts.localAddress;
        }
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingIntervalTimer = null;
      this.pingTimeoutTimer = null;
      this.open();
    }
    Socket.priorWebsocketSuccess = false;
    componentEmitter$1(Socket.prototype);
    Socket.protocol = browser$2.protocol;
    Socket.Socket = Socket;
    Socket.Transport = transport;
    Socket.transports = transports;
    Socket.parser = browser$2;
    Socket.prototype.createTransport = function(name) {
      debug$5('creating transport "%s"', name);
      var query = clone$1(this.query);
      query.EIO = browser$2.protocol;
      query.transport = name;
      var options = this.transportOptions[name] || {};
      if (this.id)
        query.sid = this.id;
      var transport2 = new transports[name]({
        query,
        socket: this,
        agent: options.agent || this.agent,
        hostname: options.hostname || this.hostname,
        port: options.port || this.port,
        secure: options.secure || this.secure,
        path: options.path || this.path,
        forceJSONP: options.forceJSONP || this.forceJSONP,
        jsonp: options.jsonp || this.jsonp,
        forceBase64: options.forceBase64 || this.forceBase64,
        enablesXDR: options.enablesXDR || this.enablesXDR,
        withCredentials: options.withCredentials || this.withCredentials,
        timestampRequests: options.timestampRequests || this.timestampRequests,
        timestampParam: options.timestampParam || this.timestampParam,
        policyPort: options.policyPort || this.policyPort,
        pfx: options.pfx || this.pfx,
        key: options.key || this.key,
        passphrase: options.passphrase || this.passphrase,
        cert: options.cert || this.cert,
        ca: options.ca || this.ca,
        ciphers: options.ciphers || this.ciphers,
        rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
        perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
        extraHeaders: options.extraHeaders || this.extraHeaders,
        forceNode: options.forceNode || this.forceNode,
        localAddress: options.localAddress || this.localAddress,
        requestTimeout: options.requestTimeout || this.requestTimeout,
        protocols: options.protocols || void 0,
        isReactNative: this.isReactNative
      });
      return transport2;
    };
    function clone$1(obj) {
      var o = {};
      for (var i3 in obj) {
        if (obj.hasOwnProperty(i3)) {
          o[i3] = obj[i3];
        }
      }
      return o;
    }
    Socket.prototype.open = function() {
      var transport2;
      if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport2 = "websocket";
      } else if (0 === this.transports.length) {
        var self2 = this;
        setTimeout(function() {
          self2.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport2 = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport2 = this.createTransport(transport2);
      } catch (e) {
        this.transports.shift();
        this.open();
        return;
      }
      transport2.open();
      this.setTransport(transport2);
    };
    Socket.prototype.setTransport = function(transport2) {
      debug$5("setting transport %s", transport2.name);
      var self2 = this;
      if (this.transport) {
        debug$5("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport2;
      transport2.on("drain", function() {
        self2.onDrain();
      }).on("packet", function(packet) {
        self2.onPacket(packet);
      }).on("error", function(e) {
        self2.onError(e);
      }).on("close", function() {
        self2.onClose("transport close");
      });
    };
    Socket.prototype.probe = function(name) {
      debug$5('probing transport "%s"', name);
      var transport2 = this.createTransport(name, {
        probe: 1
      });
      var failed = false;
      var self2 = this;
      Socket.priorWebsocketSuccess = false;
      function onTransportOpen() {
        if (self2.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed)
          return;
        debug$5('probe transport "%s" opened', name);
        transport2.send([{
          type: "ping",
          data: "probe"
        }]);
        transport2.once("packet", function(msg) {
          if (failed)
            return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug$5('probe transport "%s" pong', name);
            self2.upgrading = true;
            self2.emit("upgrading", transport2);
            if (!transport2)
              return;
            Socket.priorWebsocketSuccess = "websocket" === transport2.name;
            debug$5('pausing current transport "%s"', self2.transport.name);
            self2.transport.pause(function() {
              if (failed)
                return;
              if ("closed" === self2.readyState)
                return;
              debug$5("changing transport and sending upgrade packet");
              cleanup();
              self2.setTransport(transport2);
              transport2.send([{
                type: "upgrade"
              }]);
              self2.emit("upgrade", transport2);
              transport2 = null;
              self2.upgrading = false;
              self2.flush();
            });
          } else {
            debug$5('probe transport "%s" failed', name);
            var err = new Error("probe error");
            err.transport = transport2.name;
            self2.emit("upgradeError", err);
          }
        });
      }
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport2.close();
        transport2 = null;
      }
      function onerror(err) {
        var error = new Error("probe error: " + err);
        error.transport = transport2.name;
        freezeTransport();
        debug$5('probe transport "%s" failed because of error: %s', name, err);
        self2.emit("upgradeError", error);
      }
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport2 && to.name !== transport2.name) {
          debug$5('"%s" works - aborting "%s"', to.name, transport2.name);
          freezeTransport();
        }
      }
      function cleanup() {
        transport2.removeListener("open", onTransportOpen);
        transport2.removeListener("error", onerror);
        transport2.removeListener("close", onTransportClose);
        self2.removeListener("close", onclose);
        self2.removeListener("upgrading", onupgrade);
      }
      transport2.once("open", onTransportOpen);
      transport2.once("error", onerror);
      transport2.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport2.open();
    };
    Socket.prototype.onOpen = function() {
      debug$5("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emit("open");
      this.flush();
      if ("open" === this.readyState && this.upgrade && this.transport.pause) {
        debug$5("starting upgrade probes");
        for (var i3 = 0, l = this.upgrades.length; i3 < l; i3++) {
          this.probe(this.upgrades[i3]);
        }
      }
    };
    Socket.prototype.onPacket = function(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet);
        this.emit("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "pong":
            this.setPing();
            this.emit("pong");
            break;
          case "error":
            var err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug$5('packet received with socket readyState "%s"', this.readyState);
      }
    };
    Socket.prototype.onHandshake = function(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      if ("closed" === this.readyState)
        return;
      this.setPing();
      this.removeListener("heartbeat", this.onHeartbeat);
      this.on("heartbeat", this.onHeartbeat);
    };
    Socket.prototype.onHeartbeat = function(timeout) {
      clearTimeout(this.pingTimeoutTimer);
      var self2 = this;
      self2.pingTimeoutTimer = setTimeout(function() {
        if ("closed" === self2.readyState)
          return;
        self2.onClose("ping timeout");
      }, timeout || self2.pingInterval + self2.pingTimeout);
    };
    Socket.prototype.setPing = function() {
      var self2 = this;
      clearTimeout(self2.pingIntervalTimer);
      self2.pingIntervalTimer = setTimeout(function() {
        debug$5("writing ping packet - expecting pong within %sms", self2.pingTimeout);
        self2.ping();
        self2.onHeartbeat(self2.pingTimeout);
      }, self2.pingInterval);
    };
    Socket.prototype.ping = function() {
      var self2 = this;
      this.sendPacket("ping", function() {
        self2.emit("ping");
      });
    };
    Socket.prototype.onDrain = function() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emit("drain");
      } else {
        this.flush();
      }
    };
    Socket.prototype.flush = function() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug$5("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    };
    Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    };
    Socket.prototype.sendPacket = function(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = void 0;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type,
        data,
        options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    };
    Socket.prototype.close = function() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        var self2 = this;
        if (this.writeBuffer.length) {
          this.once("drain", function() {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      function close() {
        self2.onClose("forced close");
        debug$5("socket closing - telling transport to close");
        self2.transport.close();
      }
      function cleanupAndClose() {
        self2.removeListener("upgrade", cleanupAndClose);
        self2.removeListener("upgradeError", cleanupAndClose);
        close();
      }
      function waitForUpgrade() {
        self2.once("upgrade", cleanupAndClose);
        self2.once("upgradeError", cleanupAndClose);
      }
      return this;
    };
    Socket.prototype.onError = function(err) {
      debug$5("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    };
    Socket.prototype.onClose = function(reason, desc) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug$5('socket close with reason: "%s"', reason);
        var self2 = this;
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        this.readyState = "closed";
        this.id = null;
        this.emit("close", reason, desc);
        self2.writeBuffer = [];
        self2.prevBufferLen = 0;
      }
    };
    Socket.prototype.filterUpgrades = function(upgrades) {
      var filteredUpgrades = [];
      for (var i3 = 0, j = upgrades.length; i3 < j; i3++) {
        if (~indexof(this.transports, upgrades[i3]))
          filteredUpgrades.push(upgrades[i3]);
      }
      return filteredUpgrades;
    };
    var lib = socket;
    var parser = browser$2;
    lib.parser = parser;
    var toArray_1 = toArray;
    function toArray(list, index2) {
      var array = [];
      index2 = index2 || 0;
      for (var i3 = index2 || 0; i3 < list.length; i3++) {
        array[i3 - index2] = list[i3];
      }
      return array;
    }
    var on_1 = on$1;
    function on$1(obj, ev, fn) {
      obj.on(ev, fn);
      return {
        destroy: function() {
          obj.removeListener(ev, fn);
        }
      };
    }
    var slice = [].slice;
    var componentBind = function(obj, fn) {
      if ("string" == typeof fn)
        fn = obj[fn];
      if ("function" != typeof fn)
        throw new Error("bind() requires a function");
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.concat(slice.call(arguments)));
      };
    };
    var socket$1 = createCommonjsModule(function(module16, exports2) {
      var debug2 = browser("socket.io-client:socket");
      module16.exports = exports2 = Socket2;
      var events = {
        connect: 1,
        connect_error: 1,
        connect_timeout: 1,
        connecting: 1,
        disconnect: 1,
        error: 1,
        reconnect: 1,
        reconnect_attempt: 1,
        reconnect_failed: 1,
        reconnect_error: 1,
        reconnecting: 1,
        ping: 1,
        pong: 1
      };
      var emit2 = componentEmitter.prototype.emit;
      function Socket2(io, nsp, opts) {
        this.io = io;
        this.nsp = nsp;
        this.json = this;
        this.ids = 0;
        this.acks = {};
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
        this.flags = {};
        if (opts && opts.query) {
          this.query = opts.query;
        }
        if (this.io.autoConnect)
          this.open();
      }
      componentEmitter(Socket2.prototype);
      Socket2.prototype.subEvents = function() {
        if (this.subs)
          return;
        var io = this.io;
        this.subs = [on_1(io, "open", componentBind(this, "onopen")), on_1(io, "packet", componentBind(this, "onpacket")), on_1(io, "close", componentBind(this, "onclose"))];
      };
      Socket2.prototype.open = Socket2.prototype.connect = function() {
        if (this.connected)
          return this;
        this.subEvents();
        this.io.open();
        if ("open" === this.io.readyState)
          this.onopen();
        this.emit("connecting");
        return this;
      };
      Socket2.prototype.send = function() {
        var args = toArray_1(arguments);
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      };
      Socket2.prototype.emit = function(ev) {
        if (events.hasOwnProperty(ev)) {
          emit2.apply(this, arguments);
          return this;
        }
        var args = toArray_1(arguments);
        var packet = {
          type: (this.flags.binary !== void 0 ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = !this.flags || false !== this.flags.compress;
        if ("function" === typeof args[args.length - 1]) {
          debug2("emitting packet with ack id %d", this.ids);
          this.acks[this.ids] = args.pop();
          packet.id = this.ids++;
        }
        if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      };
      Socket2.prototype.packet = function(packet) {
        packet.nsp = this.nsp;
        this.io.packet(packet);
      };
      Socket2.prototype.onopen = function() {
        debug2("transport is open - connecting");
        if ("/" !== this.nsp) {
          if (this.query) {
            var query = typeof this.query === "object" ? parseqs.encode(this.query) : this.query;
            debug2("sending connect packet with query %s", query);
            this.packet({
              type: socket_ioParser.CONNECT,
              query
            });
          } else {
            this.packet({
              type: socket_ioParser.CONNECT
            });
          }
        }
      };
      Socket2.prototype.onclose = function(reason) {
        debug2("close (%s)", reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emit("disconnect", reason);
      };
      Socket2.prototype.onpacket = function(packet) {
        var sameNamespace = packet.nsp === this.nsp;
        var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === "/";
        if (!sameNamespace && !rootNamespaceError)
          return;
        switch (packet.type) {
          case socket_ioParser.CONNECT:
            this.onconnect();
            break;
          case socket_ioParser.EVENT:
            this.onevent(packet);
            break;
          case socket_ioParser.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_ioParser.ACK:
            this.onack(packet);
            break;
          case socket_ioParser.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_ioParser.DISCONNECT:
            this.ondisconnect();
            break;
          case socket_ioParser.ERROR:
            this.emit("error", packet.data);
            break;
        }
      };
      Socket2.prototype.onevent = function(packet) {
        var args = packet.data || [];
        debug2("emitting event %j", args);
        if (null != packet.id) {
          debug2("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          emit2.apply(this, args);
        } else {
          this.receiveBuffer.push(args);
        }
      };
      Socket2.prototype.ack = function(id) {
        var self2 = this;
        var sent = false;
        return function() {
          if (sent)
            return;
          sent = true;
          var args = toArray_1(arguments);
          debug2("sending ack %j", args);
          self2.packet({
            type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
            id,
            data: args
          });
        };
      };
      Socket2.prototype.onack = function(packet) {
        var ack = this.acks[packet.id];
        if ("function" === typeof ack) {
          debug2("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
          debug2("bad ack %s", packet.id);
        }
      };
      Socket2.prototype.onconnect = function() {
        this.connected = true;
        this.disconnected = false;
        this.emit("connect");
        this.emitBuffered();
      };
      Socket2.prototype.emitBuffered = function() {
        var i3;
        for (i3 = 0; i3 < this.receiveBuffer.length; i3++) {
          emit2.apply(this, this.receiveBuffer[i3]);
        }
        this.receiveBuffer = [];
        for (i3 = 0; i3 < this.sendBuffer.length; i3++) {
          this.packet(this.sendBuffer[i3]);
        }
        this.sendBuffer = [];
      };
      Socket2.prototype.ondisconnect = function() {
        debug2("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
      };
      Socket2.prototype.destroy = function() {
        if (this.subs) {
          for (var i3 = 0; i3 < this.subs.length; i3++) {
            this.subs[i3].destroy();
          }
          this.subs = null;
        }
        this.io.destroy(this);
      };
      Socket2.prototype.close = Socket2.prototype.disconnect = function() {
        if (this.connected) {
          debug2("performing disconnect (%s)", this.nsp);
          this.packet({
            type: socket_ioParser.DISCONNECT
          });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      };
      Socket2.prototype.compress = function(compress) {
        this.flags.compress = compress;
        return this;
      };
      Socket2.prototype.binary = function(binary2) {
        this.flags.binary = binary2;
        return this;
      };
    });
    var backo2 = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms2);
        ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
      }
      return Math.min(ms2, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
    var debug$6 = browser("socket.io-client:manager");
    var has = Object.prototype.hasOwnProperty;
    var manager = Manager;
    function Manager(uri, opts) {
      if (!(this instanceof Manager))
        return new Manager(uri, opts);
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1000);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new backo2({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      this.readyState = "closed";
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      var _parser = opts.parser || socket_ioParser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect)
        this.open();
    }
    Manager.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };
    Manager.prototype.updateSocketIds = function() {
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.generateId(nsp);
        }
      }
    };
    Manager.prototype.generateId = function(nsp) {
      return (nsp === "/" ? "" : nsp + "#") + this.engine.id;
    };
    componentEmitter(Manager.prototype);
    Manager.prototype.reconnection = function(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    };
    Manager.prototype.reconnectionAttempts = function(v) {
      if (!arguments.length)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    Manager.prototype.reconnectionDelay = function(v) {
      if (!arguments.length)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };
    Manager.prototype.randomizationFactor = function(v) {
      if (!arguments.length)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };
    Manager.prototype.reconnectionDelayMax = function(v) {
      if (!arguments.length)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };
    Manager.prototype.timeout = function(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    };
    Manager.prototype.maybeReconnectOnOpen = function() {
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    };
    Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
      debug$6("readyState %s", this.readyState);
      if (~this.readyState.indexOf("open"))
        return this;
      debug$6("opening %s", this.uri);
      this.engine = lib(this.uri, this.opts);
      var socket2 = this.engine;
      var self2 = this;
      this.readyState = "opening";
      this.skipReconnect = false;
      var openSub = on_1(socket2, "open", function() {
        self2.onopen();
        fn && fn();
      });
      var errorSub = on_1(socket2, "error", function(data) {
        debug$6("connect_error");
        self2.cleanup();
        self2.readyState = "closed";
        self2.emitAll("connect_error", data);
        if (fn) {
          var err = new Error("Connection error");
          err.data = data;
          fn(err);
        } else {
          self2.maybeReconnectOnOpen();
        }
      });
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug$6("connect attempt will timeout after %d", timeout);
        var timer = setTimeout(function() {
          debug$6("connect attempt timed out after %d", timeout);
          openSub.destroy();
          socket2.close();
          socket2.emit("error", "timeout");
          self2.emitAll("connect_timeout", timeout);
        }, timeout);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    };
    Manager.prototype.onopen = function() {
      debug$6("open");
      this.cleanup();
      this.readyState = "open";
      this.emit("open");
      var socket2 = this.engine;
      this.subs.push(on_1(socket2, "data", componentBind(this, "ondata")));
      this.subs.push(on_1(socket2, "ping", componentBind(this, "onping")));
      this.subs.push(on_1(socket2, "pong", componentBind(this, "onpong")));
      this.subs.push(on_1(socket2, "error", componentBind(this, "onerror")));
      this.subs.push(on_1(socket2, "close", componentBind(this, "onclose")));
      this.subs.push(on_1(this.decoder, "decoded", componentBind(this, "ondecoded")));
    };
    Manager.prototype.onping = function() {
      this.lastPing = new Date();
      this.emitAll("ping");
    };
    Manager.prototype.onpong = function() {
      this.emitAll("pong", new Date() - this.lastPing);
    };
    Manager.prototype.ondata = function(data) {
      this.decoder.add(data);
    };
    Manager.prototype.ondecoded = function(packet) {
      this.emit("packet", packet);
    };
    Manager.prototype.onerror = function(err) {
      debug$6("error", err);
      this.emitAll("error", err);
    };
    Manager.prototype.socket = function(nsp, opts) {
      var socket2 = this.nsps[nsp];
      if (!socket2) {
        socket2 = new socket$1(this, nsp, opts);
        this.nsps[nsp] = socket2;
        var self2 = this;
        socket2.on("connecting", onConnecting);
        socket2.on("connect", function() {
          socket2.id = self2.generateId(nsp);
        });
        if (this.autoConnect) {
          onConnecting();
        }
      }
      function onConnecting() {
        if (!~indexof(self2.connecting, socket2)) {
          self2.connecting.push(socket2);
        }
      }
      return socket2;
    };
    Manager.prototype.destroy = function(socket2) {
      var index2 = indexof(this.connecting, socket2);
      if (~index2)
        this.connecting.splice(index2, 1);
      if (this.connecting.length)
        return;
      this.close();
    };
    Manager.prototype.packet = function(packet) {
      debug$6("writing packet %j", packet);
      var self2 = this;
      if (packet.query && packet.type === 0)
        packet.nsp += "?" + packet.query;
      if (!self2.encoding) {
        self2.encoding = true;
        this.encoder.encode(packet, function(encodedPackets) {
          for (var i3 = 0; i3 < encodedPackets.length; i3++) {
            self2.engine.write(encodedPackets[i3], packet.options);
          }
          self2.encoding = false;
          self2.processPacketQueue();
        });
      } else {
        self2.packetBuffer.push(packet);
      }
    };
    Manager.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };
    Manager.prototype.cleanup = function() {
      debug$6("cleanup");
      var subsLength = this.subs.length;
      for (var i3 = 0; i3 < subsLength; i3++) {
        var sub = this.subs.shift();
        sub.destroy();
      }
      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;
      this.decoder.destroy();
    };
    Manager.prototype.close = Manager.prototype.disconnect = function() {
      debug$6("disconnect");
      this.skipReconnect = true;
      this.reconnecting = false;
      if ("opening" === this.readyState) {
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = "closed";
      if (this.engine)
        this.engine.close();
    };
    Manager.prototype.onclose = function(reason) {
      debug$6("onclose");
      this.cleanup();
      this.backoff.reset();
      this.readyState = "closed";
      this.emit("close", reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };
    Manager.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect)
        return this;
      var self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug$6("reconnect failed");
        this.backoff.reset();
        this.emitAll("reconnect_failed");
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug$6("will wait %dms before reconnect attempt", delay);
        this.reconnecting = true;
        var timer = setTimeout(function() {
          if (self2.skipReconnect)
            return;
          debug$6("attempting reconnect");
          self2.emitAll("reconnect_attempt", self2.backoff.attempts);
          self2.emitAll("reconnecting", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open(function(err) {
            if (err) {
              debug$6("reconnect attempt error");
              self2.reconnecting = false;
              self2.reconnect();
              self2.emitAll("reconnect_error", err.data);
            } else {
              debug$6("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
    };
    Manager.prototype.onreconnect = function() {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll("reconnect", attempt);
    };
    var lib$1 = createCommonjsModule(function(module16, exports2) {
      var debug2 = browser("socket.io-client");
      module16.exports = exports2 = lookup;
      var cache = exports2.managers = {};
      function lookup(uri, opts) {
        if (typeof uri === "object") {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        var parsed = url_1(uri);
        var source = parsed.source;
        var id = parsed.id;
        var path = parsed.path;
        var sameNamespace = cache[id] && path in cache[id].nsps;
        var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
        var io;
        if (newConnection) {
          debug2("ignoring socket cache for %s", source);
          io = manager(source, opts);
        } else {
          if (!cache[id]) {
            debug2("new io instance for %s", source);
            cache[id] = manager(source, opts);
          }
          io = cache[id];
        }
        if (parsed.query && !opts.query) {
          opts.query = parsed.query;
        }
        return io.socket(parsed.path, opts);
      }
      exports2.protocol = socket_ioParser.protocol;
      exports2.connect = lookup;
      exports2.Manager = manager;
      exports2.Socket = socket$1;
    });
    var lib_1 = lib$1.managers;
    var lib_2 = lib$1.protocol;
    var lib_3 = lib$1.connect;
    var lib_4 = lib$1.Manager;
    var lib_5 = lib$1.Socket;
    const Socket$1 = function() {
      let socket2;
      function on2(event2, fn) {
      }
      function emit2(event2, data) {
        if (socket2) {
          socket2.emit("message", {
            ...data,
            event: event2
          });
        }
      }
      return {
        on: on2,
        emit: emit2
      };
    }();
    const {console: console_1$1} = globals;
    const file$f = "src/ui/Field.svelte";
    function get_each_context$1(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[31] = list[i3];
      return child_ctx;
    }
    function get_each_context_1(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[34] = list[i3];
      return child_ctx;
    }
    function create_if_block_17(ctx) {
      let current;
      const icontrigger = new IconTrigger({
        props: {
          opacity: ctx[0].triggers && ctx[0].triggers.length > 0 ? 0.9 : 0.3
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(icontrigger.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icontrigger, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const icontrigger_changes = {};
          if (dirty[0] & 1)
            icontrigger_changes.opacity = ctx2[0].triggers && ctx2[0].triggers.length > 0 ? 0.9 : 0.3;
          icontrigger.$set(icontrigger_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(icontrigger.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icontrigger.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icontrigger, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_17.name,
        type: "if",
        source: "(3:8) {#if isTriggerable}",
        ctx
      });
      return block;
    }
    function create_if_block_16(ctx) {
      let current;
      const progressinput = new ProgressInput({
        props: {
          value: ctx[0].value,
          min: ctx[0].min,
          max: ctx[0].max,
          step: ctx[5],
          onChange: ctx[22]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(progressinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(progressinput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const progressinput_changes = {};
          if (dirty[0] & 1)
            progressinput_changes.value = ctx2[0].value;
          if (dirty[0] & 1)
            progressinput_changes.min = ctx2[0].min;
          if (dirty[0] & 1)
            progressinput_changes.max = ctx2[0].max;
          if (dirty[0] & 32)
            progressinput_changes.step = ctx2[5];
          if (dirty[0] & 1)
            progressinput_changes.onChange = ctx2[22];
          progressinput.$set(progressinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(progressinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(progressinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(progressinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_16.name,
        type: "if",
        source: "(9:8) {#if prop.min !== undefined && prop.max !== undefined}",
        ctx
      });
      return block;
    }
    function create_if_block_15(ctx) {
      let current;
      const colorinput = new ColorInput({
        props: {
          value: ctx[0].value,
          onChange: ctx[23]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(colorinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(colorinput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const colorinput_changes = {};
          if (dirty[0] & 1)
            colorinput_changes.value = ctx2[0].value;
          if (dirty[0] & 1)
            colorinput_changes.onChange = ctx2[23];
          colorinput.$set(colorinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(colorinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(colorinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(colorinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_15.name,
        type: "if",
        source: "(18:8) {#if type === 'color' }",
        ctx
      });
      return block;
    }
    function create_if_block_14(ctx) {
      let current;
      const checkbox = new Checkbox({
        props: {
          prop: ctx[0],
          onChange: ctx[24]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const checkbox_changes = {};
          if (dirty[0] & 1)
            checkbox_changes.prop = ctx2[0];
          if (dirty[0] & 1)
            checkbox_changes.onChange = ctx2[24];
          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_14.name,
        type: "if",
        source: "(21:8) {#if type === 'boolean' }",
        ctx
      });
      return block;
    }
    function create_if_block_13(ctx) {
      let current;
      const button = new Button({
        props: {
          onClick: ctx[9],
          $$slots: {
            default: [create_default_slot_7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 1073741825) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(25:8) {#if type === 'button'}",
        ctx
      });
      return block;
    }
    function create_default_slot_7(ctx) {
      let t_value = (ctx[0].label ? typeof ctx[0].label === "function" ? ctx[0].label(ctx[0]) : ctx[0].label : "Click") + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1 && t_value !== (t_value = (ctx2[0].label ? typeof ctx2[0].label === "function" ? ctx2[0].label(ctx2[0]) : ctx2[0].label : "Click") + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7.name,
        type: "slot",
        source: "(26:12) <Button onClick={handleTrigger}>",
        ctx
      });
      return block;
    }
    function create_if_block_12(ctx) {
      let current;
      const select = new Select({
        props: {
          onChange: ctx[25],
          options: ctx[0].options,
          value: ctx[0].value
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(select.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(select, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const select_changes = {};
          if (dirty[0] & 1)
            select_changes.onChange = ctx2[25];
          if (dirty[0] & 1)
            select_changes.options = ctx2[0].options;
          if (dirty[0] & 1)
            select_changes.value = ctx2[0].value;
          select.$set(select_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(select, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12.name,
        type: "if",
        source: "(28:8) {#if type === 'select'}",
        ctx
      });
      return block;
    }
    function create_if_block_11(ctx) {
      let current;
      const imageinput = new ImageInput({
        props: {
          value: ctx[0].image ? ctx[0].image : ctx[0].value,
          onChange: ctx[26]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(imageinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(imageinput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const imageinput_changes = {};
          if (dirty[0] & 1)
            imageinput_changes.value = ctx2[0].image ? ctx2[0].image : ctx2[0].value;
          if (dirty[0] & 1)
            imageinput_changes.onChange = ctx2[26];
          imageinput.$set(imageinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(imageinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(imageinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(imageinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11.name,
        type: "if",
        source: "(31:8) {#if type === 'image'}",
        ctx
      });
      return block;
    }
    function create_if_block_10(ctx) {
      let current;
      const textinput = new TextInput({
        props: {
          value: ctx[6] === "image" ? getFilename(ctx[0].value) : ctx[0].value,
          onSubmit: ctx[27],
          disabled: ctx[6] === "boolean" || ctx[6] === "image" ? true : ctx[2],
          step: ctx[5],
          type: ctx[6],
          min: ctx[0].min,
          max: ctx[0].max,
          style: "width: 70px; margin-left: 1px;"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(textinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(textinput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const textinput_changes = {};
          if (dirty[0] & 65)
            textinput_changes.value = ctx2[6] === "image" ? getFilename(ctx2[0].value) : ctx2[0].value;
          if (dirty[0] & 1)
            textinput_changes.onSubmit = ctx2[27];
          if (dirty[0] & 68)
            textinput_changes.disabled = ctx2[6] === "boolean" || ctx2[6] === "image" ? true : ctx2[2];
          if (dirty[0] & 32)
            textinput_changes.step = ctx2[5];
          if (dirty[0] & 64)
            textinput_changes.type = ctx2[6];
          if (dirty[0] & 1)
            textinput_changes.min = ctx2[0].min;
          if (dirty[0] & 1)
            textinput_changes.max = ctx2[0].max;
          textinput.$set(textinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(textinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10.name,
        type: "if",
        source: `(40:8) {#if type !== 'button' && type !== 'list' && type !== \\"select\\" && type !== 'action-list'}`,
        ctx
      });
      return block;
    }
    function create_if_block_7(ctx) {
      let div;
      let div_class_value;
      let each_value_1 = ctx[0].value;
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
        each_blocks[i3] = create_each_block_1(get_each_context_1(ctx, each_value_1, i3));
      }
      const block = {
        c: function create() {
          div = element("div");
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          attr_dev(div, "class", div_class_value = "field__value field__value--list " + (ctx[2] ? "field__value--disabled" : "") + " svelte-fntmq0");
          add_location(div, file$f, 52, 12, 2131);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(div, null);
          }
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 65) {
            each_value_1 = ctx2[0].value;
            let i3;
            for (i3 = 0; i3 < each_value_1.length; i3 += 1) {
              const child_ctx = get_each_context_1(ctx2, each_value_1, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
              } else {
                each_blocks[i3] = create_each_block_1(child_ctx);
                each_blocks[i3].c();
                each_blocks[i3].m(div, null);
              }
            }
            for (; i3 < each_blocks.length; i3 += 1) {
              each_blocks[i3].d(1);
            }
            each_blocks.length = each_value_1.length;
          }
          if (dirty[0] & 4 && div_class_value !== (div_class_value = "field__value field__value--list " + (ctx2[2] ? "field__value--disabled" : "") + " svelte-fntmq0")) {
            attr_dev(div, "class", div_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7.name,
        type: "if",
        source: "(52:8) {#if type === 'list' || type === 'action-list'}",
        ctx
      });
      return block;
    }
    function create_if_block_9(ctx) {
      let button;
      let t_value = ctx[34].value + "";
      let t;
      let dispose;
      function click_handler(...args) {
        return ctx[28](ctx[34], ...args);
      }
      const block = {
        c: function create() {
          button = element("button");
          t = text(t_value);
          attr_dev(button, "class", "field__value--listitem svelte-fntmq0");
          add_location(button, file$f, 55, 20, 2334);
          dispose = listen_dev(button, "click", click_handler, false, false, false);
        },
        m: function mount(target, anchor) {
          insert_dev(target, button, anchor);
          append_dev(button, t);
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 1 && t_value !== (t_value = ctx[34].value + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9.name,
        type: "if",
        source: "(55:20) {#if type === 'action-list'}",
        ctx
      });
      return block;
    }
    function create_if_block_8(ctx) {
      let span;
      let t_value = ctx[34].value + "";
      let t;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "field__value--listitem svelte-fntmq0");
          add_location(span, file$f, 58, 20, 2525);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1 && t_value !== (t_value = ctx2[34].value + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8.name,
        type: "if",
        source: "(58:20) {#if type === 'list'}",
        ctx
      });
      return block;
    }
    function create_each_block_1(ctx) {
      let t;
      let if_block1_anchor;
      let if_block0 = ctx[6] === "action-list" && create_if_block_9(ctx);
      let if_block1 = ctx[6] === "list" && create_if_block_8(ctx);
      const block = {
        c: function create() {
          if (if_block0)
            if_block0.c();
          t = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[6] === "action-list") {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_9(ctx2);
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (ctx2[6] === "list") {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block_8(ctx2);
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(54:16) {#each prop.value as option}",
        ctx
      });
      return block;
    }
    function create_if_block$2(ctx) {
      let current;
      const window2 = new Window({
        props: {
          title: ctx[1],
          visible: ctx[4],
          onClose: ctx[29],
          $$slots: {
            default: [create_default_slot$1],
            header: [create_header_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(window2.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(window2, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const window_changes = {};
          if (dirty[0] & 2)
            window_changes.title = ctx2[1];
          if (dirty[0] & 16)
            window_changes.visible = ctx2[4];
          if (dirty[0] & 16)
            window_changes.onClose = ctx2[29];
          if (dirty[0] & 1073742275) {
            window_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          window2.$set(window_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(window2.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(window2.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(window2, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(69:4) {#if parametersVisible}",
        ctx
      });
      return block;
    }
    function create_default_slot_6(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Reset");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6.name,
        type: "slot",
        source: '(72:12) <Button style=\\"margin-right: 1px\\" onClick={handleClickReset}>',
        ctx
      });
      return block;
    }
    function create_header_slot(ctx) {
      let div;
      let current;
      const button = new Button({
        props: {
          style: "margin-right: 1px",
          onClick: ctx[12],
          $$slots: {
            default: [create_default_slot_6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "header");
          add_location(div, file$f, 70, 8, 2953);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 1073741824) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_header_slot.name,
        type: "slot",
        source: '(71:8) <div slot=\\"header\\">',
        ctx
      });
      return block;
    }
    function create_if_block_6(ctx) {
      let div;
      let span;
      let t1;
      let current;
      const textinput = new TextInput({
        props: {
          width: "100%;",
          style: "max-width: 120px;",
          value: ctx[0].value,
          disabled: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          span.textContent = "Value:";
          t1 = space();
          create_component(textinput.$$.fragment);
          attr_dev(span, "class", "info__name");
          add_location(span, file$f, 84, 16, 3627);
          attr_dev(div, "class", "field__info svelte-fntmq0");
          add_location(div, file$f, 83, 12, 3585);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
          mount_component(textinput, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const textinput_changes = {};
          if (dirty[0] & 1)
            textinput_changes.value = ctx2[0].value;
          textinput.$set(textinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(textinput);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6.name,
        type: "if",
        source: "(83:12) {#if type !== 'button' }",
        ctx
      });
      return block;
    }
    function create_if_block_5(ctx) {
      let div;
      let span;
      let t1;
      let current;
      const textinput = new TextInput({
        props: {
          width: "100%;",
          style: "max-width: 120px;",
          value: ctx[0].min,
          disabled: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          span.textContent = "Value min:";
          t1 = space();
          create_component(textinput.$$.fragment);
          attr_dev(span, "class", "info__name");
          add_location(span, file$f, 90, 16, 3913);
          attr_dev(div, "class", "field__info svelte-fntmq0");
          add_location(div, file$f, 89, 12, 3871);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
          mount_component(textinput, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const textinput_changes = {};
          if (dirty[0] & 1)
            textinput_changes.value = ctx2[0].min;
          textinput.$set(textinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(textinput);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5.name,
        type: "if",
        source: "(89:12) {#if typeof prop.min !== 'undefined' }",
        ctx
      });
      return block;
    }
    function create_if_block_4(ctx) {
      let div;
      let span;
      let t1;
      let current;
      const textinput = new TextInput({
        props: {
          width: "100%;",
          style: "max-width: 120px;",
          value: ctx[0].max,
          disabled: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          span.textContent = "Value max:";
          t1 = space();
          create_component(textinput.$$.fragment);
          attr_dev(span, "class", "info__name");
          add_location(span, file$f, 96, 16, 4201);
          attr_dev(div, "class", "field__info svelte-fntmq0");
          add_location(div, file$f, 95, 12, 4159);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
          mount_component(textinput, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const textinput_changes = {};
          if (dirty[0] & 1)
            textinput_changes.value = ctx2[0].max;
          textinput.$set(textinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(textinput);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4.name,
        type: "if",
        source: "(95:12) {#if typeof prop.max !== 'undefined' }",
        ctx
      });
      return block;
    }
    function create_default_slot_5(ctx) {
      let div0;
      let span0;
      let t1;
      let t2;
      let div1;
      let span1;
      let t4;
      let t5;
      let t6;
      let t7;
      let if_block2_anchor;
      let current;
      const textinput0 = new TextInput({
        props: {
          width: "100%;",
          style: "max-width: 120px;",
          value: ctx[1],
          disabled: true
        },
        $$inline: true
      });
      const textinput1 = new TextInput({
        props: {
          width: "100%;",
          style: "max-width: 120px;",
          value: ctx[6],
          disabled: true
        },
        $$inline: true
      });
      let if_block0 = ctx[6] !== "button" && create_if_block_6(ctx);
      let if_block1 = typeof ctx[0].min !== "undefined" && create_if_block_5(ctx);
      let if_block2 = typeof ctx[0].max !== "undefined" && create_if_block_4(ctx);
      const block = {
        c: function create() {
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "Name:";
          t1 = space();
          create_component(textinput0.$$.fragment);
          t2 = space();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "Type:";
          t4 = space();
          create_component(textinput1.$$.fragment);
          t5 = space();
          if (if_block0)
            if_block0.c();
          t6 = space();
          if (if_block1)
            if_block1.c();
          t7 = space();
          if (if_block2)
            if_block2.c();
          if_block2_anchor = empty();
          attr_dev(span0, "class", "info__name");
          add_location(span0, file$f, 75, 16, 3170);
          attr_dev(div0, "class", "field__info svelte-fntmq0");
          add_location(div0, file$f, 74, 12, 3128);
          attr_dev(span1, "class", "info__name");
          add_location(span1, file$f, 79, 16, 3380);
          attr_dev(div1, "class", "field__info svelte-fntmq0");
          add_location(div1, file$f, 78, 12, 3338);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, span0);
          append_dev(div0, t1);
          mount_component(textinput0, div0, null);
          insert_dev(target, t2, anchor);
          insert_dev(target, div1, anchor);
          append_dev(div1, span1);
          append_dev(div1, t4);
          mount_component(textinput1, div1, null);
          insert_dev(target, t5, anchor);
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t6, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, t7, anchor);
          if (if_block2)
            if_block2.m(target, anchor);
          insert_dev(target, if_block2_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const textinput0_changes = {};
          if (dirty[0] & 2)
            textinput0_changes.value = ctx2[1];
          textinput0.$set(textinput0_changes);
          const textinput1_changes = {};
          if (dirty[0] & 64)
            textinput1_changes.value = ctx2[6];
          textinput1.$set(textinput1_changes);
          if (ctx2[6] !== "button") {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_6(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t6.parentNode, t6);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (typeof ctx2[0].min !== "undefined") {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_5(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t7.parentNode, t7);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (typeof ctx2[0].max !== "undefined") {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block_4(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textinput0.$$.fragment, local);
          transition_in(textinput1.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          transition_out(textinput0.$$.fragment, local);
          transition_out(textinput1.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div0);
          destroy_component(textinput0);
          if (detaching)
            detach_dev(t2);
          if (detaching)
            detach_dev(div1);
          destroy_component(textinput1);
          if (detaching)
            detach_dev(t5);
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t6);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(t7);
          if (if_block2)
            if_block2.d(detaching);
          if (detaching)
            detach_dev(if_block2_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5.name,
        type: "slot",
        source: '(74:8) <Dropdown title=\\"Informations\\">',
        ctx
      });
      return block;
    }
    function create_if_block_2(ctx) {
      let current;
      const dropdown = new Dropdown({
        props: {
          title: "Triggers",
          $$slots: {
            default: [create_default_slot_3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown_changes = {};
          if (dirty[0] & 1073741825) {
            dropdown_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown.$set(dropdown_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2.name,
        type: "if",
        source: "(102:8) {#if isTriggerable }",
        ctx
      });
      return block;
    }
    function create_if_block_3(ctx) {
      let each_1_anchor;
      let current;
      let each_value = ctx[0].triggers;
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block$1(get_each_context$1(ctx, each_value, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1) {
            each_value = ctx2[0].triggers;
            let i3;
            for (i3 = 0; i3 < each_value.length; i3 += 1) {
              const child_ctx = get_each_context$1(ctx2, each_value, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block$1(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3.name,
        type: "if",
        source: "(104:12) {#if (prop.triggers && prop.triggers.length > 0)}",
        ctx
      });
      return block;
    }
    function create_each_block$1(ctx) {
      let current;
      const triggerinput = new TriggerInput({
        props: {
          trigger: ctx[31]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(triggerinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(triggerinput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const triggerinput_changes = {};
          if (dirty[0] & 1)
            triggerinput_changes.trigger = ctx2[31];
          triggerinput.$set(triggerinput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(triggerinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(triggerinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(triggerinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$1.name,
        type: "each",
        source: "(105:16) {#each prop.triggers as trigger}",
        ctx
      });
      return block;
    }
    function create_default_slot_4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Add");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4.name,
        type: "slot",
        source: '(110:16) <Button style=\\"width: 50%; text-align: center;\\" onClick={handleClickAddTrigger}>',
        ctx
      });
      return block;
    }
    function create_default_slot_3(ctx) {
      let t;
      let div;
      let current;
      let if_block = ctx[0].triggers && ctx[0].triggers.length > 0 && create_if_block_3(ctx);
      const button = new Button({
        props: {
          style: "width: 50%; text-align: center;",
          onClick: ctx[11],
          $$slots: {
            default: [create_default_slot_4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          if (if_block)
            if_block.c();
          t = space();
          div = element("div");
          create_component(button.$$.fragment);
          set_style(div, "display", "flex");
          set_style(div, "justify-content", "center");
          add_location(div, file$f, 108, 12, 4686);
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[0].triggers && ctx2[0].triggers.length > 0) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block_3(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t.parentNode, t);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
          const button_changes = {};
          if (dirty[0] & 1073741824) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(t);
          if (detaching)
            detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3.name,
        type: "slot",
        source: '(103:8) <Dropdown title=\\"Triggers\\">',
        ctx
      });
      return block;
    }
    function create_if_block_1(ctx) {
      let current;
      const dropdown = new Dropdown({
        props: {
          title: "Actions",
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown_changes = {};
          if (dirty[0] & 1073741824) {
            dropdown_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown.$set(dropdown_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1.name,
        type: "if",
        source: "(114:8) {#if isStreamable}",
        ctx
      });
      return block;
    }
    function create_default_slot_2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Set webcam feed");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2.name,
        type: "slot",
        source: "(116:12) <Button onClick={handleClickSetWebcam}>",
        ctx
      });
      return block;
    }
    function create_default_slot_1(ctx) {
      let current;
      const button = new Button({
        props: {
          onClick: ctx[13],
          $$slots: {
            default: [create_default_slot_2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 1073741824) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1.name,
        type: "slot",
        source: '(115:8) <Dropdown title=\\"Actions\\">',
        ctx
      });
      return block;
    }
    function create_default_slot$1(ctx) {
      let t0;
      let t1;
      let t2;
      let if_block1_anchor;
      let current;
      const dropdown = new Dropdown({
        props: {
          title: "Informations",
          $$slots: {
            default: [create_default_slot_5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      let if_block0 = ctx[7] && create_if_block_2(ctx);
      let if_block1 = ctx[8] && create_if_block_1(ctx);
      const block = {
        c: function create() {
          t0 = space();
          create_component(dropdown.$$.fragment);
          t1 = space();
          if (if_block0)
            if_block0.c();
          t2 = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(dropdown, target, anchor);
          insert_dev(target, t1, anchor);
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown_changes = {};
          if (dirty[0] & 1073741891) {
            dropdown_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown.$set(dropdown_changes);
          if (ctx2[7]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_2(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t2.parentNode, t2);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (ctx2[8]) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_1(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown, detaching);
          if (detaching)
            detach_dev(t1);
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t2);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$1.name,
        type: "slot",
        source: "(70:4) <Window title={name} visible={parametersVisible} onClose={(visibility) => parametersVisible = visibility}>",
        ctx
      });
      return block;
    }
    function create_fragment$f(ctx) {
      let div3;
      let div0;
      let t0;
      let div1;
      let t1;
      let t2;
      let div2;
      let t3;
      let t4;
      let t5;
      let t6;
      let t7;
      let t8;
      let t9;
      let t10;
      let div2_class_value;
      let t11;
      let button;
      let t12;
      let current;
      let dispose;
      let if_block0 = ctx[7] && create_if_block_17(ctx);
      let if_block1 = ctx[0].min !== void 0 && ctx[0].max !== void 0 && create_if_block_16(ctx);
      let if_block2 = ctx[6] === "color" && create_if_block_15(ctx);
      let if_block3 = ctx[6] === "boolean" && create_if_block_14(ctx);
      let if_block4 = ctx[6] === "button" && create_if_block_13(ctx);
      let if_block5 = ctx[6] === "select" && create_if_block_12(ctx);
      let if_block6 = ctx[6] === "image" && create_if_block_11(ctx);
      let if_block7 = ctx[6] !== "button" && ctx[6] !== "list" && ctx[6] !== "select" && ctx[6] !== "action-list" && create_if_block_10(ctx);
      let if_block8 = (ctx[6] === "list" || ctx[6] === "action-list") && create_if_block_7(ctx);
      const default_slot_template = ctx[21].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[30], null);
      const iconsettings = new IconSettings({
        $$inline: true
      });
      let if_block9 = ctx[4] && create_if_block$2(ctx);
      const block = {
        c: function create() {
          div3 = element("div");
          div0 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          div1 = element("div");
          t1 = text(ctx[1]);
          t2 = space();
          div2 = element("div");
          if (if_block1)
            if_block1.c();
          t3 = space();
          if (if_block2)
            if_block2.c();
          t4 = space();
          if (if_block3)
            if_block3.c();
          t5 = space();
          if (if_block4)
            if_block4.c();
          t6 = space();
          if (if_block5)
            if_block5.c();
          t7 = space();
          if (if_block6)
            if_block6.c();
          t8 = space();
          if (if_block7)
            if_block7.c();
          t9 = space();
          if (if_block8)
            if_block8.c();
          t10 = space();
          if (default_slot)
            default_slot.c();
          t11 = space();
          button = element("button");
          create_component(iconsettings.$$.fragment);
          t12 = space();
          if (if_block9)
            if_block9.c();
          attr_dev(div0, "class", "field__trigger svelte-fntmq0");
          add_location(div0, file$f, 1, 4, 24);
          attr_dev(div1, "class", "field__name svelte-fntmq0");
          add_location(div1, file$f, 6, 4, 197);
          attr_dev(div2, "class", div2_class_value = "field__content " + (ctx[3] ? "field__content--wrap" : "") + " svelte-fntmq0");
          add_location(div2, file$f, 7, 4, 239);
          attr_dev(button, "class", "field__settings svelte-fntmq0");
          add_location(button, file$f, 65, 4, 2704);
          attr_dev(div3, "class", "field svelte-fntmq0");
          add_location(div3, file$f, 0, 0, 0);
          dispose = listen_dev(button, "click", ctx[10], false, false, false);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          if (if_block0)
            if_block0.m(div0, null);
          append_dev(div3, t0);
          append_dev(div3, div1);
          append_dev(div1, t1);
          append_dev(div3, t2);
          append_dev(div3, div2);
          if (if_block1)
            if_block1.m(div2, null);
          append_dev(div2, t3);
          if (if_block2)
            if_block2.m(div2, null);
          append_dev(div2, t4);
          if (if_block3)
            if_block3.m(div2, null);
          append_dev(div2, t5);
          if (if_block4)
            if_block4.m(div2, null);
          append_dev(div2, t6);
          if (if_block5)
            if_block5.m(div2, null);
          append_dev(div2, t7);
          if (if_block6)
            if_block6.m(div2, null);
          append_dev(div2, t8);
          if (if_block7)
            if_block7.m(div2, null);
          append_dev(div2, t9);
          if (if_block8)
            if_block8.m(div2, null);
          append_dev(div2, t10);
          if (default_slot) {
            default_slot.m(div2, null);
          }
          append_dev(div3, t11);
          append_dev(div3, button);
          mount_component(iconsettings, button, null);
          append_dev(div3, t12);
          if (if_block9)
            if_block9.m(div3, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[7]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_17(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div0, null);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (!current || dirty[0] & 2)
            set_data_dev(t1, ctx2[1]);
          if (ctx2[0].min !== void 0 && ctx2[0].max !== void 0) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_16(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div2, t3);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "color") {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block_15(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div2, t4);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "boolean") {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              transition_in(if_block3, 1);
            } else {
              if_block3 = create_if_block_14(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div2, t5);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "button") {
            if (if_block4) {
              if_block4.p(ctx2, dirty);
              transition_in(if_block4, 1);
            } else {
              if_block4 = create_if_block_13(ctx2);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div2, t6);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "select") {
            if (if_block5) {
              if_block5.p(ctx2, dirty);
              transition_in(if_block5, 1);
            } else {
              if_block5 = create_if_block_12(ctx2);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(div2, t7);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "image") {
            if (if_block6) {
              if_block6.p(ctx2, dirty);
              transition_in(if_block6, 1);
            } else {
              if_block6 = create_if_block_11(ctx2);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(div2, t8);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }
          if (ctx2[6] !== "button" && ctx2[6] !== "list" && ctx2[6] !== "select" && ctx2[6] !== "action-list") {
            if (if_block7) {
              if_block7.p(ctx2, dirty);
              transition_in(if_block7, 1);
            } else {
              if_block7 = create_if_block_10(ctx2);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div2, t9);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }
          if (ctx2[6] === "list" || ctx2[6] === "action-list") {
            if (if_block8) {
              if_block8.p(ctx2, dirty);
            } else {
              if_block8 = create_if_block_7(ctx2);
              if_block8.c();
              if_block8.m(div2, t10);
            }
          } else if (if_block8) {
            if_block8.d(1);
            if_block8 = null;
          }
          if (default_slot && default_slot.p && dirty[0] & 1073741824) {
            default_slot.p(get_slot_context(default_slot_template, ctx2, ctx2[30], null), get_slot_changes(default_slot_template, ctx2[30], dirty, null));
          }
          if (!current || dirty[0] & 8 && div2_class_value !== (div2_class_value = "field__content " + (ctx2[3] ? "field__content--wrap" : "") + " svelte-fntmq0")) {
            attr_dev(div2, "class", div2_class_value);
          }
          if (ctx2[4]) {
            if (if_block9) {
              if_block9.p(ctx2, dirty);
              transition_in(if_block9, 1);
            } else {
              if_block9 = create_if_block$2(ctx2);
              if_block9.c();
              transition_in(if_block9, 1);
              if_block9.m(div3, null);
            }
          } else if (if_block9) {
            group_outros();
            transition_out(if_block9, 1, 1, () => {
              if_block9 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(if_block5);
          transition_in(if_block6);
          transition_in(if_block7);
          transition_in(default_slot, local);
          transition_in(iconsettings.$$.fragment, local);
          transition_in(if_block9);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(if_block5);
          transition_out(if_block6);
          transition_out(if_block7);
          transition_out(default_slot, local);
          transition_out(iconsettings.$$.fragment, local);
          transition_out(if_block9);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div3);
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
          if (if_block2)
            if_block2.d();
          if (if_block3)
            if_block3.d();
          if (if_block4)
            if_block4.d();
          if (if_block5)
            if_block5.d();
          if (if_block6)
            if_block6.d();
          if (if_block7)
            if_block7.d();
          if (if_block8)
            if_block8.d();
          if (default_slot)
            default_slot.d(detaching);
          destroy_component(iconsettings);
          if (if_block9)
            if_block9.d();
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$c($$self, $$props, $$invalidate) {
      let {prop} = $$props;
      let {name = ""} = $$props;
      let {triggerable = true} = $$props;
      let {disabled = false} = $$props;
      let {output = false} = $$props;
      let {url: url2 = ""} = $$props;
      let {wrap = false} = $$props;
      redhydrate(url2);
      function redhydrate(key) {
        if (key.length > 0 && Storage.get(key)) {
          let parsed = JSON.parse(Storage.get(key));
          $$invalidate(0, prop.initialValue = prop.value, prop);
          $$invalidate(0, prop.value = parsed.value, prop);
          if (prop.value === "WEBCAM_0") {
            $$invalidate(0, prop.image = Webcam.canvas, prop);
            $$invalidate(0, prop.needsUpdate = true, prop);
          } else {
            $$invalidate(0, prop.needsUpdate = false, prop);
          }
        }
      }
      function save(key, value2) {
        if (key.length > 0) {
          Storage.set(url2, JSON.stringify(value2));
        }
      }
      if (output) {
        Socket$1.on("PROP_CHANGE", (data) => {
          if (data.url === url2) {
            $$invalidate(0, prop.value = data.value, prop);
          }
        });
      }
      let parametersVisible = false;
      if (prop.triggers && prop.triggers.length > 0) {
        for (let i3 = 0; i3 < prop.triggers.length; i3++) {
          prop.triggers[i3].onTrigger((params2) => {
            if (type === "boolean") {
              setValue(!prop.value);
            } else if (prop.min !== void 0 && prop.max !== void 0 && params2.value !== void 0) {
              let v = map(params2.value, 0, 1, prop.min, prop.max);
              setValue(v);
              if (prop.onTrigger) {
                prop.onTrigger(params2);
              }
            } else if (prop.onTrigger) {
              prop.onTrigger();
            }
          });
        }
      }
      function handleTrigger(event2) {
        if (typeof prop.onTrigger === "function") {
          prop.onTrigger(prop);
        }
      }
      function handleClickSettings(event2) {
        $$invalidate(4, parametersVisible = true);
      }
      function setValue(v) {
        if (prop.min !== void 0 && prop.max !== void 0) {
          $$invalidate(0, prop.value = Math.floor(clamp(v, prop.min, prop.max) * (1 / step)) / (1 / step), prop);
        } else {
          $$invalidate(0, prop.value = v, prop);
        }
        if (typeof prop.onChange === "function") {
          prop.onChange(prop);
        }
      }
      function handleClickAddTrigger() {
        $$invalidate(0, prop.triggers = [...prop.triggers, Keyboard.key("")], prop);
      }
      function handleClickReset() {
        console.log(prop);
        if (prop.initialValue) {
          $$invalidate(0, prop.value = prop.initialValue, prop);
        }
      }
      function handleClickSetWebcam() {
        $$invalidate(0, prop.image = Webcam.canvas, prop);
        $$invalidate(0, prop.value = "WEBCAM_0", prop);
        $$invalidate(0, prop.needsUpdate = true, prop);
      }
      const writable_props = ["prop", "name", "triggerable", "disabled", "output", "url", "wrap"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console_1$1.warn(`<Field> was created with unknown prop '${key}'`);
      });
      let {$$slots = {}, $$scope} = $$props;
      const func = (value2) => $$invalidate(0, prop.value = value2, prop);
      const func_1 = (value2) => $$invalidate(0, prop.value = value2, prop);
      const func_2 = (value2) => $$invalidate(0, prop.value = value2, prop);
      const func_3 = (value2) => $$invalidate(0, prop.value = value2.key, prop);
      const func_4 = ({image, name: name2}) => {
        $$invalidate(0, prop.image = image, prop);
        $$invalidate(0, prop.value = name2, prop);
      };
      const func_5 = (value2) => $$invalidate(0, prop.value = value2, prop);
      const click_handler = (option) => prop.onTrigger(option);
      const func_6 = (visibility) => $$invalidate(4, parametersVisible = visibility);
      $$self.$set = ($$props2) => {
        if ("prop" in $$props2)
          $$invalidate(0, prop = $$props2.prop);
        if ("name" in $$props2)
          $$invalidate(1, name = $$props2.name);
        if ("triggerable" in $$props2)
          $$invalidate(14, triggerable = $$props2.triggerable);
        if ("disabled" in $$props2)
          $$invalidate(2, disabled = $$props2.disabled);
        if ("output" in $$props2)
          $$invalidate(15, output = $$props2.output);
        if ("url" in $$props2)
          $$invalidate(16, url2 = $$props2.url);
        if ("wrap" in $$props2)
          $$invalidate(3, wrap = $$props2.wrap);
        if ("$$scope" in $$props2)
          $$invalidate(30, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => {
        return {
          prop,
          name,
          triggerable,
          disabled,
          output,
          url: url2,
          wrap,
          parametersVisible,
          step,
          type,
          isTriggerable,
          isStreamable,
          checked
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("prop" in $$props2)
          $$invalidate(0, prop = $$props2.prop);
        if ("name" in $$props2)
          $$invalidate(1, name = $$props2.name);
        if ("triggerable" in $$props2)
          $$invalidate(14, triggerable = $$props2.triggerable);
        if ("disabled" in $$props2)
          $$invalidate(2, disabled = $$props2.disabled);
        if ("output" in $$props2)
          $$invalidate(15, output = $$props2.output);
        if ("url" in $$props2)
          $$invalidate(16, url2 = $$props2.url);
        if ("wrap" in $$props2)
          $$invalidate(3, wrap = $$props2.wrap);
        if ("parametersVisible" in $$props2)
          $$invalidate(4, parametersVisible = $$props2.parametersVisible);
        if ("step" in $$props2)
          $$invalidate(5, step = $$props2.step);
        if ("type" in $$props2)
          $$invalidate(6, type = $$props2.type);
        if ("isTriggerable" in $$props2)
          $$invalidate(7, isTriggerable = $$props2.isTriggerable);
        if ("isStreamable" in $$props2)
          $$invalidate(8, isStreamable = $$props2.isStreamable);
        if ("checked" in $$props2)
          checked = $$props2.checked;
      };
      let step;
      let type;
      let isTriggerable;
      let isStreamable;
      let checked;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 1) {
          $$invalidate(5, step = prop.step ? prop.step : 0.1);
        }
        if ($$self.$$.dirty[0] & 1) {
          $$invalidate(6, type = prop.type ? prop.type : typeof prop.value);
        }
        if ($$self.$$.dirty[0] & 16448) {
          $$invalidate(7, isTriggerable = triggerable && ["boolean", "number", "button"].includes(type));
        }
        if ($$self.$$.dirty[0] & 64) {
          $$invalidate(8, isStreamable = type === "image");
        }
        if ($$self.$$.dirty[0] & 1) {
          checked = prop.value ? true : false;
        }
        if ($$self.$$.dirty[0] & 1) {
          {
            if (typeof prop.onChange === "function" && prop.value !== void 0) {
              prop.onChange(prop);
            }
          }
        }
        if ($$self.$$.dirty[0] & 98305) {
          {
            let serialized = {
              value: prop.value
            };
            if (!output) {
              save(url2, serialized);
            }
            if (!output) {
              Socket$1.emit("PROP_CHANGE", {
                url: url2,
                ...serialized
              });
            }
          }
        }
      };
      return [prop, name, disabled, wrap, parametersVisible, step, type, isTriggerable, isStreamable, handleTrigger, handleClickSettings, handleClickAddTrigger, handleClickReset, handleClickSetWebcam, triggerable, output, url2, checked, redhydrate, save, setValue, $$slots, func, func_1, func_2, func_3, func_4, func_5, click_handler, func_6, $$scope];
    }
    class Field extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$c, create_fragment$f, safe_not_equal, {
          prop: 0,
          name: 1,
          triggerable: 14,
          disabled: 2,
          output: 15,
          url: 16,
          wrap: 3
        }, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Field",
          options,
          id: create_fragment$f.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("prop" in props)) {
          console_1$1.warn("<Field> was created without expected prop 'prop'");
        }
      }
      get prop() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set prop(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get name() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set name(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get triggerable() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set triggerable(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get output() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set output(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get url() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set url(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get wrap() {
        throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set wrap(value2) {
        throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const subscriber_queue = [];
    function writable(value2, start = noop) {
      let stop;
      const subscribers = [];
      function set(new_value) {
        if (safe_not_equal(value2, new_value)) {
          value2 = new_value;
          if (stop) {
            const run_queue = !subscriber_queue.length;
            for (let i3 = 0; i3 < subscribers.length; i3 += 1) {
              const s2 = subscribers[i3];
              s2[1]();
              subscriber_queue.push(s2, value2);
            }
            if (run_queue) {
              for (let i3 = 0; i3 < subscriber_queue.length; i3 += 2) {
                subscriber_queue[i3][0](subscriber_queue[i3 + 1]);
              }
              subscriber_queue.length = 0;
            }
          }
        }
      }
      function update2(fn) {
        set(fn(value2));
      }
      function subscribe2(run2, invalidate = noop) {
        const subscriber = [run2, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
          stop = start(set) || noop;
        }
        run2(value2);
        return () => {
          const index2 = subscribers.indexOf(subscriber);
          if (index2 !== -1) {
            subscribers.splice(index2, 1);
          }
          if (subscribers.length === 0) {
            stop();
            stop = null;
          }
        };
      }
      return {
        set,
        update: update2,
        subscribe: subscribe2
      };
    }
    let rendererDimensions = writable({
      width: 0,
      height: 0
    });
    let currentStages = writable({
      stage1: null,
      stage2: null
    });
    const file$g = "src/ui/Preview.svelte";
    function create_fragment$g(ctx) {
      let div;
      let canvas_1;
      let div_style_value;
      let div_resize_listener;
      const block = {
        c: function create() {
          div = element("div");
          canvas_1 = element("canvas");
          attr_dev(canvas_1, "class", "svelte-ejx3hf");
          add_location(canvas_1, file$g, 1, 4, 109);
          attr_dev(div, "class", "preview svelte-ejx3hf");
          attr_dev(div, "style", div_style_value = `height: ${ctx[3]}px`);
          add_render_callback(() => ctx[13].call(div));
          add_location(div, file$g, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, canvas_1);
          ctx[12](canvas_1);
          div_resize_listener = add_resize_listener(div, ctx[13].bind(div));
          ctx[14](div);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 8 && div_style_value !== (div_style_value = `height: ${ctx2[3]}px`)) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          ctx[12](null);
          div_resize_listener.cancel();
          ctx[14](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$g.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$d($$self, $$props, $$invalidate) {
      let $rendererDimensions;
      validate_store(rendererDimensions, "rendererDimensions");
      component_subscribe($$self, rendererDimensions, ($$value) => $$invalidate(11, $rendererDimensions = $$value));
      let {renderer} = $$props;
      let {stage} = $$props;
      let {dpr = renderer.dpr} = $$props;
      let canvas, container, offsetWidth;
      let context;
      let prevStage = stage;
      const writable_props = ["renderer", "stage", "dpr"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Preview> was created with unknown prop '${key}'`);
      });
      function canvas_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(0, canvas = $$value);
        });
      }
      function div_elementresize_handler() {
        offsetWidth = this.offsetWidth;
        $$invalidate(2, offsetWidth);
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(1, container = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(5, renderer = $$props2.renderer);
        if ("stage" in $$props2)
          $$invalidate(4, stage = $$props2.stage);
        if ("dpr" in $$props2)
          $$invalidate(6, dpr = $$props2.dpr);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          stage,
          dpr,
          canvas,
          container,
          offsetWidth,
          context,
          prevStage,
          height,
          canvasWidth,
          canvasHeight,
          $rendererDimensions
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(5, renderer = $$props2.renderer);
        if ("stage" in $$props2)
          $$invalidate(4, stage = $$props2.stage);
        if ("dpr" in $$props2)
          $$invalidate(6, dpr = $$props2.dpr);
        if ("canvas" in $$props2)
          $$invalidate(0, canvas = $$props2.canvas);
        if ("container" in $$props2)
          $$invalidate(1, container = $$props2.container);
        if ("offsetWidth" in $$props2)
          $$invalidate(2, offsetWidth = $$props2.offsetWidth);
        if ("context" in $$props2)
          $$invalidate(7, context = $$props2.context);
        if ("prevStage" in $$props2)
          $$invalidate(8, prevStage = $$props2.prevStage);
        if ("height" in $$props2)
          $$invalidate(3, height = $$props2.height);
        if ("canvasWidth" in $$props2)
          $$invalidate(9, canvasWidth = $$props2.canvasWidth);
        if ("canvasHeight" in $$props2)
          $$invalidate(10, canvasHeight = $$props2.canvasHeight);
        if ("$rendererDimensions" in $$props2)
          rendererDimensions.set($rendererDimensions = $$props2.$rendererDimensions);
      };
      let height;
      let canvasWidth;
      let canvasHeight;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 4) {
          $$invalidate(3, height = window.innerHeight * offsetWidth / window.innerWidth);
        }
        if ($$self.$$.dirty[0] & 68) {
          $$invalidate(9, canvasWidth = offsetWidth * dpr);
        }
        if ($$self.$$.dirty[0] & 2116) {
          $$invalidate(10, canvasHeight = $rendererDimensions.height * offsetWidth / $rendererDimensions.width * dpr);
        }
        if ($$self.$$.dirty[0] & 1683) {
          {
            if (canvas) {
              $$invalidate(0, canvas.width = canvasWidth, canvas);
              $$invalidate(0, canvas.height = canvasHeight, canvas);
              $$invalidate(7, context = canvas.getContext("2d"));
            }
            if (stage && context) {
              $$invalidate(4, stage.context = context, stage);
              if (typeof stage.instance.onMount === "function") {
                stage.instance.onMount({
                  container,
                  canvas
                });
              }
            }
          }
        }
        if ($$self.$$.dirty[0] & 275) {
          {
            if (prevStage.name !== stage.name) {
              if (typeof prevStage.instance.onUnmount === "function") {
                prevStage.instance.onUnmount({
                  container,
                  canvas
                });
              }
              $$invalidate(8, prevStage = stage);
            }
          }
        }
      };
      return [canvas, container, offsetWidth, height, stage, renderer, dpr, context, prevStage, canvasWidth, canvasHeight, $rendererDimensions, canvas_1_binding, div_elementresize_handler, div_binding];
    }
    class Preview extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$d, create_fragment$g, safe_not_equal, {
          renderer: 5,
          stage: 4,
          dpr: 6
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Preview",
          options,
          id: create_fragment$g.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[5] === void 0 && !("renderer" in props)) {
          console.warn("<Preview> was created without expected prop 'renderer'");
        }
        if (ctx[4] === void 0 && !("stage" in props)) {
          console.warn("<Preview> was created without expected prop 'stage'");
        }
      }
      get renderer() {
        throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get stage() {
        throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stage(value2) {
        throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dpr() {
        throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dpr(value2) {
        throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const {Object: Object_1} = globals;
    const file$h = "src/ui/PanelStage.svelte";
    function get_each_context$2(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i3];
      return child_ctx;
    }
    function get_each_context_2(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i3];
      return child_ctx;
    }
    function get_each_context_1$1(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i3];
      return child_ctx;
    }
    function create_header_slot$1(ctx) {
      let div0;
      let div1;
      let t;
      let current;
      const select = new Select({
        props: {
          options: ctx[8],
          value: ctx[5].name,
          onChange: ctx[9]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div0 = element("div");
          div1 = element("div");
          t = space();
          create_component(select.$$.fragment);
          attr_dev(div1, "class", "stage__live svelte-1o77ihu");
          set_style(div1, "opacity", ctx[0].props.treshold.value < 1 ? 0 : 0);
          add_location(div1, file$h, 2, 8, 118);
          attr_dev(div0, "slot", "header");
          attr_dev(div0, "class", "stage__header svelte-1o77ihu");
          add_location(div0, file$h, 1, 4, 59);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, div1);
          append_dev(div0, t);
          mount_component(select, div0, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (!current || dirty[0] & 1) {
            set_style(div1, "opacity", ctx2[0].props.treshold.value < 1 ? 0 : 0);
          }
          const select_changes = {};
          if (dirty[0] & 32)
            select_changes.value = ctx2[5].name;
          select.$set(select_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div0);
          destroy_component(select);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_header_slot$1.name,
        type: "slot",
        source: '(2:4) <div slot=\\"header\\" class=\\"stage__header\\" style=\\"\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_3$1(ctx) {
      let current;
      const preview = new Preview({
        props: {
          renderer: ctx[0],
          stage: ctx[5],
          dpr: window.devicePixelRatio
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(preview.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(preview, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const preview_changes = {};
          if (dirty[0] & 1)
            preview_changes.renderer = ctx2[0];
          if (dirty[0] & 32)
            preview_changes.stage = ctx2[5];
          preview.$set(preview_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(preview.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(preview.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(preview, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: '(6:4) <Dropdown title=\\"Monitor\\">',
        ctx
      });
      return block;
    }
    function create_if_block$3(ctx) {
      let t;
      let each1_anchor;
      let current;
      let each_value_1 = Object.keys(ctx[6]);
      let each_blocks_1 = [];
      for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
        each_blocks_1[i3] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i3));
      }
      const out = (i3) => transition_out(each_blocks_1[i3], 1, 1, () => {
        each_blocks_1[i3] = null;
      });
      let each_value = Object.keys(ctx[7]);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block$2(get_each_context$2(ctx, each_value, i3));
      }
      const out_1 = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks_1.length; i3 += 1) {
            each_blocks_1[i3].c();
          }
          t = space();
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks_1.length; i3 += 1) {
            each_blocks_1[i3].m(target, anchor);
          }
          insert_dev(target, t, anchor);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 104) {
            each_value_1 = Object.keys(ctx2[6]);
            let i3;
            for (i3 = 0; i3 < each_value_1.length; i3 += 1) {
              const child_ctx = get_each_context_1$1(ctx2, each_value_1, i3);
              if (each_blocks_1[i3]) {
                each_blocks_1[i3].p(child_ctx, dirty);
                transition_in(each_blocks_1[i3], 1);
              } else {
                each_blocks_1[i3] = create_each_block_1$1(child_ctx);
                each_blocks_1[i3].c();
                transition_in(each_blocks_1[i3], 1);
                each_blocks_1[i3].m(t.parentNode, t);
              }
            }
            group_outros();
            for (i3 = each_value_1.length; i3 < each_blocks_1.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
          if (dirty[0] & 168) {
            each_value = Object.keys(ctx2[7]);
            let i3;
            for (i3 = 0; i3 < each_value.length; i3 += 1) {
              const child_ctx = get_each_context$2(ctx2, each_value, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block$2(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each1_anchor.parentNode, each1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
              out_1(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
            transition_in(each_blocks_1[i3]);
          }
          for (let i3 = 0; i3 < each_value.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks_1 = each_blocks_1.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks_1.length; i3 += 1) {
            transition_out(each_blocks_1[i3]);
          }
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks_1, detaching);
          if (detaching)
            detach_dev(t);
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(14:8) {#if stage !== null}",
        ctx
      });
      return block;
    }
    function create_each_block_2(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[6][ctx[18]][ctx[15]],
          name: ctx[15],
          url: `${ctx[5].name}/props/${ctx[15]}`,
          output: ctx[3]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 64)
            field_changes.prop = ctx2[6][ctx2[18]][ctx2[15]];
          if (dirty[0] & 64)
            field_changes.name = ctx2[15];
          if (dirty[0] & 96)
            field_changes.url = `${ctx2[5].name}/props/${ctx2[15]}`;
          if (dirty[0] & 8)
            field_changes.output = ctx2[3];
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(17:5) {#each Object.keys(folders[folderName]) as propKey}",
        ctx
      });
      return block;
    }
    function create_default_slot_2$1(ctx) {
      let each_1_anchor;
      let current;
      let each_value_2 = Object.keys(ctx[6][ctx[18]]);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value_2.length; i3 += 1) {
        each_blocks[i3] = create_each_block_2(get_each_context_2(ctx, each_value_2, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 104) {
            each_value_2 = Object.keys(ctx2[6][ctx2[18]]);
            let i3;
            for (i3 = 0; i3 < each_value_2.length; i3 += 1) {
              const child_ctx = get_each_context_2(ctx2, each_value_2, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block_2(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value_2.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value_2.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: "(16:4) <Dropdown title={folderName}>",
        ctx
      });
      return block;
    }
    function create_each_block_1$1(ctx) {
      let current;
      const dropdown = new Dropdown({
        props: {
          title: ctx[18],
          $$slots: {
            default: [create_default_slot_2$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown_changes = {};
          if (dirty[0] & 64)
            dropdown_changes.title = ctx2[18];
          if (dirty[0] & 8388712) {
            dropdown_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown.$set(dropdown_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$1.name,
        type: "each",
        source: "(15:3) {#each Object.keys(folders) as folderName}",
        ctx
      });
      return block;
    }
    function create_each_block$2(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[7][ctx[15]],
          name: ctx[15],
          url: `${ctx[5].name}/props/${ctx[15]}`,
          output: ctx[3]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 128)
            field_changes.prop = ctx2[7][ctx2[15]];
          if (dirty[0] & 128)
            field_changes.name = ctx2[15];
          if (dirty[0] & 160)
            field_changes.url = `${ctx2[5].name}/props/${ctx2[15]}`;
          if (dirty[0] & 8)
            field_changes.output = ctx2[3];
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$2.name,
        type: "each",
        source: "(22:12) {#each Object.keys(rest) as propKey}",
        ctx
      });
      return block;
    }
    function create_default_slot_1$1(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[5] !== null && create_if_block$3(ctx);
      const block = {
        c: function create() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[5] !== null) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block$3(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: '(13:4) <Dropdown title=\\"Parameters\\" url={`PanelStage${index}/${stage.name}/dropdown/settings`}>',
        ctx
      });
      return block;
    }
    function create_default_slot$2(ctx) {
      let t0;
      let t1;
      let current;
      const dropdown0 = new Dropdown({
        props: {
          title: "Monitor",
          $$slots: {
            default: [create_default_slot_3$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown1 = new Dropdown({
        props: {
          title: "Parameters",
          url: `PanelStage${ctx[4]}/${ctx[5].name}/dropdown/settings`,
          $$slots: {
            default: [create_default_slot_1$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          create_component(dropdown0.$$.fragment);
          t1 = space();
          create_component(dropdown1.$$.fragment);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(dropdown0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dropdown1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown0_changes = {};
          if (dirty[0] & 8388641) {
            dropdown0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown0.$set(dropdown0_changes);
          const dropdown1_changes = {};
          if (dirty[0] & 48)
            dropdown1_changes.url = `PanelStage${ctx2[4]}/${ctx2[5].name}/dropdown/settings`;
          if (dirty[0] & 8388840) {
            dropdown1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown1.$set(dropdown1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown0.$$.fragment, local);
          transition_in(dropdown1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown0.$$.fragment, local);
          transition_out(dropdown1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown0, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(dropdown1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$2.name,
        type: "slot",
        source: '(1:0) <Panel title={title} width={width} direction=\\"column\\">',
        ctx
      });
      return block;
    }
    function create_fragment$h(ctx) {
      let current;
      const panel = new Panel({
        props: {
          title: ctx[2],
          width: ctx[1],
          direction: "column",
          $$slots: {
            default: [create_default_slot$2],
            header: [create_header_slot$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(panel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel_changes = {};
          if (dirty[0] & 4)
            panel_changes.title = ctx2[2];
          if (dirty[0] & 2)
            panel_changes.width = ctx2[1];
          if (dirty[0] & 8388857) {
            panel_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel.$set(panel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$h.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$e($$self, $$props, $$invalidate) {
      let {renderer} = $$props;
      let {width} = $$props;
      let {title} = $$props;
      let {output} = $$props;
      let {index: index2} = $$props;
      let {stages} = $$props;
      let url2 = `PanelStage/${index2}`;
      let stageNames = Object.keys(stages);
      let list = stageNames.map((key) => ({
        key: stages[key].name,
        label: stages[key].name
      }));
      let count = list.length;
      let stageList = list.map((item) => item);
      let stage = count < 2 ? stages[stageNames[index2]] : stages[stageNames[index2 * 2]];
      let folders = {};
      let rest = {};
      Storage.rehydrate(url2, ({name}) => {
        for (let i3 = 0; i3 < list.length; i3++) {
          if (list[i3].label === name) {
            $$invalidate(5, stage = stages[list[i3].key]);
            break;
          }
        }
      });
      function handleStageChange({key}) {
        $$invalidate(5, stage = stages[key]);
      }
      const writable_props = ["renderer", "width", "title", "output", "index", "stages"];
      Object_1.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<PanelStage> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("title" in $$props2)
          $$invalidate(2, title = $$props2.title);
        if ("output" in $$props2)
          $$invalidate(3, output = $$props2.output);
        if ("index" in $$props2)
          $$invalidate(4, index2 = $$props2.index);
        if ("stages" in $$props2)
          $$invalidate(10, stages = $$props2.stages);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          width,
          title,
          output,
          index: index2,
          stages,
          url: url2,
          stageNames,
          list,
          count,
          stageList,
          stage,
          folders,
          rest
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("title" in $$props2)
          $$invalidate(2, title = $$props2.title);
        if ("output" in $$props2)
          $$invalidate(3, output = $$props2.output);
        if ("index" in $$props2)
          $$invalidate(4, index2 = $$props2.index);
        if ("stages" in $$props2)
          $$invalidate(10, stages = $$props2.stages);
        if ("url" in $$props2)
          $$invalidate(11, url2 = $$props2.url);
        if ("stageNames" in $$props2)
          stageNames = $$props2.stageNames;
        if ("list" in $$props2)
          $$invalidate(8, list = $$props2.list);
        if ("count" in $$props2)
          count = $$props2.count;
        if ("stageList" in $$props2)
          stageList = $$props2.stageList;
        if ("stage" in $$props2)
          $$invalidate(5, stage = $$props2.stage);
        if ("folders" in $$props2)
          $$invalidate(6, folders = $$props2.folders);
        if ("rest" in $$props2)
          $$invalidate(7, rest = $$props2.rest);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 49) {
          {
            if (!stage.instance) {
              let {name, props, scene} = stage;
              $$invalidate(5, stage.instance = new scene({
                name,
                props: stage.props,
                renderer
              }), stage);
            }
            currentStages.update((value2) => {
              let key = `stage${index2 + 1}`;
              return {
                ...value2,
                [`${key}`]: stage
              };
            });
            Storage.set(url2, JSON.stringify({
              name: stage.name
            }));
          }
        }
        if ($$self.$$.dirty[0] & 96) {
          {
            $$invalidate(6, folders = {});
            $$invalidate(7, rest = {});
            let keys2 = Object.keys(stage.props);
            for (let i3 = 0; i3 < keys2.length; i3++) {
              let key = keys2[i3];
              let {folder} = stage.props[key];
              if (folder) {
                if (!folders[`${folder}`]) {
                  $$invalidate(6, folders[`${folder}`] = {}, folders);
                }
                $$invalidate(6, folders[`${folder}`][`${key}`] = stage.props[key], folders);
              } else {
                $$invalidate(7, rest[`${key}`] = stage.props[key], rest);
              }
            }
          }
        }
      };
      return [renderer, width, title, output, index2, stage, folders, rest, list, handleStageChange, stages];
    }
    class PanelStage extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$e, create_fragment$h, safe_not_equal, {
          renderer: 0,
          width: 1,
          title: 2,
          output: 3,
          index: 4,
          stages: 10
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PanelStage",
          options,
          id: create_fragment$h.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("renderer" in props)) {
          console.warn("<PanelStage> was created without expected prop 'renderer'");
        }
        if (ctx[1] === void 0 && !("width" in props)) {
          console.warn("<PanelStage> was created without expected prop 'width'");
        }
        if (ctx[2] === void 0 && !("title" in props)) {
          console.warn("<PanelStage> was created without expected prop 'title'");
        }
        if (ctx[3] === void 0 && !("output" in props)) {
          console.warn("<PanelStage> was created without expected prop 'output'");
        }
        if (ctx[4] === void 0 && !("index" in props)) {
          console.warn("<PanelStage> was created without expected prop 'index'");
        }
        if (ctx[10] === void 0 && !("stages" in props)) {
          console.warn("<PanelStage> was created without expected prop 'stages'");
        }
      }
      get renderer() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get width() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get title() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set title(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get output() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set output(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get index() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set index(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get stages() {
        throw new Error("<PanelStage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stages(value2) {
        throw new Error("<PanelStage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$i = "src/ui/PreviewOutput.svelte";
    function create_fragment$i(ctx) {
      let div;
      let canvas_1;
      let div_style_value;
      let div_resize_listener;
      const block = {
        c: function create() {
          div = element("div");
          canvas_1 = element("canvas");
          attr_dev(canvas_1, "class", "svelte-xsix64");
          add_location(canvas_1, file$i, 1, 4, 86);
          attr_dev(div, "class", "output svelte-xsix64");
          attr_dev(div, "style", div_style_value = `height: ${ctx[2]}px`);
          add_render_callback(() => ctx[14].call(div));
          add_location(div, file$i, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, canvas_1);
          ctx[13](canvas_1);
          div_resize_listener = add_resize_listener(div, ctx[14].bind(div));
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 4 && div_style_value !== (div_style_value = `height: ${ctx2[2]}px`)) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          ctx[13](null);
          div_resize_listener.cancel();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$i.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$f($$self, $$props, $$invalidate) {
      let $rendererDimensions;
      let $currentStages;
      validate_store(rendererDimensions, "rendererDimensions");
      component_subscribe($$self, rendererDimensions, ($$value) => $$invalidate(10, $rendererDimensions = $$value));
      validate_store(currentStages, "currentStages");
      component_subscribe($$self, currentStages, ($$value) => $$invalidate(11, $currentStages = $$value));
      let {renderer} = $$props;
      let {dpr = renderer.dpr} = $$props;
      let canvas;
      let context;
      let offsetWidth;
      let rendererWidth = renderer.dimensions.width;
      let rendererHeight = renderer.dimensions.height;
      rendererDimensions.subscribe((value2) => {
        rendererWidth = value2.width;
        rendererHeight = value2.height;
      });
      onMount(() => {
        $$invalidate(0, canvas.width = canvasWidth, canvas);
        $$invalidate(0, canvas.height = canvasHeight, canvas);
        context = canvas.getContext("2d");
        on("afterframe", update2);
      });
      function update2({deltaTime: deltaTime2, time: time2, timeOffset: timeOffset2}) {
        if ($currentStages.stage1 && $currentStages.stage2) {
          renderer.render($currentStages.stage1, $currentStages.stage2, {
            deltaTime: deltaTime2,
            time: time2,
            timeOffset: timeOffset2
          });
        }
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(renderer.canvas, 0, 0, canvas.width, canvas.height);
      }
      const writable_props = ["renderer", "dpr"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<PreviewOutput> was created with unknown prop '${key}'`);
      });
      function canvas_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(0, canvas = $$value);
        });
      }
      function div_elementresize_handler() {
        offsetWidth = this.offsetWidth;
        $$invalidate(1, offsetWidth);
      }
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(3, renderer = $$props2.renderer);
        if ("dpr" in $$props2)
          $$invalidate(4, dpr = $$props2.dpr);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          dpr,
          canvas,
          context,
          offsetWidth,
          rendererWidth,
          rendererHeight,
          height,
          canvasWidth,
          canvasHeight,
          $rendererDimensions,
          $currentStages
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(3, renderer = $$props2.renderer);
        if ("dpr" in $$props2)
          $$invalidate(4, dpr = $$props2.dpr);
        if ("canvas" in $$props2)
          $$invalidate(0, canvas = $$props2.canvas);
        if ("context" in $$props2)
          context = $$props2.context;
        if ("offsetWidth" in $$props2)
          $$invalidate(1, offsetWidth = $$props2.offsetWidth);
        if ("rendererWidth" in $$props2)
          rendererWidth = $$props2.rendererWidth;
        if ("rendererHeight" in $$props2)
          rendererHeight = $$props2.rendererHeight;
        if ("height" in $$props2)
          $$invalidate(2, height = $$props2.height);
        if ("canvasWidth" in $$props2)
          $$invalidate(8, canvasWidth = $$props2.canvasWidth);
        if ("canvasHeight" in $$props2)
          $$invalidate(9, canvasHeight = $$props2.canvasHeight);
        if ("$rendererDimensions" in $$props2)
          rendererDimensions.set($rendererDimensions = $$props2.$rendererDimensions);
        if ("$currentStages" in $$props2)
          currentStages.set($currentStages = $$props2.$currentStages);
      };
      let height;
      let canvasWidth;
      let canvasHeight;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 2) {
          $$invalidate(2, height = window.innerHeight * offsetWidth / window.innerWidth);
        }
        if ($$self.$$.dirty[0] & 18) {
          $$invalidate(8, canvasWidth = offsetWidth * dpr);
        }
        if ($$self.$$.dirty[0] & 1042) {
          $$invalidate(9, canvasHeight = $rendererDimensions.height * offsetWidth / $rendererDimensions.width * dpr);
        }
        if ($$self.$$.dirty[0] & 769) {
          {
            if (canvas) {
              $$invalidate(0, canvas.width = canvasWidth, canvas);
              $$invalidate(0, canvas.height = canvasHeight, canvas);
              context = canvas.getContext("2d");
            }
          }
        }
      };
      return [canvas, offsetWidth, height, renderer, dpr, context, rendererWidth, rendererHeight, canvasWidth, canvasHeight, $rendererDimensions, $currentStages, update2, canvas_1_binding, div_elementresize_handler];
    }
    class PreviewOutput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$f, create_fragment$i, safe_not_equal, {
          renderer: 3,
          dpr: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PreviewOutput",
          options,
          id: create_fragment$i.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[3] === void 0 && !("renderer" in props)) {
          console.warn("<PreviewOutput> was created without expected prop 'renderer'");
        }
      }
      get renderer() {
        throw new Error("<PreviewOutput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<PreviewOutput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dpr() {
        throw new Error("<PreviewOutput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dpr(value2) {
        throw new Error("<PreviewOutput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const OutputWindow = function() {
      let object;
      let opened = false;
      let dimensions = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      let resizeFn;
      async function open(renderer) {
        object = window.open(`${window.location.href}?mode=output`, "Output", `width=${dimensions.width},height=${dimensions.height}`);
        opened = true;
        object.addEventListener("load", () => {
          console.log("output loaded");
        });
        object.addEventListener("resize", () => {
          dimensions.width = object.innerWidth;
          dimensions.height = object.innerHeight;
          if (resizeFn) {
            resizeFn({
              width: dimensions.width,
              height: dimensions.height
            });
          }
        });
      }
      function onResize(fn) {
        resizeFn = fn;
      }
      function setSize(width, height) {
        dimensions.width = width;
        dimensions.height = height;
        if (opened) {
          object.resizeTo(width, height);
        }
        if (resizeFn) {
          resizeFn({
            width: dimensions.width,
            height: dimensions.height
          });
        }
      }
      return {
        open,
        dimensions,
        onResize,
        setSize
      };
    }();
    const {Object: Object_1$1} = globals;
    const file$j = "src/ui/PanelOutput.svelte";
    function get_each_context$3(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[3] = list[i3];
      return child_ctx;
    }
    function create_default_slot_3$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Open");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$2.name,
        type: "slot",
        source: "(4:8) <Button onClick={handleClickOpenOutput}>",
        ctx
      });
      return block;
    }
    function create_header_slot$2(ctx) {
      let div0;
      let div1;
      let t;
      let current;
      const button = new Button({
        props: {
          onClick: ctx[2],
          $$slots: {
            default: [create_default_slot_3$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div0 = element("div");
          div1 = element("div");
          t = space();
          create_component(button.$$.fragment);
          add_location(div1, file$j, 2, 8, 88);
          attr_dev(div0, "slot", "header");
          add_location(div0, file$j, 1, 4, 60);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, div1);
          append_dev(div0, t);
          mount_component(button, div0, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 64) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div0);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_header_slot$2.name,
        type: "slot",
        source: '(2:4) <div slot=\\"header\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_2$2(ctx) {
      let current;
      const previewoutput = new PreviewOutput({
        props: {
          renderer: ctx[0],
          dpr: window.devicePixelRatio
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(previewoutput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(previewoutput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const previewoutput_changes = {};
          if (dirty[0] & 1)
            previewoutput_changes.renderer = ctx2[0];
          previewoutput.$set(previewoutput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(previewoutput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(previewoutput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(previewoutput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$2.name,
        type: "slot",
        source: '(6:4) <Dropdown title=\\"Monitor\\">',
        ctx
      });
      return block;
    }
    function create_each_block$3(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[0].props[ctx[3]],
          name: ctx[3],
          url: `Output/props/${ctx[3]}`
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 1)
            field_changes.prop = ctx2[0].props[ctx2[3]];
          if (dirty[0] & 1)
            field_changes.name = ctx2[3];
          if (dirty[0] & 1)
            field_changes.url = `Output/props/${ctx2[3]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$3.name,
        type: "each",
        source: "(10:8) {#each Object.keys(renderer.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_default_slot_1$2(ctx) {
      let each_1_anchor;
      let current;
      let each_value = Object.keys(ctx[0].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block$3(get_each_context$3(ctx, each_value, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1) {
            each_value = Object.keys(ctx2[0].props);
            let i3;
            for (i3 = 0; i3 < each_value.length; i3 += 1) {
              const child_ctx = get_each_context$3(ctx2, each_value, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block$3(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$2.name,
        type: "slot",
        source: '(9:4) <Dropdown title=\\"Settings\\">',
        ctx
      });
      return block;
    }
    function create_default_slot$3(ctx) {
      let t0;
      let t1;
      let current;
      const dropdown0 = new Dropdown({
        props: {
          title: "Monitor",
          $$slots: {
            default: [create_default_slot_2$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown1 = new Dropdown({
        props: {
          title: "Settings",
          $$slots: {
            default: [create_default_slot_1$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          create_component(dropdown0.$$.fragment);
          t1 = space();
          create_component(dropdown1.$$.fragment);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(dropdown0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dropdown1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown0_changes = {};
          if (dirty[0] & 65) {
            dropdown0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown0.$set(dropdown0_changes);
          const dropdown1_changes = {};
          if (dirty[0] & 65) {
            dropdown1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown1.$set(dropdown1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown0.$$.fragment, local);
          transition_in(dropdown1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown0.$$.fragment, local);
          transition_out(dropdown1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown0, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(dropdown1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$3.name,
        type: "slot",
        source: '(1:0) <Panel title=\\"Output\\" width={width} direction=\\"column\\">',
        ctx
      });
      return block;
    }
    function create_fragment$j(ctx) {
      let current;
      const panel = new Panel({
        props: {
          title: "Output",
          width: ctx[1],
          direction: "column",
          $$slots: {
            default: [create_default_slot$3],
            header: [create_header_slot$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(panel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel_changes = {};
          if (dirty[0] & 2)
            panel_changes.width = ctx2[1];
          if (dirty[0] & 65) {
            panel_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel.$set(panel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$j.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$g($$self, $$props, $$invalidate) {
      let {renderer} = $$props;
      let {width} = $$props;
      function handleClickOpenOutput() {
        OutputWindow.open(renderer);
      }
      const writable_props = ["renderer", "width"];
      Object_1$1.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<PanelOutput> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          width
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
      };
      return [renderer, width, handleClickOpenOutput];
    }
    class PanelOutput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$g, create_fragment$j, safe_not_equal, {
          renderer: 0,
          width: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PanelOutput",
          options,
          id: create_fragment$j.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("renderer" in props)) {
          console.warn("<PanelOutput> was created without expected prop 'renderer'");
        }
        if (ctx[1] === void 0 && !("width" in props)) {
          console.warn("<PanelOutput> was created without expected prop 'width'");
        }
      }
      get renderer() {
        throw new Error("<PanelOutput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<PanelOutput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get width() {
        throw new Error("<PanelOutput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<PanelOutput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const Microphone = function() {
      let stream;
      async function request({onSuccess = noop$1, onError = noop$1} = {}) {
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: false
          });
          onSuccess(stream);
        } catch (error) {
          console.error("Microphone: error while requesting access.");
          console.error(error);
          onError(error);
        }
      }
      function stop() {
        if (stream) {
          let tracks = stream.getTracks();
          for (let i3 = 0; i3 < tracks.length; i3++) {
            let track = tracks[i3];
            track.stop();
          }
        }
      }
      return {
        request,
        stop
      };
    }();
    const file$k = "src/ui/fields/FieldsAudio.svelte";
    function create_default_slot_4$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Prev");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: '(3:4) <Button style=\\"margin-left: 5px;\\" onClick={propInputPlaylist.handleClickPrev}>',
        ctx
      });
      return block;
    }
    function create_default_slot_3$3(ctx) {
      let t_value = ctx[1].labelPlay + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2 && t_value !== (t_value = ctx2[1].labelPlay + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$3.name,
        type: "slot",
        source: '(4:4) <Button style=\\"margin-left: 5px;\\" onClick={propInputPlaylist.handleClickPlay}>',
        ctx
      });
      return block;
    }
    function create_default_slot_2$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Next");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$3.name,
        type: "slot",
        source: '(5:4) <Button style=\\"margin-left: 5px;\\" onClick={propInputPlaylist.handleClickNext}>',
        ctx
      });
      return block;
    }
    function create_default_slot_1$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Load");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$3.name,
        type: "slot",
        source: '(6:4) <Button style=\\"margin-left: 5px;\\" onClick={propInputPlaylist.handleClickLoad}>',
        ctx
      });
      return block;
    }
    function create_default_slot$4(ctx) {
      let t0;
      let t1;
      let t2;
      let t3;
      let input;
      let current;
      let dispose;
      const button0 = new Button({
        props: {
          style: "margin-left: 5px;",
          onClick: ctx[1].handleClickPrev,
          $$slots: {
            default: [create_default_slot_4$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const button1 = new Button({
        props: {
          style: "margin-left: 5px;",
          onClick: ctx[1].handleClickPlay,
          $$slots: {
            default: [create_default_slot_3$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const button2 = new Button({
        props: {
          style: "margin-left: 5px;",
          onClick: ctx[1].handleClickNext,
          $$slots: {
            default: [create_default_slot_2$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const button3 = new Button({
        props: {
          style: "margin-left: 5px;",
          onClick: ctx[1].handleClickLoad,
          $$slots: {
            default: [create_default_slot_1$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button0.$$.fragment);
          t0 = space();
          create_component(button1.$$.fragment);
          t1 = space();
          create_component(button2.$$.fragment);
          t2 = space();
          create_component(button3.$$.fragment);
          t3 = space();
          input = element("input");
          attr_dev(input, "type", "file");
          attr_dev(input, "name", "load");
          set_style(input, "display", "none");
          attr_dev(input, "accept", "audio/mp3, audio/wav");
          add_location(input, file$k, 6, 4, 564);
          dispose = listen_dev(input, "change", function() {
            ctx[1].handleUpload.apply(this, arguments);
          }, false, false, false);
        },
        m: function mount(target, anchor) {
          mount_component(button0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(button1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(button2, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(button3, target, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, input, anchor);
          ctx[2](input);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          const button0_changes = {};
          if (dirty[0] & 2)
            button0_changes.onClick = ctx[1].handleClickPrev;
          if (dirty[0] & 16) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }
          button0.$set(button0_changes);
          const button1_changes = {};
          if (dirty[0] & 2)
            button1_changes.onClick = ctx[1].handleClickPlay;
          if (dirty[0] & 18) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }
          button1.$set(button1_changes);
          const button2_changes = {};
          if (dirty[0] & 2)
            button2_changes.onClick = ctx[1].handleClickNext;
          if (dirty[0] & 16) {
            button2_changes.$$scope = {
              dirty,
              ctx
            };
          }
          button2.$set(button2_changes);
          const button3_changes = {};
          if (dirty[0] & 2)
            button3_changes.onClick = ctx[1].handleClickLoad;
          if (dirty[0] & 16) {
            button3_changes.$$scope = {
              dirty,
              ctx
            };
          }
          button3.$set(button3_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(button2.$$.fragment, local);
          transition_in(button3.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(button2.$$.fragment, local);
          transition_out(button3.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(button1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(button2, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(button3, detaching);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(input);
          ctx[2](null);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(2:0) <Field prop={propInputPlaylist} name={propInputPlaylist.name} wrap={true}>",
        ctx
      });
      return block;
    }
    function create_fragment$k(ctx) {
      let t0;
      let t1;
      let t2;
      let t3;
      let t4;
      let current;
      const field0 = new Field({
        props: {
          prop: ctx[0],
          name: ctx[0].name,
          url: "Microphone"
        },
        $$inline: true
      });
      const field1 = new Field({
        props: {
          prop: ctx[1],
          name: ctx[1].name,
          wrap: true,
          $$slots: {
            default: [create_default_slot$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const field2 = new Field({
        props: {
          prop: {
            min: 0,
            max: 1,
            value: 0.5,
            step: 0.001,
            triggers: [Midi.knob(1)],
            onChange: ctx[3]
          },
          name: "volume"
        },
        $$inline: true
      });
      const field3 = new Field({
        props: {
          prop: {
            min: 0,
            max: 1000,
            value: 300,
            triggers: [Midi.knob(2)]
          },
          name: "hold"
        },
        $$inline: true
      });
      const field4 = new Field({
        props: {
          prop: {
            min: 0,
            max: 1,
            value: 0.992,
            triggers: [Midi.knob(3)]
          },
          name: "decay"
        },
        $$inline: true
      });
      const field5 = new Field({
        props: {
          prop: {
            min: 0,
            max: 1,
            value: 0.1,
            triggers: [Midi.knob(4)]
          },
          name: "min"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field0.$$.fragment);
          t0 = space();
          create_component(field1.$$.fragment);
          t1 = space();
          create_component(field2.$$.fragment);
          t2 = space();
          create_component(field3.$$.fragment);
          t3 = space();
          create_component(field4.$$.fragment);
          t4 = space();
          create_component(field5.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(field0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(field1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(field2, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(field3, target, anchor);
          insert_dev(target, t3, anchor);
          mount_component(field4, target, anchor);
          insert_dev(target, t4, anchor);
          mount_component(field5, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field0_changes = {};
          if (dirty[0] & 1)
            field0_changes.prop = ctx2[0];
          if (dirty[0] & 1)
            field0_changes.name = ctx2[0].name;
          field0.$set(field0_changes);
          const field1_changes = {};
          if (dirty[0] & 2)
            field1_changes.prop = ctx2[1];
          if (dirty[0] & 2)
            field1_changes.name = ctx2[1].name;
          if (dirty[0] & 18) {
            field1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          field1.$set(field1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field0.$$.fragment, local);
          transition_in(field1.$$.fragment, local);
          transition_in(field2.$$.fragment, local);
          transition_in(field3.$$.fragment, local);
          transition_in(field4.$$.fragment, local);
          transition_in(field5.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field0.$$.fragment, local);
          transition_out(field1.$$.fragment, local);
          transition_out(field2.$$.fragment, local);
          transition_out(field3.$$.fragment, local);
          transition_out(field4.$$.fragment, local);
          transition_out(field5.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(field1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(field2, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(field3, detaching);
          if (detaching)
            detach_dev(t3);
          destroy_component(field4, detaching);
          if (detaching)
            detach_dev(t4);
          destroy_component(field5, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$k.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$h($$self, $$props, $$invalidate) {
      let propInputMicro = {
        name: "microphone",
        type: "button",
        label: () => propInputMicro.value ? "Disable" : "Enable",
        value: false,
        onChange: () => {
          if (propInputMicro.value) {
            Microphone.request({
              onSuccess: (stream) => {
                Audio2.attachStream(stream);
              }
            });
          } else {
            Microphone.stop();
            Audio2.detachStream();
          }
        },
        onTrigger: () => {
          $$invalidate(0, propInputMicro.value = !propInputMicro.value, propInputMicro);
        }
      };
      let propInputPlaylist = {
        name: "playlist",
        type: "action-list",
        current: 0,
        value: [{
          value: "sun-models.mp3",
          src: "assets/sounds/sun-models.mp3"
        }],
        input: null,
        playing: false,
        labelPlay: "Play",
        onTrigger: ({value: value2}) => {
          console.log(value2);
        },
        handleClickPrev: () => {
          let {current, value: value2} = propInputPlaylist;
          $$invalidate(1, propInputPlaylist.current = current > 0 ? current - 1 : value2.length - 1, propInputPlaylist);
        },
        handleClickNext: () => {
          let {current, value: value2, playing} = propInputPlaylist;
          $$invalidate(1, propInputPlaylist.current = (current + 1) % value2.length, propInputPlaylist);
          if (playing) {
            propInputPlaylist.handleClickPlay();
          }
        },
        handleClickPlay: () => {
          $$invalidate(1, propInputPlaylist.playing = !propInputPlaylist.playing, propInputPlaylist);
          $$invalidate(1, propInputPlaylist.labelPlay = propInputPlaylist.playing ? "Pause" : "Play", propInputPlaylist);
          if (propInputPlaylist.playing) {
            let {value: value2, current} = propInputPlaylist;
            let filepath = value2[current].src;
            Audio2.play(filepath, {
              onEnd: () => {
                propInputPlaylist.handleClickNext();
              }
            });
          } else {
            Audio2.pause();
          }
        },
        handleUpload: (event2) => {
          let reader = new FileReader();
          let file2 = event2.target.files[0];
          reader.onload = (e) => {
            $$invalidate(1, propInputPlaylist.value = [...propInputPlaylist.value, {
              value: file2.name,
              src: e.target.result
            }], propInputPlaylist);
            Audio2.play(e.target.result, {
              onEnd: () => {
                propInputPlaylist.handleClickNext();
              }
            });
          };
          reader.readAsDataURL(file2);
        },
        handleClickLoad: () => {
          propInputPlaylist.input.click();
        }
      };
      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          propInputPlaylist.input = $$value;
          $$invalidate(1, propInputPlaylist);
        });
      }
      const func = ({value: value2}) => {
        Audio2.setGlobalVolume(value2);
      };
      $$self.$capture_state = () => {
        return {};
      };
      $$self.$inject_state = ($$props2) => {
        if ("propInputMicro" in $$props2)
          $$invalidate(0, propInputMicro = $$props2.propInputMicro);
        if ("propInputPlaylist" in $$props2)
          $$invalidate(1, propInputPlaylist = $$props2.propInputPlaylist);
      };
      return [propInputMicro, propInputPlaylist, input_binding, func];
    }
    class FieldsAudio extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$h, create_fragment$k, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FieldsAudio",
          options,
          id: create_fragment$k.name
        });
      }
    }
    const file$l = "src/ui/svg/IconRefresh.svelte";
    function create_fragment$l(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M9 12l-4.463 4.969-4.537-4.969h3c0-4.97 4.03-9 9-9 2.395 0 4.565.942 6.179 2.468l-2.004 2.231c-1.081-1.05-2.553-1.699-4.175-1.699-3.309 0-6 2.691-6 6h3zm10.463-4.969l-4.463 4.969h3c0 3.309-2.691 6-6 6-1.623 0-3.094-.65-4.175-1.699l-2.004 2.231c1.613 1.526 3.784 2.468 6.179 2.468 4.97 0 9-4.03 9-9h3l-4.537-4.969z");
          add_location(path, file$l, 0, 98, 98);
          attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg, "width", "24");
          attr_dev(svg, "height", "24");
          attr_dev(svg, "viewBox", "0 0 24 24");
          attr_dev(svg, "fill", "#f0f0f0");
          add_location(svg, file$l, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$l.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    class IconRefresh extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, null, create_fragment$l, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconRefresh",
          options,
          id: create_fragment$l.name
        });
      }
    }
    function create_default_slot_1$4(ctx) {
      let t;
      let current;
      const iconrefresh = new IconRefresh({
        $$inline: true
      });
      const block = {
        c: function create() {
          t = text("Refresh");
          create_component(iconrefresh.$$.fragment);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          mount_component(iconrefresh, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconrefresh.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconrefresh.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
          destroy_component(iconrefresh, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$4.name,
        type: "slot",
        source: "(2:4) <Button onClick={handleClickRefresh}>",
        ctx
      });
      return block;
    }
    function create_default_slot$5(ctx) {
      let current;
      const button = new Button({
        props: {
          onClick: ctx[2],
          $$slots: {
            default: [create_default_slot_1$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 8) {
            button_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$5.name,
        type: "slot",
        source: "(1:0) <Field prop={propMidiDevice} name={propMidiDevice.name}>",
        ctx
      });
      return block;
    }
    function create_fragment$m(ctx) {
      let t;
      let current;
      const field0 = new Field({
        props: {
          prop: ctx[0],
          name: ctx[0].name,
          $$slots: {
            default: [create_default_slot$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const field1 = new Field({
        props: {
          prop: ctx[1],
          name: ctx[1].name,
          disabled: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field0.$$.fragment);
          t = space();
          create_component(field1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(field0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(field1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field0_changes = {};
          if (dirty[0] & 1)
            field0_changes.prop = ctx2[0];
          if (dirty[0] & 1)
            field0_changes.name = ctx2[0].name;
          if (dirty[0] & 8) {
            field0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          field0.$set(field0_changes);
          const field1_changes = {};
          if (dirty[0] & 2)
            field1_changes.prop = ctx2[1];
          if (dirty[0] & 2)
            field1_changes.name = ctx2[1].name;
          field1.$set(field1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field0.$$.fragment, local);
          transition_in(field1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field0.$$.fragment, local);
          transition_out(field1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field0, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(field1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$m.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function createDevicesList() {
      if (Midi.inputs.length === 0) {
        return [{
          key: "none",
          label: "No device detected"
        }];
      } else {
        return [...Midi.inputs.map((input) => ({
          key: input.name,
          label: `${input.name}`
        }))];
      }
    }
    function instance$i($$self, $$props, $$invalidate) {
      let propMidiDevice = {
        name: "device",
        type: "select",
        input: null,
        options: createDevicesList(),
        onChange: ({key}) => {
        }
      };
      let propMidiMessages = {
        name: "messages",
        type: "list",
        value: []
      };
      function handleClickRefresh() {
        Midi.refresh();
        $$invalidate(0, propMidiDevice.value = createDevicesList(), propMidiDevice);
      }
      Midi.loadDevices(() => {
        $$invalidate(0, propMidiDevice.value = createDevicesList(), propMidiDevice);
        if (Midi.inputs.length > 0) {
          Midi.setInput(Midi.inputs[0]);
        }
      });
      Midi.noteon("*").onTrigger((e) => {
        let device = e.target.name;
        let note2 = e.note.name;
        let number = e.note.number;
        let octave = e.note.octave;
        let channel = e.channel;
        let event2 = `k(${number}) n(${note2}) o(${octave}) c(${channel}) from ${device}`;
        let messages = [...propMidiMessages.value];
        if (messages.length >= 4) {
          messages.splice(0, 1);
        }
        messages.push({
          value: event2
        });
        $$invalidate(1, propMidiMessages.value = messages, propMidiMessages);
      });
      $$self.$capture_state = () => {
        return {};
      };
      $$self.$inject_state = ($$props2) => {
        if ("propMidiDevice" in $$props2)
          $$invalidate(0, propMidiDevice = $$props2.propMidiDevice);
        if ("propMidiMessages" in $$props2)
          $$invalidate(1, propMidiMessages = $$props2.propMidiMessages);
      };
      return [propMidiDevice, propMidiMessages, handleClickRefresh];
    }
    class FieldsMidi extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$i, create_fragment$m, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FieldsMidi",
          options,
          id: create_fragment$m.name
        });
      }
    }
    function create_fragment$n(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[0],
          name: ctx[0].name,
          url: "Webcam"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 1)
            field_changes.prop = ctx2[0];
          if (dirty[0] & 1)
            field_changes.name = ctx2[0].name;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$n.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function enable() {
      Webcam.request({
        audio: false,
        onSuccess: () => {
        }
      });
    }
    function disable() {
      Webcam.stop();
    }
    function instance$j($$self, $$props, $$invalidate) {
      let propInputWebcam = {
        name: "webcam",
        type: "button",
        value: false,
        label: () => propInputWebcam.value ? "Disable" : "Enable",
        onChange: (prop) => {
          if (propInputWebcam.value) {
            enable();
          } else {
            disable();
          }
        },
        onTrigger: (prop) => {
          $$invalidate(0, propInputWebcam.value = !propInputWebcam.value, propInputWebcam);
          $$invalidate(0, propInputWebcam.label = propInputWebcam.value ? "Disable" : "Enable", propInputWebcam);
        }
      };
      $$self.$capture_state = () => {
        return {};
      };
      $$self.$inject_state = ($$props2) => {
        if ("propInputWebcam" in $$props2)
          $$invalidate(0, propInputWebcam = $$props2.propInputWebcam);
      };
      return [propInputWebcam];
    }
    class FieldsWebcam extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$j, create_fragment$n, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FieldsWebcam",
          options,
          id: create_fragment$n.name
        });
      }
    }
    function create_default_slot_1$5(ctx) {
      let t;
      let current;
      const field0 = new Field({
        props: {
          prop: ctx[1],
          name: "width",
          triggerable: false,
          url: "output/props/width"
        },
        $$inline: true
      });
      const field1 = new Field({
        props: {
          prop: ctx[2],
          name: "height",
          triggerable: false,
          url: "output/props/height"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field0.$$.fragment);
          t = space();
          create_component(field1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(field1, target, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current)
            return;
          transition_in(field0.$$.fragment, local);
          transition_in(field1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field0.$$.fragment, local);
          transition_out(field1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field0, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(field1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$5.name,
        type: "slot",
        source: '(2:4) <Dropdown title=\\"Dimensions\\" url=\\"OutputSettings/Dimensions/Dropdown\\">',
        ctx
      });
      return block;
    }
    function create_default_slot$6(ctx) {
      let current;
      const dropdown = new Dropdown({
        props: {
          title: "Dimensions",
          url: "OutputSettings/Dimensions/Dropdown",
          $$slots: {
            default: [create_default_slot_1$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown_changes = {};
          if (dirty[0] & 32) {
            dropdown_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown.$set(dropdown_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$6.name,
        type: "slot",
        source: '(1:0) <Panel width={width} title=\\"Output settings\\" direction=\\"column\\">',
        ctx
      });
      return block;
    }
    function create_fragment$o(ctx) {
      let current;
      const panel = new Panel({
        props: {
          width: ctx[0],
          title: "Output settings",
          direction: "column",
          $$slots: {
            default: [create_default_slot$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(panel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel_changes = {};
          if (dirty[0] & 1)
            panel_changes.width = ctx2[0];
          if (dirty[0] & 32) {
            panel_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel.$set(panel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$o.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$k($$self, $$props, $$invalidate) {
      let $rendererDimensions;
      validate_store(rendererDimensions, "rendererDimensions");
      component_subscribe($$self, rendererDimensions, ($$value) => $$invalidate(4, $rendererDimensions = $$value));
      let {width} = $$props;
      let {renderer} = $$props;
      let propWidth = {
        value: renderer.dimensions.width,
        step: 1,
        onChange: ({value: value2}) => {
          renderer.resize(value2, renderer.dimensions.height);
          set_store_value(rendererDimensions, $rendererDimensions.width = value2, $rendererDimensions);
        }
      };
      let propHeight = {
        value: renderer.dimensions.height,
        step: 1,
        onChange: ({value: value2}) => {
          renderer.resize(renderer.dimensions.width, value2);
          set_store_value(rendererDimensions, $rendererDimensions.height = value2, $rendererDimensions);
        }
      };
      const writable_props = ["width", "renderer"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<PanelOutputSettings> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("renderer" in $$props2)
          $$invalidate(3, renderer = $$props2.renderer);
      };
      $$self.$capture_state = () => {
        return {
          width,
          renderer,
          propWidth,
          propHeight,
          $rendererDimensions
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("renderer" in $$props2)
          $$invalidate(3, renderer = $$props2.renderer);
        if ("propWidth" in $$props2)
          $$invalidate(1, propWidth = $$props2.propWidth);
        if ("propHeight" in $$props2)
          $$invalidate(2, propHeight = $$props2.propHeight);
        if ("$rendererDimensions" in $$props2)
          rendererDimensions.set($rendererDimensions = $$props2.$rendererDimensions);
      };
      return [width, propWidth, propHeight, renderer];
    }
    class PanelOutputSettings extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$k, create_fragment$o, safe_not_equal, {
          width: 0,
          renderer: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PanelOutputSettings",
          options,
          id: create_fragment$o.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("width" in props)) {
          console.warn("<PanelOutputSettings> was created without expected prop 'width'");
        }
        if (ctx[3] === void 0 && !("renderer" in props)) {
          console.warn("<PanelOutputSettings> was created without expected prop 'renderer'");
        }
      }
      get width() {
        throw new Error("<PanelOutputSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<PanelOutputSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get renderer() {
        throw new Error("<PanelOutputSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<PanelOutputSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$m = "src/ui/Separator.svelte";
    function create_fragment$p(ctx) {
      let div;
      let div_style_value;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "separator svelte-18bshfm");
          attr_dev(div, "style", div_style_value = `width: ${ctx[0]}; height: ${ctx[1]};`);
          add_location(div, file$m, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 3 && div_style_value !== (div_style_value = `width: ${ctx2[0]}; height: ${ctx2[1]};`)) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$p.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$l($$self, $$props, $$invalidate) {
      let {width = "1px"} = $$props;
      let {height = "100%"} = $$props;
      const writable_props = ["width", "height"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Separator> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(1, height = $$props2.height);
      };
      $$self.$capture_state = () => {
        return {
          width,
          height
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(0, width = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(1, height = $$props2.height);
      };
      return [width, height];
    }
    class Separator extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$l, create_fragment$p, safe_not_equal, {
          width: 0,
          height: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Separator",
          options,
          id: create_fragment$p.name
        });
      }
      get width() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set width(value2) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get height() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set height(value2) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const {Object: Object_1$2} = globals;
    function create_default_slot_5$1(ctx) {
      let t0;
      let t1;
      let t2;
      let t3;
      let current;
      const panelstage0 = new PanelStage({
        props: {
          title: "Stage 1",
          stages: ctx[2],
          index: 0,
          width: "100%",
          renderer: ctx[0],
          output: ctx[1]
        },
        $$inline: true
      });
      const separator0 = new Separator({
        $$inline: true
      });
      const panelstage1 = new PanelStage({
        props: {
          title: "Stage 2",
          stages: ctx[2],
          index: 1,
          width: "100%",
          renderer: ctx[0],
          output: ctx[1]
        },
        $$inline: true
      });
      const separator1 = new Separator({
        $$inline: true
      });
      const paneloutput = new PanelOutput({
        props: {
          width: "100%",
          renderer: ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panelstage0.$$.fragment);
          t0 = space();
          create_component(separator0.$$.fragment);
          t1 = space();
          create_component(panelstage1.$$.fragment);
          t2 = space();
          create_component(separator1.$$.fragment);
          t3 = space();
          create_component(paneloutput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(panelstage0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(separator0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(panelstage1, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(separator1, target, anchor);
          insert_dev(target, t3, anchor);
          mount_component(paneloutput, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panelstage0_changes = {};
          if (dirty[0] & 1)
            panelstage0_changes.renderer = ctx2[0];
          if (dirty[0] & 2)
            panelstage0_changes.output = ctx2[1];
          panelstage0.$set(panelstage0_changes);
          const panelstage1_changes = {};
          if (dirty[0] & 1)
            panelstage1_changes.renderer = ctx2[0];
          if (dirty[0] & 2)
            panelstage1_changes.output = ctx2[1];
          panelstage1.$set(panelstage1_changes);
          const paneloutput_changes = {};
          if (dirty[0] & 1)
            paneloutput_changes.renderer = ctx2[0];
          paneloutput.$set(paneloutput_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panelstage0.$$.fragment, local);
          transition_in(separator0.$$.fragment, local);
          transition_in(panelstage1.$$.fragment, local);
          transition_in(separator1.$$.fragment, local);
          transition_in(paneloutput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panelstage0.$$.fragment, local);
          transition_out(separator0.$$.fragment, local);
          transition_out(panelstage1.$$.fragment, local);
          transition_out(separator1.$$.fragment, local);
          transition_out(paneloutput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panelstage0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(separator0, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(panelstage1, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(separator1, detaching);
          if (detaching)
            detach_dev(t3);
          destroy_component(paneloutput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: '(1:0) <Panel width=\\"100%\\" height=\\"72vh\\" direction=\\"row\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_4$2(ctx) {
      let current;
      const fieldsmidi = new FieldsMidi({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldsmidi.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldsmidi, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldsmidi.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldsmidi.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldsmidi, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$2.name,
        type: "slot",
        source: '(28:8) <Dropdown title=\\"Midi\\" url=\\"InputSettings/Midi/Dropdown\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_3$4(ctx) {
      let current;
      const fieldsaudio = new FieldsAudio({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldsaudio.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldsaudio, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldsaudio.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldsaudio.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldsaudio, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$4.name,
        type: "slot",
        source: '(31:8) <Dropdown title=\\"Audio\\" url=\\"InputSettings/Audio/Dropdown\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_2$4(ctx) {
      let current;
      const fieldswebcam = new FieldsWebcam({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldswebcam.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldswebcam, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldswebcam.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldswebcam.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldswebcam, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$4.name,
        type: "slot",
        source: '(34:8) <Dropdown title=\\"Video\\" url=\\"InputSettings/Video/Dropdown\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_1$6(ctx) {
      let t0;
      let t1;
      let current;
      const dropdown0 = new Dropdown({
        props: {
          title: "Midi",
          url: "InputSettings/Midi/Dropdown",
          $$slots: {
            default: [create_default_slot_4$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown1 = new Dropdown({
        props: {
          title: "Audio",
          url: "InputSettings/Audio/Dropdown",
          $$slots: {
            default: [create_default_slot_3$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown2 = new Dropdown({
        props: {
          title: "Video",
          url: "InputSettings/Video/Dropdown",
          $$slots: {
            default: [create_default_slot_2$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown0.$$.fragment);
          t0 = space();
          create_component(dropdown1.$$.fragment);
          t1 = space();
          create_component(dropdown2.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(dropdown1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dropdown2, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown0_changes = {};
          if (dirty[0] & 32) {
            dropdown0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown0.$set(dropdown0_changes);
          const dropdown1_changes = {};
          if (dirty[0] & 32) {
            dropdown1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown1.$set(dropdown1_changes);
          const dropdown2_changes = {};
          if (dirty[0] & 32) {
            dropdown2_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown2.$set(dropdown2_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown0.$$.fragment, local);
          transition_in(dropdown1.$$.fragment, local);
          transition_in(dropdown2.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown0.$$.fragment, local);
          transition_out(dropdown1.$$.fragment, local);
          transition_out(dropdown2.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(dropdown2, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$6.name,
        type: "slot",
        source: '(27:4) <Panel width=\\"50%\\" title=\\"Input Settings\\" direction=\\"column\\">',
        ctx
      });
      return block;
    }
    function create_default_slot$7(ctx) {
      let t0;
      let t1;
      let current;
      const panel = new Panel({
        props: {
          width: "50%",
          title: "Input Settings",
          direction: "column",
          $$slots: {
            default: [create_default_slot_1$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const separator = new Separator({
        $$inline: true
      });
      const paneloutputsettings = new PanelOutputSettings({
        props: {
          width: "50%",
          renderer: ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel.$$.fragment);
          t0 = space();
          create_component(separator.$$.fragment);
          t1 = space();
          create_component(paneloutputsettings.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(panel, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(separator, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(paneloutputsettings, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel_changes = {};
          if (dirty[0] & 32) {
            panel_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel.$set(panel_changes);
          const paneloutputsettings_changes = {};
          if (dirty[0] & 1)
            paneloutputsettings_changes.renderer = ctx2[0];
          paneloutputsettings.$set(paneloutputsettings_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel.$$.fragment, local);
          transition_in(separator.$$.fragment, local);
          transition_in(paneloutputsettings.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel.$$.fragment, local);
          transition_out(separator.$$.fragment, local);
          transition_out(paneloutputsettings.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(separator, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(paneloutputsettings, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$7.name,
        type: "slot",
        source: '(26:0) <Panel width=\\"100%\\" height=\\"calc(28vh - 1px)\\" direction=\\"row\\">',
        ctx
      });
      return block;
    }
    function create_fragment$q(ctx) {
      let t0;
      let t1;
      let current;
      const panel0 = new Panel({
        props: {
          width: "100%",
          height: "72vh",
          direction: "row",
          $$slots: {
            default: [create_default_slot_5$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const separator = new Separator({
        props: {
          height: "1px",
          width: "100%"
        },
        $$inline: true
      });
      const panel1 = new Panel({
        props: {
          width: "100%",
          height: "calc(28vh - 1px)",
          direction: "row",
          $$slots: {
            default: [create_default_slot$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel0.$$.fragment);
          t0 = space();
          create_component(separator.$$.fragment);
          t1 = space();
          create_component(panel1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(panel0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(separator, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(panel1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel0_changes = {};
          if (dirty[0] & 35) {
            panel0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel0.$set(panel0_changes);
          const panel1_changes = {};
          if (dirty[0] & 33) {
            panel1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel1.$set(panel1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel0.$$.fragment, local);
          transition_in(separator.$$.fragment, local);
          transition_in(panel1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel0.$$.fragment, local);
          transition_out(separator.$$.fragment, local);
          transition_out(panel1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(separator, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(panel1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$q.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$m($$self, $$props, $$invalidate) {
      let {renderer = {}} = $$props;
      let {stages = {}} = $$props;
      let {output} = $$props;
      let instanced = {};
      let allStages = Object.keys(stages).reduce((all, key) => {
        all[key] = stages[key];
        let cloneKey = `${stages[key].name} (Clone)`;
        all[cloneKey] = cloneDeep_1(stages[key], true);
        all[cloneKey].name = cloneKey;
        return all;
      }, {});
      rendererDimensions.subscribe((value2) => {
        Object.keys(allStages).forEach((key) => {
          let stage = allStages[key];
          if (stage.instance) {
            stage.instance.resize({
              width: value2.width,
              height: value2.height
            });
          }
        });
      });
      currentStages.subscribe((value2) => {
        let names = Object.keys(value2).map((key) => {
          if (value2[key])
            return value2[key].name;
          return null;
        });
        Storage.set("current", JSON.stringify(names));
      });
      const writable_props = ["renderer", "stages", "output"];
      Object_1$2.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Controller> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(3, stages = $$props2.stages);
        if ("output" in $$props2)
          $$invalidate(1, output = $$props2.output);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          stages,
          output,
          instanced,
          allStages
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(3, stages = $$props2.stages);
        if ("output" in $$props2)
          $$invalidate(1, output = $$props2.output);
        if ("instanced" in $$props2)
          instanced = $$props2.instanced;
        if ("allStages" in $$props2)
          $$invalidate(2, allStages = $$props2.allStages);
      };
      return [renderer, output, allStages, stages];
    }
    class Controller extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$m, create_fragment$q, safe_not_equal, {
          renderer: 0,
          stages: 3,
          output: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Controller",
          options,
          id: create_fragment$q.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[1] === void 0 && !("output" in props)) {
          console.warn("<Controller> was created without expected prop 'output'");
        }
      }
      get renderer() {
        throw new Error("<Controller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<Controller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get stages() {
        throw new Error("<Controller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stages(value2) {
        throw new Error("<Controller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get output() {
        throw new Error("<Controller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set output(value2) {
        throw new Error("<Controller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const {Object: Object_1$3} = globals;
    const file$n = "src/Output.svelte";
    function get_each_context$4(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i3];
      return child_ctx;
    }
    function get_each_context_1$2(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i3];
      return child_ctx;
    }
    function get_each_context_2$1(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i3];
      return child_ctx;
    }
    function create_if_block_1$1(ctx) {
      let each_1_anchor;
      let current;
      let each_value_2 = Object.keys(ctx[2].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value_2.length; i3 += 1) {
        each_blocks[i3] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 4) {
            each_value_2 = Object.keys(ctx2[2].props);
            let i3;
            for (i3 = 0; i3 < each_value_2.length; i3 += 1) {
              const child_ctx = get_each_context_2$1(ctx2, each_value_2, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block_2$1(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value_2.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value_2.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(4:8) {#if stage1 !== null}",
        ctx
      });
      return block;
    }
    function create_each_block_2$1(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[2].props[ctx[9]],
          name: ctx[9],
          url: `${ctx[2].name}/props/${ctx[9]}`,
          output: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 4)
            field_changes.prop = ctx2[2].props[ctx2[9]];
          if (dirty[0] & 4)
            field_changes.name = ctx2[9];
          if (dirty[0] & 4)
            field_changes.url = `${ctx2[2].name}/props/${ctx2[9]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$1.name,
        type: "each",
        source: "(5:12) {#each Object.keys(stage1.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_if_block$4(ctx) {
      let each_1_anchor;
      let current;
      let each_value_1 = Object.keys(ctx[3].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
        each_blocks[i3] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 8) {
            each_value_1 = Object.keys(ctx2[3].props);
            let i3;
            for (i3 = 0; i3 < each_value_1.length; i3 += 1) {
              const child_ctx = get_each_context_1$2(ctx2, each_value_1, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block_1$2(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value_1.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(9:8) {#if stage2 !== null}",
        ctx
      });
      return block;
    }
    function create_each_block_1$2(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[3].props[ctx[9]],
          name: ctx[9],
          url: `${ctx[3].name}/props/${ctx[9]}`,
          output: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 8)
            field_changes.prop = ctx2[3].props[ctx2[9]];
          if (dirty[0] & 8)
            field_changes.name = ctx2[9];
          if (dirty[0] & 8)
            field_changes.url = `${ctx2[3].name}/props/${ctx2[9]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$2.name,
        type: "each",
        source: "(10:12) {#each Object.keys(stage2.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_each_block$4(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[0].props[ctx[9]],
          name: ctx[9],
          url: `Output/props/${ctx[9]}`,
          output: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 1)
            field_changes.prop = ctx2[0].props[ctx2[9]];
          if (dirty[0] & 1)
            field_changes.name = ctx2[9];
          if (dirty[0] & 1)
            field_changes.url = `Output/props/${ctx2[9]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$4.name,
        type: "each",
        source: "(14:8) {#each Object.keys(renderer.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_fragment$r(ctx) {
      let div1;
      let div0;
      let t0;
      let t1;
      let current;
      let if_block0 = ctx[2] !== null && create_if_block_1$1(ctx);
      let if_block1 = ctx[3] !== null && create_if_block$4(ctx);
      let each_value = Object.keys(ctx[0].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block$4(get_each_context$4(ctx, each_value, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          if (if_block1)
            if_block1.c();
          t1 = space();
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          set_style(div0, "display", "none");
          add_location(div0, file$n, 2, 4, 46);
          attr_dev(div1, "class", "output svelte-1xe7470");
          add_location(div1, file$n, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          if (if_block0)
            if_block0.m(div0, null);
          append_dev(div0, t0);
          if (if_block1)
            if_block1.m(div0, null);
          append_dev(div0, t1);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(div0, null);
          }
          ctx[8](div1);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[2] !== null) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_1$1(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div0, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (ctx2[3] !== null) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block$4(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div0, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (dirty[0] & 1) {
            each_value = Object.keys(ctx2[0].props);
            let i3;
            for (i3 = 0; i3 < each_value.length; i3 += 1) {
              const child_ctx = get_each_context$4(ctx2, each_value, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block$4(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(div0, null);
              }
            }
            group_outros();
            for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          for (let i3 = 0; i3 < each_value.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
          destroy_each(each_blocks, detaching);
          ctx[8](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$r.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$n($$self, $$props, $$invalidate) {
      let {renderer} = $$props;
      let {stages} = $$props;
      let element2;
      let current = Storage.get("current");
      let stage1;
      let stage2;
      Storage.rehydrate("current", (current2) => {
        $$invalidate(2, stage1 = current2 && current2.length > 0 ? stages[current2[0]] : null);
        instanciate(stage1);
        $$invalidate(3, stage2 = current2 && current2.length > 1 ? stages[current2[1]] : null);
        instanciate(stage2);
      });
      function instanciate(stage) {
        if (stage) {
          let {name, props, scene} = stage;
          stage.instance = scene({
            name,
            props,
            renderer
          });
        }
      }
      onMount(() => {
        $$invalidate(0, renderer.canvas.style.width = "100%", renderer);
        $$invalidate(0, renderer.canvas.style.height = "auto", renderer);
        element2.appendChild(renderer.canvas);
        on("frame", update2);
      });
      function update2({deltaTime: deltaTime2, time: time2}) {
        if (stage1 && stage2) {
          renderer.render(stage1, stage2, {
            deltaTime: deltaTime2,
            time: time2
          });
        }
      }
      const writable_props = ["renderer", "stages"];
      Object_1$3.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<Output> was created with unknown prop '${key}'`);
      });
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(1, element2 = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(4, stages = $$props2.stages);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          stages,
          element: element2,
          current,
          stage1,
          stage2
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(4, stages = $$props2.stages);
        if ("element" in $$props2)
          $$invalidate(1, element2 = $$props2.element);
        if ("current" in $$props2)
          current = $$props2.current;
        if ("stage1" in $$props2)
          $$invalidate(2, stage1 = $$props2.stage1);
        if ("stage2" in $$props2)
          $$invalidate(3, stage2 = $$props2.stage2);
      };
      return [renderer, element2, stage1, stage2, stages, current, instanciate, update2, div1_binding];
    }
    class Output extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$n, create_fragment$r, safe_not_equal, {
          renderer: 0,
          stages: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Output",
          options,
          id: create_fragment$r.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("renderer" in props)) {
          console.warn("<Output> was created without expected prop 'renderer'");
        }
        if (ctx[4] === void 0 && !("stages" in props)) {
          console.warn("<Output> was created without expected prop 'stages'");
        }
      }
      get renderer() {
        throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get stages() {
        throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stages(value2) {
        throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const {Object: Object_1$4, console: console_1$2} = globals;
    const file$o = "src/Single.svelte";
    function get_each_context$5(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i3];
      return child_ctx;
    }
    function get_each_context_1$3(ctx, list, i3) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i3];
      return child_ctx;
    }
    function create_if_block$5(ctx) {
      let each_1_anchor;
      let current;
      let each_value_1 = Object.keys(ctx[2].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
        each_blocks[i3] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 4) {
            each_value_1 = Object.keys(ctx2[2].props);
            let i3;
            for (i3 = 0; i3 < each_value_1.length; i3 += 1) {
              const child_ctx = get_each_context_1$3(ctx2, each_value_1, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block_1$3(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value_1.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value_1.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(5:12) {#if stage !== null}",
        ctx
      });
      return block;
    }
    function create_each_block_1$3(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[2].props[ctx[9]],
          name: ctx[9],
          url: `${ctx[2].name}/props/${ctx[9]}`,
          output: false
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 4)
            field_changes.prop = ctx2[2].props[ctx2[9]];
          if (dirty[0] & 4)
            field_changes.name = ctx2[9];
          if (dirty[0] & 4)
            field_changes.url = `${ctx2[2].name}/props/${ctx2[9]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$3.name,
        type: "each",
        source: "(6:16) {#each Object.keys(stage.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_default_slot_8(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[2] !== null && create_if_block$5(ctx);
      const block = {
        c: function create() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[2] !== null) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block$5(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8.name,
        type: "slot",
        source: '(4:8) <Dropdown title=\\"Scene\\">',
        ctx
      });
      return block;
    }
    function create_each_block$5(ctx) {
      let current;
      const field = new Field({
        props: {
          prop: ctx[0].props[ctx[9]],
          name: ctx[9],
          url: `Output/props/${ctx[9]}`
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const field_changes = {};
          if (dirty[0] & 1)
            field_changes.prop = ctx2[0].props[ctx2[9]];
          if (dirty[0] & 1)
            field_changes.name = ctx2[9];
          if (dirty[0] & 1)
            field_changes.url = `Output/props/${ctx2[9]}`;
          field.$set(field_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$5.name,
        type: "each",
        source: "(12:12) {#each Object.keys(renderer.props) as propKey}",
        ctx
      });
      return block;
    }
    function create_default_slot_7$1(ctx) {
      let each_1_anchor;
      let current;
      let each_value = Object.keys(ctx[0].props);
      let each_blocks = [];
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        each_blocks[i3] = create_each_block$5(get_each_context$5(ctx, each_value, i3));
      }
      const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
        each_blocks[i3] = null;
      });
      const block = {
        c: function create() {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].c();
          }
          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            each_blocks[i3].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1) {
            each_value = Object.keys(ctx2[0].props);
            let i3;
            for (i3 = 0; i3 < each_value.length; i3 += 1) {
              const child_ctx = get_each_context$5(ctx2, each_value, i3);
              if (each_blocks[i3]) {
                each_blocks[i3].p(child_ctx, dirty);
                transition_in(each_blocks[i3], 1);
              } else {
                each_blocks[i3] = create_each_block$5(child_ctx);
                each_blocks[i3].c();
                transition_in(each_blocks[i3], 1);
                each_blocks[i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
              out(i3);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i3 = 0; i3 < each_value.length; i3 += 1) {
            transition_in(each_blocks[i3]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
            transition_out(each_blocks[i3]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7$1.name,
        type: "slot",
        source: '(11:8) <Dropdown title=\\"Renderer\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_6$1(ctx) {
      let current;
      const fieldsaudio = new FieldsAudio({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldsaudio.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldsaudio, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldsaudio.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldsaudio.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldsaudio, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$1.name,
        type: "slot",
        source: '(17:12) <Dropdown title=\\"Audio\\" opened={true}>',
        ctx
      });
      return block;
    }
    function create_default_slot_5$2(ctx) {
      let current;
      const fieldsmidi = new FieldsMidi({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldsmidi.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldsmidi, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldsmidi.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldsmidi.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldsmidi, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$2.name,
        type: "slot",
        source: '(20:12) <Dropdown title=\\"Midi\\" opened={false}>',
        ctx
      });
      return block;
    }
    function create_default_slot_4$3(ctx) {
      let current;
      const fieldswebcam = new FieldsWebcam({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(fieldswebcam.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(fieldswebcam, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(fieldswebcam.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(fieldswebcam.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(fieldswebcam, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$3.name,
        type: "slot",
        source: '(23:12) <Dropdown title=\\"Video\\" opened={false}>',
        ctx
      });
      return block;
    }
    function create_default_slot_3$5(ctx) {
      let t0;
      let t1;
      let current;
      const dropdown0 = new Dropdown({
        props: {
          title: "Audio",
          opened: true,
          $$slots: {
            default: [create_default_slot_6$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown1 = new Dropdown({
        props: {
          title: "Midi",
          opened: false,
          $$slots: {
            default: [create_default_slot_5$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown2 = new Dropdown({
        props: {
          title: "Video",
          opened: false,
          $$slots: {
            default: [create_default_slot_4$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dropdown0.$$.fragment);
          t0 = space();
          create_component(dropdown1.$$.fragment);
          t1 = space();
          create_component(dropdown2.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dropdown0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(dropdown1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dropdown2, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown0_changes = {};
          if (dirty[0] & 16384) {
            dropdown0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown0.$set(dropdown0_changes);
          const dropdown1_changes = {};
          if (dirty[0] & 16384) {
            dropdown1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown1.$set(dropdown1_changes);
          const dropdown2_changes = {};
          if (dirty[0] & 16384) {
            dropdown2_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown2.$set(dropdown2_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(dropdown0.$$.fragment, local);
          transition_in(dropdown1.$$.fragment, local);
          transition_in(dropdown2.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dropdown0.$$.fragment, local);
          transition_out(dropdown1.$$.fragment, local);
          transition_out(dropdown2.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dropdown0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(dropdown2, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$5.name,
        type: "slot",
        source: '(16:8) <Dropdown title=\\"Inputs\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_2$5(ctx) {
      let t0;
      let t1;
      let t2;
      let current;
      const field = new Field({
        props: {
          prop: ctx[3],
          name: "stage",
          triggerable: false,
          url: `Single/stage`
        },
        $$inline: true
      });
      const dropdown0 = new Dropdown({
        props: {
          title: "Scene",
          $$slots: {
            default: [create_default_slot_8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown1 = new Dropdown({
        props: {
          title: "Renderer",
          $$slots: {
            default: [create_default_slot_7$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const dropdown2 = new Dropdown({
        props: {
          title: "Inputs",
          $$slots: {
            default: [create_default_slot_3$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(field.$$.fragment);
          t0 = space();
          create_component(dropdown0.$$.fragment);
          t1 = space();
          create_component(dropdown1.$$.fragment);
          t2 = space();
          create_component(dropdown2.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(field, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(dropdown0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dropdown1, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(dropdown2, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const dropdown0_changes = {};
          if (dirty[0] & 16388) {
            dropdown0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown0.$set(dropdown0_changes);
          const dropdown1_changes = {};
          if (dirty[0] & 16385) {
            dropdown1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown1.$set(dropdown1_changes);
          const dropdown2_changes = {};
          if (dirty[0] & 16384) {
            dropdown2_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          dropdown2.$set(dropdown2_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(field.$$.fragment, local);
          transition_in(dropdown0.$$.fragment, local);
          transition_in(dropdown1.$$.fragment, local);
          transition_in(dropdown2.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(field.$$.fragment, local);
          transition_out(dropdown0.$$.fragment, local);
          transition_out(dropdown1.$$.fragment, local);
          transition_out(dropdown2.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(field, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(dropdown0, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(dropdown1, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(dropdown2, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$5.name,
        type: "slot",
        source: '(2:4) <Panel width=\\"30%\\" direction=\\"column\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_1$7(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "output svelte-1xe7470");
          add_location(div, file$o, 28, 8, 1128);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          ctx[8](div);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          ctx[8](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$7.name,
        type: "slot",
        source: '(28:4) <Panel width=\\"70%\\">',
        ctx
      });
      return block;
    }
    function create_default_slot$8(ctx) {
      let t0;
      let t1;
      let current;
      const panel0 = new Panel({
        props: {
          width: "30%",
          direction: "column",
          $$slots: {
            default: [create_default_slot_2$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const panel1 = new Panel({
        props: {
          width: "70%",
          $$slots: {
            default: [create_default_slot_1$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const separator = new Separator({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel0.$$.fragment);
          t0 = space();
          create_component(panel1.$$.fragment);
          t1 = space();
          create_component(separator.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(panel0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(panel1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(separator, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel0_changes = {};
          if (dirty[0] & 16389) {
            panel0_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel0.$set(panel0_changes);
          const panel1_changes = {};
          if (dirty[0] & 16386) {
            panel1_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel1.$set(panel1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel0.$$.fragment, local);
          transition_in(panel1.$$.fragment, local);
          transition_in(separator.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel0.$$.fragment, local);
          transition_out(panel1.$$.fragment, local);
          transition_out(separator.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(panel1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(separator, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$8.name,
        type: "slot",
        source: '(1:0) <Panel width=\\"100%\\">',
        ctx
      });
      return block;
    }
    function create_fragment$s(ctx) {
      let current;
      const panel = new Panel({
        props: {
          width: "100%",
          $$slots: {
            default: [create_default_slot$8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(panel.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(panel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const panel_changes = {};
          if (dirty[0] & 16391) {
            panel_changes.$$scope = {
              dirty,
              ctx: ctx2
            };
          }
          panel.$set(panel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(panel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(panel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(panel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$s.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$o($$self, $$props, $$invalidate) {
      let {stages} = $$props;
      let {renderer} = $$props;
      let output;
      let stageNames = Object.keys(stages);
      let list = stageNames.map((key) => ({
        key: stages[key].name,
        label: stages[key].name
      }));
      let stage = stages[stageNames[0]];
      console.log(stageNames, list);
      let propStage = {
        name: "stage",
        type: "select",
        value: stage.name,
        options: list,
        onChange: (value2) => {
          $$invalidate(2, stage = stages[propStage.value]);
        }
      };
      onMount(() => {
        $$invalidate(0, renderer.canvas.style.width = "100%", renderer);
        $$invalidate(0, renderer.canvas.style.height = "auto", renderer);
        output.appendChild(renderer.canvas);
        on("frame", update2);
      });
      function update2({deltaTime: deltaTime2, time: time2}) {
        renderer.render(stage, null, {
          deltaTime: deltaTime2,
          time: time2
        });
      }
      const writable_props = ["stages", "renderer"];
      Object_1$4.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console_1$2.warn(`<Single> was created with unknown prop '${key}'`);
      });
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(1, output = $$value);
        });
      }
      $$self.$set = ($$props2) => {
        if ("stages" in $$props2)
          $$invalidate(4, stages = $$props2.stages);
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
      };
      $$self.$capture_state = () => {
        return {
          stages,
          renderer,
          output,
          stageNames,
          list,
          stage,
          propStage
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("stages" in $$props2)
          $$invalidate(4, stages = $$props2.stages);
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("output" in $$props2)
          $$invalidate(1, output = $$props2.output);
        if ("stageNames" in $$props2)
          stageNames = $$props2.stageNames;
        if ("list" in $$props2)
          list = $$props2.list;
        if ("stage" in $$props2)
          $$invalidate(2, stage = $$props2.stage);
        if ("propStage" in $$props2)
          $$invalidate(3, propStage = $$props2.propStage);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 7) {
          {
            if (!stage.instance) {
              let {name, props, scene} = stage;
              $$invalidate(2, stage.instance = new scene({
                name,
                props,
                renderer
              }), stage);
            }
            if (typeof stage.instance.onMount === "function") {
              stage.instance.onMount({
                container: output,
                canvas: renderer.canvas
              });
            }
          }
        }
      };
      return [renderer, output, stage, propStage, stages, stageNames, list, update2, div_binding];
    }
    class Single extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$o, create_fragment$s, safe_not_equal, {
          stages: 4,
          renderer: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Single",
          options,
          id: create_fragment$s.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[4] === void 0 && !("stages" in props)) {
          console_1$2.warn("<Single> was created without expected prop 'stages'");
        }
        if (ctx[0] === void 0 && !("renderer" in props)) {
          console_1$2.warn("<Single> was created without expected prop 'renderer'");
        }
      }
      get stages() {
        throw new Error("<Single>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stages(value2) {
        throw new Error("<Single>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get renderer() {
        throw new Error("<Single>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<Single>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    const file$p = "src/App.svelte";
    function create_else_block$1(ctx) {
      let current;
      const controller = new Controller({
        props: {
          renderer: ctx[0],
          stages: ctx[1],
          output: ctx[2]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(controller.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(controller, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const controller_changes = {};
          if (dirty[0] & 1)
            controller_changes.renderer = ctx2[0];
          if (dirty[0] & 2)
            controller_changes.stages = ctx2[1];
          if (dirty[0] & 4)
            controller_changes.output = ctx2[2];
          controller.$set(controller_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(controller.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(controller.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(controller, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(12:1) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_1$2(ctx) {
      let current;
      const single_1 = new Single({
        props: {
          renderer: ctx[0],
          stages: ctx[1]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(single_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(single_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const single_1_changes = {};
          if (dirty[0] & 1)
            single_1_changes.renderer = ctx2[0];
          if (dirty[0] & 2)
            single_1_changes.stages = ctx2[1];
          single_1.$set(single_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(single_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(single_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(single_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$2.name,
        type: "if",
        source: "(7:18) ",
        ctx
      });
      return block;
    }
    function create_if_block$6(ctx) {
      let current;
      const output_1 = new Output({
        props: {
          renderer: ctx[0],
          stages: ctx[1]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(output_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(output_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const output_1_changes = {};
          if (dirty[0] & 1)
            output_1_changes.renderer = ctx2[0];
          if (dirty[0] & 2)
            output_1_changes.stages = ctx2[1];
          output_1.$set(output_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(output_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(output_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(output_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(2:1) {#if output}",
        ctx
      });
      return block;
    }
    function create_fragment$t(ctx) {
      let main;
      let current_block_type_index;
      let if_block;
      let current;
      const if_block_creators = [create_if_block$6, create_if_block_1$2, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[2])
          return 0;
        if (ctx2[3])
          return 1;
        return 2;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          main = element("main");
          if_block.c();
          attr_dev(main, "class", "svelte-1cy3hpj");
          add_location(main, file$p, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          if_blocks[current_block_type_index].m(main, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            }
            transition_in(if_block, 1);
            if_block.m(main, null);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(main);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$t.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$p($$self, $$props, $$invalidate) {
      let {renderer = {}} = $$props;
      let {stages = {}} = $$props;
      let {output = false} = $$props;
      let {single = false} = $$props;
      const writable_props = ["renderer", "stages", "output", "single"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
          console.warn(`<App> was created with unknown prop '${key}'`);
      });
      $$self.$set = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(1, stages = $$props2.stages);
        if ("output" in $$props2)
          $$invalidate(2, output = $$props2.output);
        if ("single" in $$props2)
          $$invalidate(3, single = $$props2.single);
      };
      $$self.$capture_state = () => {
        return {
          renderer,
          stages,
          output,
          single,
          dimensions
        };
      };
      $$self.$inject_state = ($$props2) => {
        if ("renderer" in $$props2)
          $$invalidate(0, renderer = $$props2.renderer);
        if ("stages" in $$props2)
          $$invalidate(1, stages = $$props2.stages);
        if ("output" in $$props2)
          $$invalidate(2, output = $$props2.output);
        if ("single" in $$props2)
          $$invalidate(3, single = $$props2.single);
        if ("dimensions" in $$props2)
          dimensions = $$props2.dimensions;
      };
      let dimensions;
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 1) {
          dimensions = renderer.dimensions;
        }
      };
      return [renderer, stages, output, single];
    }
    class App extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$p, create_fragment$t, safe_not_equal, {
          renderer: 0,
          stages: 1,
          output: 2,
          single: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "App",
          options,
          id: create_fragment$t.name
        });
      }
      get renderer() {
        throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set renderer(value2) {
        throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get stages() {
        throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set stages(value2) {
        throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get output() {
        throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set output(value2) {
        throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get single() {
        throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set single(value2) {
        throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    }
    function THREERenderer(THREE2, {width = window.innerWidth * 0.5, height = window.innerHeight * 0.5} = {}) {
      let dimensions = {
        width,
        height
      };
      let renderer = new THREE2.WebGLRenderer({
        antialias: true
      });
      renderer.setSize(width, height);
      let camera = new THREE2.Camera();
      let scene = new THREE2.Scene();
      let renderTarget0 = new THREE2.WebGLRenderTarget(width, height, {
        format: THREE2.RGBFormat,
        stencilBuffer: false,
        depthBuffer: true
      });
      let renderTarget1 = new THREE2.WebGLRenderTarget(width, height, {
        format: THREE2.RGBFormat,
        stencilBuffer: false,
        depthBuffer: true
      });
      let vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
      let uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
      let geometry = new THREE2.BufferGeometry();
      geometry.setAttribute("position", new THREE2.BufferAttribute(vertices, 2));
      geometry.setAttribute("uv", new THREE2.BufferAttribute(uvs, 2));
      let vertexShader6 = `
        precision highp float;

        attribute vec2 position;
        attribute vec2 uv;

        varying vec2 vUv;
        void main () {
            vUv = uv;
            gl_Position = vec4(position, 0, 1);
        }
    `;
      let fragmentFade = `
        precision highp float;

        uniform sampler2D tInput0;
        uniform sampler2D tInput1;
        uniform float uTreshold;

        varying vec2 vUv;

        void main() {
            vec4 texel0 = texture2D(tInput0, vUv);
            vec4 texel1 = texture2D(tInput1, vUv);
            
            gl_FragColor = mix(texel0, texel1, uTreshold);
            // gl_FragColor = vec4(0.0, 1., 1., 1.);
        }
    `;
      let fragmentSplit = `
        precision highp float;

        uniform sampler2D tInput0;
        uniform sampler2D tInput1;
        uniform float uTreshold;

        varying vec2 vUv;

        void main() {
            vec4 texel0 = texture2D(tInput0, vUv);
            vec4 texel1 = texture2D(tInput1, vUv);
            
            gl_FragColor = mix(texel0, texel1, step(vUv.x, uTreshold));
            // gl_FragColor = vec4(0.0, 1., 1., 1.);
        }
    `;
      let transitions = [{
        name: "Fade",
        key: "fade",
        fragment: fragmentFade
      }, {
        name: "Split V",
        key: "split",
        fragment: fragmentSplit
      }];
      let props = {
        treshold: {
          min: 0,
          max: 1,
          step: 0.001,
          value: 0,
          onChange: () => {
            uniforms.uTreshold.value = props.treshold.value;
          }
        },
        transition: {
          type: "select",
          options: transitions.map(({name, key}) => ({
            key,
            label: name
          })),
          onChange: ({key}) => {
            for (let i3 = 0; i3 < transitions.length; i3++) {
              if (transitions[i3].key === key) {
                const {fragment} = transitions[i3];
                mesh.material = new THREE2.RawShaderMaterial({
                  vertexShader: vertexShader6,
                  fragmentShader: fragment,
                  uniforms
                });
              }
            }
          }
        }
      };
      let uniforms = {
        tInput0: {
          value: renderTarget0.texture
        },
        tInput1: {
          value: renderTarget1.texture
        },
        uTreshold: {
          value: props.treshold.value
        }
      };
      let material2 = new THREE2.RawShaderMaterial({
        vertexShader: vertexShader6,
        fragmentShader: fragmentFade,
        uniforms
      });
      let mesh = new THREE2.Mesh(geometry, material2);
      scene.add(mesh);
      function resize({width: width2 = dimensions.widt, height: height2 = dimensions.height} = {}) {
        dimensions.width = width2;
        dimensions.height = height2;
        renderer.setSize(width2, height2);
      }
      function render(stage1, stage2, {deltaTime: deltaTime2, time: time2, timeOffset: timeOffset2}) {
        if (stage1 && stage1.instance) {
          stage1.instance.update({
            deltaTime: deltaTime2,
            time: time2
          });
          renderer.setRenderTarget(renderTarget0);
          stage1.instance.render({
            renderer
          });
        }
        if (stage2 && stage2.instance) {
          stage2.instance.update({
            deltaTime: deltaTime2,
            time: time2
          });
          renderer.setRenderTarget(renderTarget1);
          stage2.instance.render({
            renderer
          });
        }
        renderer.setRenderTarget(null);
        let tempTreshold = uniforms.uTreshold.value;
        uniforms.uTreshold.value = 0;
        renderer.render(scene, camera);
        if (stage1 && stage1.context) {
          stage1.context.clearRect(0, 0, width, height);
          stage1.context.drawImage(renderer.domElement, 0, 0);
        }
        uniforms.uTreshold.value = 1;
        renderer.render(scene, camera);
        if (stage2 && stage2.context) {
          stage2.context.clearRect(0, 0, width, height);
          stage2.context.drawImage(renderer.domElement, 0, 0);
        }
        uniforms.uTreshold.value = tempTreshold;
        renderer.render(scene, camera);
      }
      resize({
        width,
        height
      });
      return {
        renderer,
        canvas: renderer.domElement,
        resize,
        dimensions,
        render,
        props
      };
    }
    function parseParams(url2) {
      console.log(url2);
      let stringParams = `${decodeURI(url2).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"')}`;
      if (stringParams.length > 0) {
        stringParams = `{"${stringParams}"}`;
      } else {
        stringParams = `{}`;
      }
      let params2 = JSON.parse(stringParams);
      return params2;
    }
    const Time = function() {
      let state = {
        offset: 0,
        deltaTime: 0,
        time: 0,
        set
      };
      function set({time: time2, offset, delta}) {
        state.deltaTime = delta;
        state.offset = offset;
      }
      return state;
    }();
    let params = parseParams(window.location.search.substring(1));
    let timeOffset = 0;
    Storage.rehydrate("timeOffset", (value2) => {
      timeOffset = value2;
    });
    let time = timeOffset;
    let lastTime = performance.now();
    let deltaTime = 0;
    Time.set({
      time,
      offset: timeOffset,
      delta: deltaTime
    });
    function loop() {
      const now = performance.now();
      deltaTime = now - lastTime;
      time += deltaTime;
      lastTime = now;
      Time.set({
        time,
        offset: timeOffset,
        delta: deltaTime
      });
      emit("beforeframe", {
        time,
        deltaTime,
        timeOffset
      });
      emit("frame", {
        time,
        deltaTime,
        timeOffset
      });
      emit("afterframe", {
        time,
        deltaTime,
        timeOffset
      });
      Storage.set("timeOffset", time);
      requestAnimationFrame(loop);
    }
    loop();
    function Fragment({renderer, stages}) {
      return new App({
        target: document.body,
        props: {
          output: params.mode && params.mode === "output",
          single: params.mode && params.mode === "single",
          renderer,
          stages
        }
      });
    }
    const default2 = Fragment;

    // public/stages/Tampa/Uniforms.js
    const Uniforms8 = function() {
      let uniforms = {
        uTime: {
          value: 0
        },
        roomDiffuse: {
          value: new THREE.Color(16711680)
        }
      };
      function common3() {
        return uniforms;
      }
      function get(name) {
        return uniforms[name];
      }
      function update2({time: time2, deltaTime: deltaTime2}) {
        uniforms.uTime.value = time2 / 1000;
      }
      return {
        common: common3,
        update: update2,
        get
      };
    }();
    const default11 = Uniforms8;

    // public/stages/Tampa/Room.js
    let vertexShader5 = `
varying vec2 vUv;

void main() {
    vUv = uv;
    vec3 transformed = position;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);
}`;
    const fragmentShader5 = `
uniform vec3 roomDiffuse;

varying vec2 vUv;

#include <common>

void main() {
    vec3 color = roomDiffuse;

    float intensity = 0.2;
    color *= sin(vUv.y * PI) * intensity + (1. - intensity); // vertical gradient
    color *= sin(vUv.x * PI) * intensity + (1. - intensity);

    gl_FragColor = vec4(color, 1.0);
}
`;
    function Room7() {
      let transform = new THREE.Object3D();
      let geometry = new THREE.PlaneBufferGeometry(1, 1);
      let material2 = new THREE.ShaderMaterial({
        vertexShader: vertexShader5,
        fragmentShader: fragmentShader5,
        uniforms: {
          ...default11.common(),
          diffuse: {
            value: new THREE.Color(16777215)
          }
        }
      });
      let back = new THREE.Mesh(geometry, material2);
      back.position.z = -Room7.depth * 0.5;
      back.scale.set(Room7.width, Room7.height, 1);
      back.position.y = Room7.height * 0.5;
      transform.add(back);
      let front = new THREE.Mesh(geometry, material2);
      front.position.y = Room7.height * 0.5;
      front.position.z = Room7.depth * 0.5;
      front.scale.set(Room7.width, Room7.height, 1);
      front.rotation.y = Math.PI;
      transform.add(front);
      let left = new THREE.Mesh(geometry, material2);
      left.position.x = -Room7.width * 0.5;
      left.position.y = Room7.height * 0.5;
      left.rotation.y = Math.PI * 0.5;
      left.scale.set(Room7.depth, Room7.height, 1);
      transform.add(left);
      let right = new THREE.Mesh(geometry, material2);
      right.position.x = Room7.width * 0.5;
      right.position.y = Room7.height * 0.5;
      right.rotation.y = -Math.PI * 0.5;
      right.scale.set(Room7.depth, Room7.height, 1);
      transform.add(right);
      return {
        transform
      };
    }
    Room7.width = 10;
    Room7.depth = 10;
    Room7.height = 7;
    const default5 = Room7;

    // public/stages/Tampa/Hole.js
    let vertexShader3 = `
varying vec2 vUv;

void main() {
    vUv = uv;
    vec3 transformed = position;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);
}`;
    const fragmentShader3 = `
uniform vec3 diffuse;

varying vec2 vUv;

#include <common>

void main() {
    vec3 color = diffuse;
    color *= vUv.y; // vertical gradient

    float intensity = 0.2;
    color *= sin(vUv.x * PI) * intensity + (1. - intensity);

    gl_FragColor = vec4(color, 1.0);
}
`;
    function Hole4() {
      let transform = new THREE.Object3D();
      let geometry = new THREE.PlaneGeometry(Hole4.width, Hole4.height);
      geometry.translate(0, -Hole4.height * 0.5, 0);
      let material2 = new THREE.ShaderMaterial({
        vertexShader: vertexShader3,
        fragmentShader: fragmentShader3,
        uniforms: {
          ...default11.common(),
          diffuse: {
            value: new THREE.Color(16777215)
          }
        },
        side: THREE.BackSide
      });
      let meshFront = new THREE.Mesh(geometry, material2);
      meshFront.position.z = Hole4.depth * 0.5;
      transform.add(meshFront);
      let meshLeft = new THREE.Mesh(geometry, material2);
      meshLeft.position.x = -Hole4.width * 0.5;
      meshLeft.rotation.y = -Math.PI * 0.5;
      transform.add(meshLeft);
      let meshRight = new THREE.Mesh(geometry, material2);
      meshRight.position.x = Hole4.width * 0.5;
      meshRight.rotation.y = Math.PI * 0.5;
      transform.add(meshRight);
      let meshBack = new THREE.Mesh(geometry, material2);
      meshBack.position.z = -Hole4.depth * 0.5;
      meshBack.rotation.y = Math.PI;
      transform.add(meshBack);
      return {
        transform
      };
    }
    Hole4.width = default5.width * 0.2;
    Hole4.depth = default5.depth * 0.2;
    Hole4.height = default5.height * 0.75;
    const default6 = Hole4;

    // public/stages/Tampa/Floor.js
    let vertexShader2 = `
    varying vec2 vUv;

    void main() {
        vUv = uv;
        vec3 transformed = position;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);
    }`;
    let fragmentShader2 = `
    uniform vec3 roomDiffuse;
    uniform vec4 uvTransform;

    varying vec2 vUv;

    #include <common>

    float mapRange(float value, float low1, float high1, float low2, float high2) {
        return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
    }

    void main() {
        vec2 uv = vec2(
            mapRange(vUv.x, 0., 1., uvTransform.x, uvTransform.y),
            mapRange(vUv.y, 0., 1., uvTransform.z, uvTransform.w)
        );
        vec3 color = roomDiffuse;

        float intensity = 0.2;
        color *= sin(uv.y * PI) * intensity + (1. - intensity);
        color *= sin(uv.x * PI) * intensity + (1. - intensity);

        gl_FragColor = vec4(color, 1.0);
    }
`;
    function Floor3() {
      let transform = new THREE.Object3D();
      let widthBig = (default5.width - default6.width) * 0.5;
      let depthSmall = (default5.depth - default6.depth) * 0.5;
      let geometry = new THREE.PlaneBufferGeometry(1, 1);
      geometry.rotateX(-Math.PI * 0.5);
      let uniforms = {
        ...default11.common(),
        roomDiffuse: {
          value: new THREE.Color(16711680)
        },
        uvTransform: {
          value: new THREE.Vector4()
        }
      };
      let left = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2,
        uniforms: {
          ...default11.common(),
          uvTransform: {
            value: new THREE.Vector4(0, (default5.width - default6.width - (default5.width - default6.width) * 0.5) / default5.width, 0, 1)
          }
        }
      }));
      left.position.x = -widthBig * 0.5 - default6.width * 0.5;
      left.scale.set(widthBig, 1, default5.depth);
      transform.add(left);
      let right = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2,
        uniforms: {
          ...default11.common(),
          uvTransform: {
            value: new THREE.Vector4(((default5.width - default6.width) * 0.5 + default6.width) / default5.width, 1, 0, 1)
          }
        }
      }));
      right.position.x = widthBig * 0.5 + default6.width * 0.5;
      right.scale.copy(left.scale);
      transform.add(right);
      let back = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2,
        uniforms: {
          ...default11.common(),
          uvTransform: {
            value: new THREE.Vector4((default5.width - default6.width - (default5.width - default6.width) * 0.5) / default5.width, ((default5.width - default6.width) * 0.5 + default6.width) / default5.width, ((default5.depth - default6.depth) * 0.5 + default6.depth) / default5.depth, 1)
          }
        }
      }));
      back.scale.set(default6.width, 1, depthSmall);
      back.position.z = -depthSmall * 0.5 - default6.depth * 0.5;
      transform.add(back);
      let front = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2,
        uniforms: {
          ...default11.common(),
          uvTransform: {
            value: new THREE.Vector4((default5.width - default6.width - (default5.width - default6.width) * 0.5) / default5.width, ((default5.width - default6.width) * 0.5 + default6.width) / default5.width, 0, (default5.depth - default6.depth - (default5.depth - default6.depth) * 0.5) / default5.depth)
          }
        }
      }));
      front.scale.copy(back.scale);
      front.position.z = depthSmall * 0.5 + default6.depth * 0.5;
      transform.add(front);
      return {
        transform
      };
    }
    const default4 = Floor3;

    // public/stages/Tampa/Shape.js
    function Shape4() {
      let transform = new THREE.Object3D();
      let geometry = new THREE.BoxGeometry(default6.width, default6.width, default6.depth);
      let material2 = new THREE.MeshBasicMaterial({
        color: 16711935
      });
      let mesh = new THREE.Mesh(geometry, material2);
      mesh.position.y = -default6.width * 0.5;
      transform.add(mesh);
      return {
        transform
      };
    }
    const default7 = Shape4;

    // public/stages/Tampa/Ceiling.js
    let vertexShader = `
varying vec2 vUv;

void main() {
    vUv = uv;
    vec3 transformed = position;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);
}`;
    const fragmentShader = `
uniform vec3 diffuse;
uniform vec3 roomDiffuse;

varying vec2 vUv;

#include <common>

void main() {
    vec3 color = roomDiffuse;

    float intensity = 0.2;
    color *= sin(vUv.y * PI) * intensity + (1. - intensity); // vertical gradient
    color *= sin(vUv.x * PI) * intensity + (1. - intensity);

    gl_FragColor = vec4(color, 1.0);
}
`;
    function Ceiling3() {
      let transform = new THREE.Object3D();
      let geometry = new THREE.PlaneBufferGeometry(1, 1);
      geometry.rotateX(Math.PI * 0.5);
      let material2 = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          ...default11.common(),
          diffuse: {
            value: new THREE.Color(16777215)
          }
        }
      });
      let mesh = new THREE.Mesh(geometry, material2);
      mesh.scale.set(default5.width, 1, default5.depth);
      mesh.position.y = default5.height;
      transform.add(mesh);
      const LIGHT_COUNT = 4;
      const LIGHT_WIDTH = default5.width * 0.5;
      const LIGHT_DEPTH = default5.depth * 0.1;
      const LIGHT_SPACE = LIGHT_DEPTH * 2;
      let lightMaterial = new THREE.MeshBasicMaterial({
        color: 16777215
      });
      const LIGHT_LENGTH = LIGHT_COUNT * LIGHT_DEPTH + (LIGHT_COUNT - 1) * (LIGHT_SPACE - LIGHT_DEPTH);
      for (let i3 = 0; i3 < LIGHT_COUNT; i3++) {
        let light = new THREE.Mesh(geometry, lightMaterial);
        light.scale.set(LIGHT_WIDTH, 1, LIGHT_DEPTH);
        light.position.y = default5.height - 0.01;
        light.position.z = i3 * LIGHT_SPACE + LIGHT_DEPTH * 0.5 - LIGHT_LENGTH * 0.5;
        transform.add(light);
      }
      return {
        transform
      };
    }
    const default8 = Ceiling3;

    // public/stages/Tampa/Lights.js
    function Lights3() {
      let transform = new THREE.Object3D();
      let ambientLight = new THREE.AmbientLight(16777215, 0.5);
      transform.add(ambientLight);
      return {
        transform
      };
    }
    const default9 = Lights3;

    // public/stages/Tampa/Particles.js
    const random = require(0 /* canvas-sketch-util/random */, true /* ES6 import */);
    const vertexShader4 = `

attribute float size;
attribute float speed;
attribute vec3 customColor;

uniform float uTime;

varying vec3 vColor;

mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main() {
    vec3 transformed = position;
    transformed -= vec3(0., position.y, 0.);
    transformed = (rotationMatrix(vec3(0., 1., 0.), uTime * speed) * vec4(transformed, 1.)).xyz;
    transformed += vec3(0., position.y, 0.);

    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0 );

    gl_PointSize = size * ( 300.0 / -mvPosition.z );

    gl_Position = projectionMatrix * mvPosition;
}
`;
    const fragmentShader4 = `
uniform vec3 color;

void main() {
    gl_FragColor = vec4(color, 1.0);
}
`;
    function Particles3() {
      let transform = new THREE.Object3D();
      let geometry = new THREE.BufferGeometry();
      let positions = [];
      let sizes = [];
      let speeds = [];
      let count = 500;
      for (let i3 = 0; i3 < count; i3++) {
        let x = random.default.range(-default5.width * 0.5, default5.width * 0.5);
        let y2 = random.default.range(0, default5.height);
        let z = random.default.range(-default5.depth * 0.5, default5.depth * 0.5);
        positions.push(x, y2, z);
        sizes.push(Math.random() * 0.2);
        speeds.push(random.default.range(0.5, 1));
      }
      geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.setAttribute("size", new THREE.BufferAttribute(new Float32Array(sizes), 1));
      geometry.setAttribute("speed", new THREE.BufferAttribute(new Float32Array(speeds), 1));
      let material2 = new THREE.ShaderMaterial({
        vertexShader: vertexShader4,
        fragmentShader: fragmentShader4,
        uniforms: {
          ...default11.common(),
          color: {
            value: new THREE.Color(16777215)
          }
        }
      });
      let mesh = new THREE.Points(geometry, material2);
      transform.add(mesh);
      return {
        transform
      };
    }
    const default10 = Particles3;

    // node_modules/three/build/three.module.js
    if (Number.EPSILON === void 0) {
      Number.EPSILON = Math.pow(2, -52);
    }
    if (Number.isInteger === void 0) {
      Number.isInteger = function(value2) {
        return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
      };
    }
    if (Math.sign === void 0) {
      Math.sign = function(x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
      };
    }
    if ("name" in Function.prototype === false) {
      Object.defineProperty(Function.prototype, "name", {
        get: function() {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
      });
    }
    if (Object.assign === void 0) {
      Object.assign = function(target) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index2 = 1; index2 < arguments.length; index2++) {
          var source = arguments[index2];
          if (source !== void 0 && source !== null) {
            for (var nextKey in source) {
              if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    }
    var REVISION = "112";
    var MOUSE = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
    };
    var TOUCH = {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
    };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var VSMShadowMap = 3;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var ACESFilmicToneMapping = 5;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipmapNearestFilter = 1004;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipmapLinearFilter = 1005;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipmapNearestFilter = 1007;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipmapLinearFilter = 1008;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RedFormat = 1028;
    var RedIntegerFormat = 1029;
    var RGFormat = 1030;
    var RGIntegerFormat = 1031;
    var RGBIntegerFormat = 1032;
    var RGBAIntegerFormat = 1033;
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var TangentSpaceNormalMap = 0;
    var ObjectSpaceNormalMap = 1;
    var ZeroStencilOp = 0;
    var KeepStencilOp = 7680;
    var ReplaceStencilOp = 7681;
    var IncrementStencilOp = 7682;
    var DecrementStencilOp = 7683;
    var IncrementWrapStencilOp = 34055;
    var DecrementWrapStencilOp = 34056;
    var InvertStencilOp = 5386;
    var NeverStencilFunc = 512;
    var LessStencilFunc = 513;
    var EqualStencilFunc = 514;
    var LessEqualStencilFunc = 515;
    var GreaterStencilFunc = 516;
    var NotEqualStencilFunc = 517;
    var GreaterEqualStencilFunc = 518;
    var AlwaysStencilFunc = 519;
    var StaticDrawUsage = 35044;
    var DynamicDrawUsage = 35048;
    var StreamDrawUsage = 35040;
    var StaticReadUsage = 35045;
    var DynamicReadUsage = 35049;
    var StreamReadUsage = 35041;
    var StaticCopyUsage = 35046;
    var DynamicCopyUsage = 35050;
    var StreamCopyUsage = 35042;
    function EventDispatcher() {
    }
    Object.assign(EventDispatcher.prototype, {
      addEventListener: function(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === void 0)
          return false;
        var listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === void 0)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          var index2 = listenerArray.indexOf(listener);
          if (index2 !== -1) {
            listenerArray.splice(index2, 1);
          }
        }
      },
      dispatchEvent: function(event2) {
        if (this._listeners === void 0)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[event2.type];
        if (listenerArray !== void 0) {
          event2.target = this;
          var array = listenerArray.slice(0);
          for (var i3 = 0, l = array.length; i3 < l; i3++) {
            array[i3].call(this, event2);
          }
        }
      }
    });
    var _lut = [];
    for (var i = 0; i < 256; i++) {
      _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
    }
    var _Math = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function() {
        var d0 = Math.random() * 4294967295 | 0;
        var d1 = Math.random() * 4294967295 | 0;
        var d2 = Math.random() * 4294967295 | 0;
        var d3 = Math.random() * 4294967295 | 0;
        var uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      },
      clamp: function(value2, min, max) {
        return Math.max(min, Math.min(max, value2));
      },
      euclideanModulo: function(n, m2) {
        return (n % m2 + m2) % m2;
      },
      mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      lerp: function(x, y2, t) {
        return (1 - t) * x + t * y2;
      },
      smoothstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      degToRad: function(degrees) {
        return degrees * _Math.DEG2RAD;
      },
      radToDeg: function(radians) {
        return radians * _Math.RAD2DEG;
      },
      isPowerOfTwo: function(value2) {
        return (value2 & value2 - 1) === 0 && value2 !== 0;
      },
      ceilPowerOfTwo: function(value2) {
        return Math.pow(2, Math.ceil(Math.log(value2) / Math.LN2));
      },
      floorPowerOfTwo: function(value2) {
        return Math.pow(2, Math.floor(Math.log(value2) / Math.LN2));
      }
    };
    function Vector2(x, y2) {
      this.x = x || 0;
      this.y = y2 || 0;
    }
    Object.defineProperties(Vector2.prototype, {
      width: {
        get: function() {
          return this.x;
        },
        set: function(value2) {
          this.x = value2;
        }
      },
      height: {
        get: function() {
          return this.y;
        },
        set: function(value2) {
          this.y = value2;
        }
      }
    });
    Object.assign(Vector2.prototype, {
      isVector2: true,
      set: function(x, y2) {
        this.x = x;
        this.y = y2;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y2) {
        this.y = y2;
        return this;
      },
      setComponent: function(index2, value2) {
        switch (index2) {
          case 0:
            this.x = value2;
            break;
          case 1:
            this.y = value2;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      },
      getComponent: function(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index2);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w2);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s2) {
        this.x += s2;
        this.y += s2;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      addScaledVector: function(v, s2) {
        this.x += v.x * s2;
        this.y += v.y * s2;
        return this;
      },
      sub: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w2);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s2) {
        this.x -= s2;
        this.y -= s2;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      applyMatrix3: function(m2) {
        var x = this.x, y2 = this.y;
        var e = m2.elements;
        this.x = e[0] * x + e[3] * y2 + e[6];
        this.y = e[1] * x + e[4] * y2 + e[7];
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      },
      clampLength: function(min, max) {
        var length2 = this.length();
        return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      cross: function(v) {
        return this.x * v.y - this.y * v.x;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      angle: function() {
        var angle = Math.atan2(this.y, this.x);
        if (angle < 0)
          angle += 2 * Math.PI;
        return angle;
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      },
      setLength: function(length2) {
        return this.normalize().multiplyScalar(length2);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromBufferAttribute: function(attribute, index2, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        return this;
      },
      rotateAround: function(center, angle) {
        var c = Math.cos(angle), s2 = Math.sin(angle);
        var x = this.x - center.x;
        var y2 = this.y - center.y;
        this.x = x * c - y2 * s2 + center.x;
        this.y = x * s2 + y2 * c + center.y;
        return this;
      }
    });
    function Quaternion(x, y2, z, w2) {
      this._x = x || 0;
      this._y = y2 || 0;
      this._z = z || 0;
      this._w = w2 !== void 0 ? w2 : 1;
    }
    Object.assign(Quaternion, {
      slerp: function(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
      },
      slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          var s2 = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s2 = Math.sin(s2 * len) / sin;
            t = Math.sin(t * len) / sin;
          }
          var tDir = t * dir;
          x0 = x0 * s2 + x1 * tDir;
          y0 = y0 * s2 + y1 * tDir;
          z0 = z0 * s2 + z1 * tDir;
          w0 = w0 * s2 + w1 * tDir;
          if (s2 === 1 - t) {
            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
    });
    Object.defineProperties(Quaternion.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        set: function(value2) {
          this._x = value2;
          this._onChangeCallback();
        }
      },
      y: {
        get: function() {
          return this._y;
        },
        set: function(value2) {
          this._y = value2;
          this._onChangeCallback();
        }
      },
      z: {
        get: function() {
          return this._z;
        },
        set: function(value2) {
          this._z = value2;
          this._onChangeCallback();
        }
      },
      w: {
        get: function() {
          return this._w;
        },
        set: function(value2) {
          this._w = value2;
          this._onChangeCallback();
        }
      }
    });
    Object.assign(Quaternion.prototype, {
      isQuaternion: true,
      set: function(x, y2, z, w2) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._w = w2;
        this._onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update2) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        var x = euler._x, y2 = euler._y, z = euler._z, order = euler.order;
        var cos = Math.cos;
        var sin = Math.sin;
        var c1 = cos(x / 2);
        var c2 = cos(y2 / 2);
        var c3 = cos(z / 2);
        var s1 = sin(x / 2);
        var s2 = sin(y2 / 2);
        var s3 = sin(z / 2);
        if (order === "XYZ") {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "YXZ") {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === "ZXY") {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "ZYX") {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === "YZX") {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "XZY") {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update2 !== false)
          this._onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2, s2 = Math.sin(halfAngle);
        this._x = axis.x * s2;
        this._y = axis.y * s2;
        this._z = axis.z * s2;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m2) {
        var te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s2;
        if (trace > 0) {
          s2 = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s2;
          this._x = (m32 - m23) * s2;
          this._y = (m13 - m31) * s2;
          this._z = (m21 - m12) * s2;
        } else if (m11 > m22 && m11 > m33) {
          s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / s2;
          this._x = 0.25 * s2;
          this._y = (m12 + m21) / s2;
          this._z = (m13 + m31) / s2;
        } else if (m22 > m33) {
          s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / s2;
          this._x = (m12 + m21) / s2;
          this._y = 0.25 * s2;
          this._z = (m23 + m32) / s2;
        } else {
          s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / s2;
          this._x = (m13 + m31) / s2;
          this._y = (m23 + m32) / s2;
          this._z = 0.25 * s2;
        }
        this._onChangeCallback();
        return this;
      },
      setFromUnitVectors: function(vFrom, vTo) {
        var EPS = 1e-06;
        var r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
          r = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r;
        }
        return this.normalize();
      },
      angleTo: function(q) {
        return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
      },
      rotateTowards: function(q, step) {
        var angle = this.angleTo(q);
        if (angle === 0)
          return this;
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
      },
      inverse: function() {
        return this.conjugate();
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      premultiply: function(q) {
        return this.multiplyQuaternions(q, this);
      },
      multiplyQuaternions: function(a, b) {
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      },
      slerp: function(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x, y2 = this._y, z = this._z, w2 = this._w;
        var cosHalfTheta = w2 * qb._w + x * qb._x + y2 * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w2;
          this._x = x;
          this._y = y2;
          this._z = z;
          return this;
        }
        var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          var s2 = 1 - t;
          this._w = s2 * w2 + t * this._w;
          this._x = s2 * x + t * this._x;
          this._y = s2 * y2 + t * this._y;
          this._z = s2 * z + t * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w2 * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y2 * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
      },
      _onChangeCallback: function() {
      }
    });
    var _vector = new Vector3();
    var _quaternion = new Quaternion();
    function Vector3(x, y2, z) {
      this.x = x || 0;
      this.y = y2 || 0;
      this.z = z || 0;
    }
    Object.assign(Vector3.prototype, {
      isVector3: true,
      set: function(x, y2, z) {
        this.x = x;
        this.y = y2;
        this.z = z;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y2) {
        this.y = y2;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index2, value2) {
        switch (index2) {
          case 0:
            this.x = value2;
            break;
          case 1:
            this.y = value2;
            break;
          case 2:
            this.z = value2;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      },
      getComponent: function(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index2);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w2);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s2) {
        this.x += s2;
        this.y += s2;
        this.z += s2;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      addScaledVector: function(v, s2) {
        this.x += v.x * s2;
        this.y += v.y * s2;
        this.z += v.z * s2;
        return this;
      },
      sub: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w2);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s2) {
        this.x -= s2;
        this.y -= s2;
        this.z -= s2;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v, w2);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion.setFromEuler(euler));
      },
      applyAxisAngle: function(axis, angle) {
        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
      },
      applyMatrix3: function(m2) {
        var x = this.x, y2 = this.y, z = this.z;
        var e = m2.elements;
        this.x = e[0] * x + e[3] * y2 + e[6] * z;
        this.y = e[1] * x + e[4] * y2 + e[7] * z;
        this.z = e[2] * x + e[5] * y2 + e[8] * z;
        return this;
      },
      applyNormalMatrix: function(m2) {
        return this.applyMatrix3(m2).normalize();
      },
      applyMatrix4: function(m2) {
        var x = this.x, y2 = this.y, z = this.z;
        var e = m2.elements;
        var w2 = 1 / (e[3] * x + e[7] * y2 + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y2 + e[8] * z + e[12]) * w2;
        this.y = (e[1] * x + e[5] * y2 + e[9] * z + e[13]) * w2;
        this.z = (e[2] * x + e[6] * y2 + e[10] * z + e[14]) * w2;
        return this;
      },
      applyQuaternion: function(q) {
        var x = this.x, y2 = this.y, z = this.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        var ix = qw * x + qy * z - qz * y2;
        var iy = qw * y2 + qz * x - qx * z;
        var iz = qw * z + qx * y2 - qy * x;
        var iw = -qx * x - qy * y2 - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      },
      unproject: function(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      },
      transformDirection: function(m2) {
        var x = this.x, y2 = this.y, z = this.z;
        var e = m2.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z;
        this.y = e[1] * x + e[5] * y2 + e[9] * z;
        this.z = e[2] * x + e[6] * y2 + e[10] * z;
        return this.normalize();
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      },
      clampLength: function(min, max) {
        var length2 = this.length();
        return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function(length2) {
        return this.normalize().multiplyScalar(length2);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      },
      cross: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v, w2);
        }
        return this.crossVectors(this, v);
      },
      crossVectors: function(a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function(v) {
        var scalar = v.dot(this) / v.lengthSq();
        return this.copy(v).multiplyScalar(scalar);
      },
      projectOnPlane: function(planeNormal) {
        _vector.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector);
      },
      reflect: function(normal) {
        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
      },
      angleTo: function(v) {
        var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0)
          console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
        var theta = this.dot(v) / denominator;
        return Math.acos(_Math.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      },
      setFromSpherical: function(s2) {
        return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
      },
      setFromSphericalCoords: function(radius, phi, theta) {
        var sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      },
      setFromCylindrical: function(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      },
      setFromCylindricalCoords: function(radius, theta, y2) {
        this.x = radius * Math.sin(theta);
        this.y = y2;
        this.z = radius * Math.cos(theta);
        return this;
      },
      setFromMatrixPosition: function(m2) {
        var e = m2.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      },
      setFromMatrixScale: function(m2) {
        var sx = this.setFromMatrixColumn(m2, 0).length();
        var sy = this.setFromMatrixColumn(m2, 1).length();
        var sz = this.setFromMatrixColumn(m2, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(m2, index2) {
        return this.fromArray(m2.elements, index2 * 4);
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromBufferAttribute: function(attribute, index2, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        this.z = attribute.getZ(index2);
        return this;
      }
    });
    var _vector$1 = new Vector3();
    function Matrix3() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    Object.assign(Matrix3.prototype, {
      isMatrix3: true,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function(m2) {
        var te = this.elements;
        var me = m2.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      },
      setFromMatrix4: function(m2) {
        var me = m2.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      },
      applyToBufferAttribute: function(attribute) {
        for (var i3 = 0, l = attribute.count; i3 < l; i3++) {
          _vector$1.x = attribute.getX(i3);
          _vector$1.y = attribute.getY(i3);
          _vector$1.z = attribute.getZ(i3);
          _vector$1.applyMatrix3(this);
          attribute.setXYZ(i3, _vector$1.x, _vector$1.y, _vector$1.z);
        }
        return attribute;
      },
      multiply: function(m2) {
        return this.multiplyMatrices(this, m2);
      },
      premultiply: function(m2) {
        return this.multiplyMatrices(m2, this);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[3], a13 = ae[6];
        var a21 = ae[1], a22 = ae[4], a23 = ae[7];
        var a31 = ae[2], a32 = ae[5], a33 = ae[8];
        var b11 = be[0], b12 = be[3], b13 = be[6];
        var b21 = be[1], b22 = be[4], b23 = be[7];
        var b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      },
      multiplyScalar: function(s2) {
        var te = this.elements;
        te[0] *= s2;
        te[3] *= s2;
        te[6] *= s2;
        te[1] *= s2;
        te[4] *= s2;
        te[7] *= s2;
        te[2] *= s2;
        te[5] *= s2;
        te[8] *= s2;
        return this;
      },
      determinant: function() {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d2 = te[3], e = te[4], f = te[5], g = te[6], h2 = te[7], i3 = te[8];
        return a * e * i3 - a * f * h2 - b * d2 * i3 + b * f * g + c * d2 * h2 - c * e * g;
      },
      getInverse: function(matrix, throwOnDegenerate) {
        if (matrix && matrix.isMatrix4) {
          console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
        }
        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
          var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      },
      transpose: function() {
        var tmp2, m2 = this.elements;
        tmp2 = m2[1];
        m2[1] = m2[3];
        m2[3] = tmp2;
        tmp2 = m2[2];
        m2[2] = m2[6];
        m2[6] = tmp2;
        tmp2 = m2[5];
        m2[5] = m2[7];
        m2[7] = tmp2;
        return this;
      },
      getNormalMatrix: function(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
      },
      transposeIntoArray: function(r) {
        var m2 = this.elements;
        r[0] = m2[0];
        r[1] = m2[3];
        r[2] = m2[6];
        r[3] = m2[1];
        r[4] = m2[4];
        r[5] = m2[7];
        r[6] = m2[2];
        r[7] = m2[5];
        r[8] = m2[8];
        return this;
      },
      setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
        var c = Math.cos(rotation);
        var s2 = Math.sin(rotation);
        this.set(sx * c, sx * s2, -sx * (c * cx + s2 * cy) + cx + tx, -sy * s2, sy * c, -sy * (-s2 * cx + c * cy) + cy + ty, 0, 0, 1);
      },
      scale: function(sx, sy) {
        var te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      },
      rotate: function(theta) {
        var c = Math.cos(theta);
        var s2 = Math.sin(theta);
        var te = this.elements;
        var a11 = te[0], a12 = te[3], a13 = te[6];
        var a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s2 * a21;
        te[3] = c * a12 + s2 * a22;
        te[6] = c * a13 + s2 * a23;
        te[1] = -s2 * a11 + c * a21;
        te[4] = -s2 * a12 + c * a22;
        te[7] = -s2 * a13 + c * a23;
        return this;
      },
      translate: function(tx, ty) {
        var te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      },
      equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i3 = 0; i3 < 9; i3++) {
          if (te[i3] !== me[i3])
            return false;
        }
        return true;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        for (var i3 = 0; i3 < 9; i3++) {
          this.elements[i3] = array[i3 + offset];
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      }
    });
    var _canvas;
    var ImageUtils = {
      getDataURL: function(image) {
        var canvas;
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        } else if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0)
            _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          var context = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
    };
    var textureId = 0;
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      Object.defineProperty(this, "id", {
        value: textureId++
      });
      this.uuid = _Math.generateUUID();
      this.name = "";
      this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
      this.mipmaps = [];
      this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
      this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
      this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
      this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : LinearMipmapLinearFilter;
      this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
      this.format = format !== void 0 ? format : RGBAFormat;
      this.internalFormat = null;
      this.type = type !== void 0 ? type : UnsignedByteType;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
      this.version = 0;
      this.onUpdate = null;
    }
    Texture.DEFAULT_IMAGE = void 0;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Texture,
      isTexture: true,
      updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
      },
      toJSON: function(meta) {
        var isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        var output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (this.image !== void 0) {
          var image = this.image;
          if (image.uuid === void 0) {
            image.uuid = _Math.generateUUID();
          }
          if (!isRootObject && meta.images[image.uuid] === void 0) {
            var url2;
            if (Array.isArray(image)) {
              url2 = [];
              for (var i3 = 0, l = image.length; i3 < l; i3++) {
                url2.push(ImageUtils.getDataURL(image[i3]));
              }
            } else {
              url2 = ImageUtils.getDataURL(image);
            }
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url: url2
            };
          }
          output.image = image.uuid;
        }
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      },
      transformUv: function(uv) {
        if (this.mapping !== UVMapping)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
    });
    Object.defineProperty(Texture.prototype, "needsUpdate", {
      set: function(value2) {
        if (value2 === true)
          this.version++;
      }
    });
    function Vector4(x, y2, z, w2) {
      this.x = x || 0;
      this.y = y2 || 0;
      this.z = z || 0;
      this.w = w2 !== void 0 ? w2 : 1;
    }
    Object.defineProperties(Vector4.prototype, {
      width: {
        get: function() {
          return this.z;
        },
        set: function(value2) {
          this.z = value2;
        }
      },
      height: {
        get: function() {
          return this.w;
        },
        set: function(value2) {
          this.w = value2;
        }
      }
    });
    Object.assign(Vector4.prototype, {
      isVector4: true,
      set: function(x, y2, z, w2) {
        this.x = x;
        this.y = y2;
        this.z = z;
        this.w = w2;
        return this;
      },
      setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y2) {
        this.y = y2;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w2) {
        this.w = w2;
        return this;
      },
      setComponent: function(index2, value2) {
        switch (index2) {
          case 0:
            this.x = value2;
            break;
          case 1:
            this.y = value2;
            break;
          case 2:
            this.z = value2;
            break;
          case 3:
            this.w = value2;
            break;
          default:
            throw new Error("index is out of range: " + index2);
        }
        return this;
      },
      getComponent: function(index2) {
        switch (index2) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index2);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== void 0 ? v.w : 1;
        return this;
      },
      add: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w2);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s2) {
        this.x += s2;
        this.y += s2;
        this.z += s2;
        this.w += s2;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      addScaledVector: function(v, s2) {
        this.x += v.x * s2;
        this.y += v.y * s2;
        this.z += v.z * s2;
        this.w += v.w * s2;
        return this;
      },
      sub: function(v, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w2);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s2) {
        this.x -= s2;
        this.y -= s2;
        this.z -= s2;
        this.w -= s2;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      },
      applyMatrix4: function(m2) {
        var x = this.x, y2 = this.y, z = this.z, w2 = this.w;
        var e = m2.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z + e[12] * w2;
        this.y = e[1] * x + e[5] * y2 + e[9] * z + e[13] * w2;
        this.z = e[2] * x + e[6] * y2 + e[10] * z + e[14] * w2;
        this.w = e[3] * x + e[7] * y2 + e[11] * z + e[15] * w2;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s2 = Math.sqrt(1 - q.w * q.w);
        if (s2 < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s2;
          this.y = q.y / s2;
          this.z = q.z / s2;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m2) {
        var angle, x, y2, z, epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x = 0;
              y2 = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y2 = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y2 = 0;
              z = 0.707106781;
            } else {
              y2 = Math.sqrt(yy);
              x = xy / y2;
              z = yz / y2;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y2 = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y2 = yz / z;
            }
          }
          this.set(x, y2, z, angle);
          return this;
        }
        var s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s2) < 0.001)
          s2 = 1;
        this.x = (m32 - m23) / s2;
        this.y = (m13 - m31) / s2;
        this.z = (m21 - m12) / s2;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      },
      clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      },
      clampLength: function(min, max) {
        var length2 = this.length();
        return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function(length2) {
        return this.normalize().multiplyScalar(length2);
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      },
      equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromBufferAttribute: function(attribute, index2, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index2);
        this.y = attribute.getY(index2);
        this.z = attribute.getZ(index2);
        this.w = attribute.getW(index2);
        return this;
      }
    });
    function WebGLRenderTarget(width, height, options) {
      this.width = width;
      this.height = height;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      options = options || {};
      this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.image = {};
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
      this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
    }
    WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: WebGLRenderTarget,
      isWebGLRenderTarget: true,
      setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.texture.image.width = width;
          this.texture.image.height = height;
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    function WebGLMultisampleRenderTarget(width, height, options) {
      WebGLRenderTarget.call(this, width, height, options);
      this.samples = 4;
    }
    WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
      constructor: WebGLMultisampleRenderTarget,
      isWebGLMultisampleRenderTarget: true,
      copy: function(source) {
        WebGLRenderTarget.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
      }
    });
    var _v1 = new Vector3();
    var _m1 = new Matrix4();
    var _zero = new Vector3(0, 0, 0);
    var _one = new Vector3(1, 1, 1);
    var _x = new Vector3();
    var _y = new Vector3();
    var _z = new Vector3();
    function Matrix4() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    Object.assign(Matrix4.prototype, {
      isMatrix4: true,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new Matrix4().fromArray(this.elements);
      },
      copy: function(m2) {
        var te = this.elements;
        var me = m2.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      },
      copyPosition: function(m2) {
        var te = this.elements, me = m2.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function(m2) {
        var te = this.elements;
        var me = m2.elements;
        var scaleX = 1 / _v1.setFromMatrixColumn(m2, 0).length();
        var scaleY = 1 / _v1.setFromMatrixColumn(m2, 1).length();
        var scaleZ = 1 / _v1.setFromMatrixColumn(m2, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      makeRotationFromEuler: function(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        var te = this.elements;
        var x = euler.x, y2 = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y2), d2 = Math.sin(y2);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
          var ae = a * e, af = a * f, be = b * e, bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d2;
          te[1] = af + be * d2;
          te[5] = ae - bf * d2;
          te[9] = -b * c;
          te[2] = bf - ae * d2;
          te[6] = be + af * d2;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          var ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d2;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          var ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d2;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          var ae = a * e, af = a * f, be = b * e, bf = b * f;
          te[0] = c * e;
          te[4] = be * d2 - af;
          te[8] = ae * d2 + bf;
          te[1] = c * f;
          te[5] = bf * d2 + ae;
          te[9] = af * d2 - be;
          te[2] = -d2;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          var ac = a * c, ad = a * d2, bc = b * c, bd = b * d2;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d2 * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
          var ac = a * c, ad = a * d2, bc = b * c, bd = b * d2;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d2 * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      makeRotationFromQuaternion: function(q) {
        return this.compose(_zero, q, _one);
      },
      lookAt: function(eye, target, up) {
        var te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 0.0001;
          } else {
            _z.z += 0.0001;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      },
      multiply: function(m2, n) {
        if (n !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m2, n);
        }
        return this.multiplyMatrices(this, m2);
      },
      premultiply: function(m2) {
        return this.multiplyMatrices(m2, this);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyScalar: function(s2) {
        var te = this.elements;
        te[0] *= s2;
        te[4] *= s2;
        te[8] *= s2;
        te[12] *= s2;
        te[1] *= s2;
        te[5] *= s2;
        te[9] *= s2;
        te[13] *= s2;
        te[2] *= s2;
        te[6] *= s2;
        te[10] *= s2;
        te[14] *= s2;
        te[3] *= s2;
        te[7] *= s2;
        te[11] *= s2;
        te[15] *= s2;
        return this;
      },
      applyToBufferAttribute: function(attribute) {
        for (var i3 = 0, l = attribute.count; i3 < l; i3++) {
          _v1.x = attribute.getX(i3);
          _v1.y = attribute.getY(i3);
          _v1.z = attribute.getZ(i3);
          _v1.applyMatrix4(this);
          attribute.setXYZ(i3, _v1.x, _v1.y, _v1.z);
        }
        return attribute;
      },
      determinant: function() {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      },
      transpose: function() {
        var te = this.elements;
        var tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
      },
      setPosition: function(x, y2, z) {
        var te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y2;
          te[14] = z;
        }
        return this;
      },
      getInverse: function(m2, throwOnDegenerate) {
        var te = this.elements, me = m2.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) {
          var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      },
      scale: function(v) {
        var te = this.elements;
        var x = v.x, y2 = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y2;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y2;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y2;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y2;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      },
      makeTranslation: function(x, y2, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y2, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        var c = Math.cos(theta), s2 = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        var c = Math.cos(theta), s2 = Math.sin(theta);
        this.set(c, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        var c = Math.cos(theta), s2 = Math.sin(theta);
        this.set(c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s2 = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y2 = axis.y, z = axis.z;
        var tx = t * x, ty = t * y2;
        this.set(tx * x + c, tx * y2 - s2 * z, tx * z + s2 * y2, 0, tx * y2 + s2 * z, ty * y2 + c, ty * z - s2 * x, 0, tx * z - s2 * y2, ty * z + s2 * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x, y2, z) {
        this.set(x, 0, 0, 0, 0, y2, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      makeShear: function(x, y2, z) {
        this.set(1, y2, z, 0, x, 1, z, 0, x, y2, 1, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        var te = this.elements;
        var x = quaternion._x, y2 = quaternion._y, z = quaternion._z, w2 = quaternion._w;
        var x2 = x + x, y22 = y2 + y2, z2 = z + z;
        var xx = x * x2, xy = x * y22, xz = x * z2;
        var yy = y2 * y22, yz = y2 * z2, zz = z * z2;
        var wx = w2 * x2, wy = w2 * y22, wz = w2 * z2;
        var sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      },
      decompose: function(position, quaternion, scale) {
        var te = this.elements;
        var sx = _v1.set(te[0], te[1], te[2]).length();
        var sy = _v1.set(te[4], te[5], te[6]).length();
        var sz = _v1.set(te[8], te[9], te[10]).length();
        var det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      },
      makePerspective: function(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y2 = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d2 = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y2;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d2;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w2 = 1 / (right - left);
        var h2 = 1 / (top - bottom);
        var p = 1 / (far - near);
        var x = (right + left) * w2;
        var y2 = (top + bottom) * h2;
        var z = (far + near) * p;
        te[0] = 2 * w2;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h2;
        te[9] = 0;
        te[13] = -y2;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i3 = 0; i3 < 16; i3++) {
          if (te[i3] !== me[i3])
            return false;
        }
        return true;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        for (var i3 = 0; i3 < 16; i3++) {
          this.elements[i3] = array[i3 + offset];
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      }
    });
    var _matrix = new Matrix4();
    var _quaternion$1 = new Quaternion();
    function Euler(x, y2, z, order) {
      this._x = x || 0;
      this._y = y2 || 0;
      this._z = z || 0;
      this._order = order || Euler.DefaultOrder;
    }
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    Euler.DefaultOrder = "XYZ";
    Object.defineProperties(Euler.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        set: function(value2) {
          this._x = value2;
          this._onChangeCallback();
        }
      },
      y: {
        get: function() {
          return this._y;
        },
        set: function(value2) {
          this._y = value2;
          this._onChangeCallback();
        }
      },
      z: {
        get: function() {
          return this._z;
        },
        set: function(value2) {
          this._z = value2;
          this._onChangeCallback();
        }
      },
      order: {
        get: function() {
          return this._order;
        },
        set: function(value2) {
          this._order = value2;
          this._onChangeCallback();
        }
      }
    });
    Object.assign(Euler.prototype, {
      isEuler: true,
      set: function(x, y2, z, order) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m2, order, update2) {
        var clamp2 = _Math.clamp;
        var te = m2.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        if (order === "XYZ") {
          this._y = Math.asin(clamp2(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === "YXZ") {
          this._x = Math.asin(-clamp2(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === "ZXY") {
          this._x = Math.asin(clamp2(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === "ZYX") {
          this._y = Math.asin(-clamp2(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === "YZX") {
          this._z = Math.asin(clamp2(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === "XZY") {
          this._z = Math.asin(-clamp2(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
        }
        this._order = order;
        if (update2 !== false)
          this._onChangeCallback();
        return this;
      },
      setFromQuaternion: function(q, order, update2) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update2);
      },
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function(newOrder) {
        _quaternion$1.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$1, newOrder);
      },
      equals: function(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0)
          this._order = array[3];
        this._onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new Vector3(this._x, this._y, this._z);
        }
      },
      _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
      },
      _onChangeCallback: function() {
      }
    });
    function Layers() {
      this.mask = 1 | 0;
    }
    Object.assign(Layers.prototype, {
      set: function(channel) {
        this.mask = 1 << channel | 0;
      },
      enable: function(channel) {
        this.mask |= 1 << channel | 0;
      },
      enableAll: function() {
        this.mask = 4294967295 | 0;
      },
      toggle: function(channel) {
        this.mask ^= 1 << channel | 0;
      },
      disable: function(channel) {
        this.mask &= ~(1 << channel | 0);
      },
      disableAll: function() {
        this.mask = 0;
      },
      test: function(layers) {
        return (this.mask & layers.mask) !== 0;
      }
    });
    var _object3DId = 0;
    var _v1$1 = new Vector3();
    var _q1 = new Quaternion();
    var _m1$1 = new Matrix4();
    var _target = new Vector3();
    var _position = new Vector3();
    var _scale = new Vector3();
    var _quaternion$2 = new Quaternion();
    var _xAxis = new Vector3(1, 0, 0);
    var _yAxis = new Vector3(0, 1, 0);
    var _zAxis = new Vector3(0, 0, 1);
    var _addedEvent = {
      type: "added"
    };
    var _removedEvent = {
      type: "removed"
    };
    function Object3D() {
      Object.defineProperty(this, "id", {
        value: _object3DId++
      });
      this.uuid = _Math.generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D.DefaultUp.clone();
      var position = new Vector3();
      var rotation = new Euler();
      var quaternion = new Quaternion();
      var scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.userData = {};
    }
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Object3D,
      isObject3D: true,
      onBeforeRender: function() {
      },
      onAfterRender: function() {
      },
      applyMatrix: function(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m2) {
        this.quaternion.setFromRotationMatrix(m2);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      },
      rotateOnWorldAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      },
      rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      },
      rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      },
      rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      },
      translateOnAxis: function(axis, distance) {
        _v1$1.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$1.multiplyScalar(distance));
        return this;
      },
      translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
      },
      translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
      },
      translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
      },
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function(vector) {
        return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
      },
      lookAt: function(x, y2, z) {
        if (x.isVector3) {
          _target.copy(x);
        } else {
          _target.set(x, y2, z);
        }
        var parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$1.lookAt(_position, _target, this.up);
        } else {
          _m1$1.lookAt(_target, _position, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
          _m1$1.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$1);
          this.quaternion.premultiply(_q1.inverse());
        }
      },
      add: function(object) {
        if (arguments.length > 1) {
          for (var i3 = 0; i3 < arguments.length; i3++) {
            this.add(arguments[i3]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (var i3 = 0; i3 < arguments.length; i3++) {
            this.remove(arguments[i3]);
          }
          return this;
        }
        var index2 = this.children.indexOf(object);
        if (index2 !== -1) {
          object.parent = null;
          this.children.splice(index2, 1);
          object.dispatchEvent(_removedEvent);
        }
        return this;
      },
      attach: function(object) {
        this.updateWorldMatrix(true, false);
        _m1$1.getInverse(this.matrixWorld);
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix(_m1$1);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
      },
      getObjectById: function(id) {
        return this.getObjectByProperty("id", id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty("name", name);
      },
      getObjectByProperty: function(name, value2) {
        if (this[name] === value2)
          return this;
        for (var i3 = 0, l = this.children.length; i3 < l; i3++) {
          var child = this.children[i3];
          var object = child.getObjectByProperty(name, value2);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      },
      getWorldPosition: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldPosition() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
          target = new Quaternion();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
      },
      getWorldScale: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldScale() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, _quaternion$2, target);
        return target;
      },
      getWorldDirection: function(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldDirection() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        var e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
      },
      raycast: function() {
      },
      traverse: function(callback) {
        callback(this);
        var children2 = this.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          children2[i3].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return;
        callback(this);
        var children2 = this.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          children2[i3].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        var parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        var children2 = this.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          children2[i3].updateMatrixWorld(force);
        }
      },
      updateWorldMatrix: function(updateParents, updateChildren) {
        var parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          var children2 = this.children;
          for (var i3 = 0, l = children2.length; i3 < l; i3++) {
            children2[i3].updateWorldMatrix(false, true);
          }
        }
      },
      toJSON: function(meta) {
        var isRootObject = meta === void 0 || typeof meta === "string";
        var output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        function serialize(library, element2) {
          if (library[element2.uuid] === void 0) {
            library[element2.uuid] = element2.toJSON(meta);
          }
          return element2.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          var parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            var shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (var i3 = 0, l = shapes.length; i3 < l; i3++) {
                var shape = shapes[i3];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            var uuids = [];
            for (var i3 = 0, l = this.material.length; i3 < l; i3++) {
              uuids.push(serialize(meta.materials, this.material[i3]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (var i3 = 0; i3 < this.children.length; i3++) {
            object.children.push(this.children[i3].toJSON(meta).object);
          }
        }
        if (isRootObject) {
          var geometries = extractFromCache(meta.geometries);
          var materials = extractFromCache(meta.materials);
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          var shapes = extractFromCache(meta.shapes);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (shapes.length > 0)
            output.shapes = shapes;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      },
      clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
      },
      copy: function(source, recursive) {
        if (recursive === void 0)
          recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (var i3 = 0; i3 < source.children.length; i3++) {
            var child = source.children[i3];
            this.add(child.clone());
          }
        }
        return this;
      }
    });
    function Scene() {
      Object3D.call(this);
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
    }
    Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Scene,
      isScene: true,
      copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      },
      toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null)
          data.object.background = this.background.toJSON(meta);
        if (this.environment !== null)
          data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    var _vector$2 = new Vector3();
    var _box = new Box3();
    var _v0 = new Vector3();
    var _v1$2 = new Vector3();
    var _v2 = new Vector3();
    var _f0 = new Vector3();
    var _f1 = new Vector3();
    var _f2 = new Vector3();
    var _center = new Vector3();
    var _extents = new Vector3();
    var _triangleNormal = new Vector3();
    var _testAxis = new Vector3();
    function Box3(min, max) {
      this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
      this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    Object.assign(Box3.prototype, {
      isBox3: true,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromArray: function(array) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i3 = 0, l = array.length; i3 < l; i3 += 3) {
          var x = array[i3];
          var y2 = array[i3 + 1];
          var z = array[i3 + 2];
          if (x < minX)
            minX = x;
          if (y2 < minY)
            minY = y2;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y2 > maxY)
            maxY = y2;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      },
      setFromBufferAttribute: function(attribute) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i3 = 0, l = attribute.count; i3 < l; i3++) {
          var x = attribute.getX(i3);
          var y2 = attribute.getY(i3);
          var z = attribute.getZ(i3);
          if (x < minX)
            minX = x;
          if (y2 < minY)
            minY = y2;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y2 > maxY)
            maxY = y2;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i3 = 0, il = points.length; i3 < il; i3++) {
          this.expandByPoint(points[i3]);
        }
        return this;
      },
      setFromCenterAndSize: function(center, size) {
        var halfSize = _vector$2.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      },
      setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getCenter() target is now required");
          target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getSize() target is now required");
          target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      expandByObject: function(object) {
        object.updateWorldMatrix(false, false);
        var geometry = object.geometry;
        if (geometry !== void 0) {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box.copy(geometry.boundingBox);
          _box.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_box.min);
          this.expandByPoint(_box.max);
        }
        var children2 = object.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          this.expandByObject(children2[i3]);
        }
        return this;
      },
      containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      },
      containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      },
      getParameter: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getParameter() target is now required");
          target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      intersectsBox: function(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      },
      intersectsSphere: function(sphere) {
        this.clampPoint(sphere.center, _vector$2);
        return _vector$2.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      },
      intersectsPlane: function(plane) {
        var min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      },
      intersectsTriangle: function(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0.subVectors(triangle.a, _center);
        _v1$2.subVectors(triangle.b, _center);
        _v2.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$2, _v0);
        _f1.subVectors(_v2, _v1$2);
        _f2.subVectors(_v0, _v2);
        var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0, _v1$2, _v2, _extents);
      },
      clampPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .clampPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function(point) {
        var clampedPoint = _vector$2.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      },
      getBoundingSphere: function(target) {
        if (target === void 0) {
          console.error("THREE.Box3: .getBoundingSphere() target is now required");
        }
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$2).length() * 0.5;
        return target;
      },
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function(matrix) {
        if (this.isEmpty())
          return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    });
    function satForAxes(axes, v0, v1, v2, extents) {
      var i3, j;
      for (i3 = 0, j = axes.length - 3; i3 <= j; i3 += 3) {
        _testAxis.fromArray(axes, i3);
        var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        var p0 = v0.dot(_testAxis);
        var p1 = v1.dot(_testAxis);
        var p2 = v2.dot(_testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          return false;
        }
      }
      return true;
    }
    var _box$1 = new Box3();
    function Sphere(center, radius) {
      this.center = center !== void 0 ? center : new Vector3();
      this.radius = radius !== void 0 ? radius : 0;
    }
    Object.assign(Sphere.prototype, {
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$1.setFromPoints(points).getCenter(center);
        }
        var maxRadiusSq = 0;
        for (var i3 = 0, il = points.length; i3 < il; i3++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i3]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      empty: function() {
        return this.radius <= 0;
      },
      containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      },
      intersectsBox: function(box) {
        return box.intersectsSphere(this);
      },
      intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function(point, target) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        if (target === void 0) {
          console.warn("THREE.Sphere: .clampPoint() target is now required");
          target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      },
      getBoundingBox: function(target) {
        if (target === void 0) {
          console.warn("THREE.Sphere: .getBoundingBox() target is now required");
          target = new Box3();
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
    });
    var _vector$3 = new Vector3();
    var _segCenter = new Vector3();
    var _segDir = new Vector3();
    var _diff = new Vector3();
    var _edge1 = new Vector3();
    var _edge2 = new Vector3();
    var _normal = new Vector3();
    function Ray(origin, direction) {
      this.origin = origin !== void 0 ? origin : new Vector3();
      this.direction = direction !== void 0 ? direction : new Vector3(0, 0, -1);
    }
    Object.assign(Ray.prototype, {
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .at() target is now required");
          target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      lookAt: function(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      },
      recast: function(t) {
        this.origin.copy(this.at(t, _vector$3));
        return this;
      },
      closestPointToPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        target.subVectors(point, this.origin);
        var directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      },
      distanceSqToPoint: function(point) {
        var directionDistance = _vector$3.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$3.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$3.distanceToSquared(point);
      },
      distanceSqToSegment: function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(_segDir);
        var b0 = _diff.dot(this.direction);
        var b1 = -_diff.dot(_segDir);
        var c = _diff.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
      },
      intersectSphere: function(sphere, target) {
        _vector$3.subVectors(sphere.center, this.origin);
        var tca = _vector$3.dot(this.direction);
        var d2 = _vector$3.dot(_vector$3) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        var thc = Math.sqrt(radius2 - d2);
        var t0 = tca - thc;
        var t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      },
      intersectsSphere: function(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      },
      distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      },
      intersectPlane: function(plane, target) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, target);
      },
      intersectsPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      intersectBox: function(box, target) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      },
      intersectsBox: function(box) {
        return this.intersectBox(box, _vector$3) !== null;
      },
      intersectTriangle: function(a, b, c, backfaceCulling, target) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        var DdN = this.direction.dot(_normal);
        var sign;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign = 1;
        } else if (DdN < 0) {
          sign = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        var QdN = -sign * _diff.dot(_normal);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      },
      applyMatrix4: function(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
    });
    var _vector1 = new Vector3();
    var _vector2 = new Vector3();
    var _normalMatrix = new Matrix3();
    function Plane(normal, constant) {
      this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
      this.constant = constant !== void 0 ? constant : 0;
    }
    Object.assign(Plane.prototype, {
      isPlane: true,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x, y2, z, w2) {
        this.normal.set(x, y2, z);
        this.constant = w2;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function(a, b, c) {
        var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        var inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .projectPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      },
      intersectLine: function(line, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .intersectLine() target is now required");
          target = new Vector3();
        }
        var direction = line.delta(_vector1);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return void 0;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return void 0;
        }
        return target.copy(direction).multiplyScalar(t).add(line.start);
      },
      intersectsLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      },
      intersectsBox: function(box) {
        return box.intersectsPlane(this);
      },
      intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
      },
      coplanarPoint: function(target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .coplanarPoint() target is now required");
          target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function(matrix, optionalNormalMatrix) {
        var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      },
      translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
    });
    var _v0$1 = new Vector3();
    var _v1$3 = new Vector3();
    var _v2$1 = new Vector3();
    var _v3 = new Vector3();
    var _vab = new Vector3();
    var _vac = new Vector3();
    var _vbc = new Vector3();
    var _vap = new Vector3();
    var _vbp = new Vector3();
    var _vcp = new Vector3();
    function Triangle(a, b, c) {
      this.a = a !== void 0 ? a : new Vector3();
      this.b = b !== void 0 ? b : new Vector3();
      this.c = c !== void 0 ? c : new Vector3();
    }
    Object.assign(Triangle, {
      getNormal: function(a, b, c, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getNormal() target is now required");
          target = new Vector3();
        }
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        var targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      },
      getBarycoord: function(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$1.subVectors(point, a);
        var dot00 = _v0$1.dot(_v0$1);
        var dot01 = _v0$1.dot(_v1$3);
        var dot02 = _v0$1.dot(_v2$1);
        var dot11 = _v1$3.dot(_v1$3);
        var dot12 = _v1$3.dot(_v2$1);
        var denom = dot00 * dot11 - dot01 * dot01;
        if (target === void 0) {
          console.warn("THREE.Triangle: .getBarycoord() target is now required");
          target = new Vector3();
        }
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      },
      containsPoint: function(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
      },
      getUV: function(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3.x);
        target.addScaledVector(uv2, _v3.y);
        target.addScaledVector(uv3, _v3.z);
        return target;
      },
      isFrontFacing: function(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
    });
    Object.assign(Triangle.prototype, {
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i22) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i22]);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      getArea: function() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
      },
      getMidpoint: function(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getMidpoint() target is now required");
          target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      getNormal: function(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      },
      getPlane: function(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getPlane() target is now required");
          target = new Plane();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      getBarycoord: function(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      },
      getUV: function(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      },
      containsPoint: function(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      isFrontFacing: function(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      },
      intersectsBox: function(box) {
        return box.intersectsTriangle(this);
      },
      closestPointToPoint: function(p, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        var a = this.a, b = this.b, c = this.c;
        var v, w2;
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        var d1 = _vab.dot(_vap);
        var d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        _vbp.subVectors(p, b);
        var d3 = _vab.dot(_vbp);
        var d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b);
        }
        var vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        var d5 = _vab.dot(_vcp);
        var d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        var vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w2 = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(_vac, w2);
        }
        var va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b);
          w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b).addScaledVector(_vbc, w2);
        }
        var denom = 1 / (va + vb + vc);
        v = vb * denom;
        w2 = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w2);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    });
    var _colorKeywords = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    var _hslA = {
      h: 0,
      s: 0,
      l: 0
    };
    var _hslB = {
      h: 0,
      s: 0,
      l: 0
    };
    function Color(r, g, b) {
      if (g === void 0 && b === void 0) {
        return this.set(r);
      }
      return this.setRGB(r, g, b);
    }
    function hue2rgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }
    function SRGBToLinear(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB(c) {
      return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }
    Object.assign(Color.prototype, {
      isColor: true,
      r: 1,
      g: 1,
      b: 1,
      set: function(value2) {
        if (value2 && value2.isColor) {
          this.copy(value2);
        } else if (typeof value2 === "number") {
          this.setHex(value2);
        } else if (typeof value2 === "string") {
          this.setStyle(value2);
        }
        return this;
      },
      setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function(h2, s2, l) {
        h2 = _Math.euclideanModulo(h2, 1);
        s2 = _Math.clamp(s2, 0, 1);
        l = _Math.clamp(l, 0, 1);
        if (s2 === 0) {
          this.r = this.g = this.b = l;
        } else {
          var p = l <= 0.5 ? l * (1 + s2) : l + s2 - l * s2;
          var q = 2 * l - p;
          this.r = hue2rgb(q, p, h2 + 1 / 3);
          this.g = hue2rgb(q, p, h2);
          this.b = hue2rgb(q, p, h2 - 1 / 3);
        }
        return this;
      },
      setStyle: function(style) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        var m2;
        if (m2 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
          var color;
          var name = m2[1];
          var components = m2[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[5]);
                return this;
              }
              if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[5]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                var h2 = parseFloat(color[1]) / 360;
                var s2 = parseInt(color[2], 10) / 100;
                var l = parseInt(color[3], 10) / 100;
                handleAlpha(color[5]);
                return this.setHSL(h2, s2, l);
              }
              break;
          }
        } else if (m2 = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
          var hex = m2[1];
          var size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style);
        }
        return this;
      },
      setColorName: function(style) {
        var hex = _colorKeywords[style];
        if (hex !== void 0) {
          this.setHex(hex);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      },
      clone: function() {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === void 0)
          gammaFactor = 2;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === void 0)
          gammaFactor = 2;
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
      },
      convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
      },
      copySRGBToLinear: function(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      },
      copyLinearToSRGB: function(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      },
      convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
      },
      convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
      },
      getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
      },
      getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(target) {
        if (target === void 0) {
          console.warn("THREE.Color: .getHSL() target is now required");
          target = {
            h: 0,
            s: 0,
            l: 0
          };
        }
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      },
      getStyle: function() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
      },
      offsetHSL: function(h2, s2, l) {
        this.getHSL(_hslA);
        _hslA.h += h2;
        _hslA.s += s2;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s2) {
        this.r += s2;
        this.g += s2;
        this.b += s2;
        return this;
      },
      sub: function(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s2) {
        this.r *= s2;
        this.g *= s2;
        this.b *= s2;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      lerpHSL: function(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        var h2 = _Math.lerp(_hslA.h, _hslB.h, alpha);
        var s2 = _Math.lerp(_hslA.s, _hslB.s, alpha);
        var l = _Math.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h2, s2, l);
        return this;
      },
      equals: function(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      },
      toJSON: function() {
        return this.getHex();
      }
    });
    Color.NAMES = _colorKeywords;
    function Face3(a, b, c, normal, color, materialIndex) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal && normal.isVector3 ? normal : new Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color && color.isColor ? color : new Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
    }
    Object.assign(Face3.prototype, {
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (var i3 = 0, il = source.vertexNormals.length; i3 < il; i3++) {
          this.vertexNormals[i3] = source.vertexNormals[i3].clone();
        }
        for (var i3 = 0, il = source.vertexColors.length; i3 < il; i3++) {
          this.vertexColors[i3] = source.vertexColors[i3].clone();
        }
        return this;
      }
    });
    var materialId = 0;
    function Material() {
      Object.defineProperty(this, "id", {
        value: materialId++
      });
      this.uuid = _Math.generateUUID();
      this.name = "";
      this.type = "Material";
      this.fog = true;
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.flatShading = false;
      this.vertexTangents = false;
      this.vertexColors = NoColors;
      this.opacity = 1;
      this.transparent = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaTest = 0;
      this.premultipliedAlpha = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
    }
    Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Material,
      isMaterial: true,
      onBeforeCompile: function() {
      },
      setValues: function(values) {
        if (values === void 0)
          return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading ? true : false;
            continue;
          }
          var currentValue = this[key];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      },
      toJSON: function(meta) {
        var isRoot = meta === void 0 || typeof meta === "string";
        if (isRoot) {
          meta = {
            textures: {},
            images: {}
          };
        }
        var data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor)
          data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture)
          data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          data.reflectivity = this.reflectivity;
          data.refractionRatio = this.refractionRatio;
          if (this.combine !== void 0)
            data.combine = this.combine;
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.size !== void 0)
          data.size = this.size;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
          data.blending = this.blending;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.side !== FrontSide)
          data.side = this.side;
        if (this.vertexColors !== NoColors)
          data.vertexColors = this.vertexColors;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true)
          data.morphTargets = true;
        if (this.morphNormals === true)
          data.morphNormals = true;
        if (this.skinning === true)
          data.skinning = true;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data2 = cache[key];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRoot) {
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexTangents = source.vertexTangents;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        var srcPlanes = source.clippingPlanes, dstPlanes = null;
        if (srcPlanes !== null) {
          var n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (var i3 = 0; i3 !== n; ++i3)
            dstPlanes[i3] = srcPlanes[i3].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    Object.defineProperty(Material.prototype, "needsUpdate", {
      set: function(value2) {
        if (value2 === true)
          this.version++;
      }
    });
    function MeshBasicMaterial(parameters) {
      Material.call(this);
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    }
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      return this;
    };
    var _vector$4 = new Vector3();
    function BufferAttribute(array, itemSize, normalized) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized === true;
      this.usage = StaticDrawUsage;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    }
    Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
      set: function(value2) {
        if (value2 === true)
          this.version++;
      }
    });
    Object.assign(BufferAttribute.prototype, {
      isBufferAttribute: true,
      onUploadCallback: function() {
      },
      setUsage: function(value2) {
        this.usage = value2;
        return this;
      },
      copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i3 = 0, l = this.itemSize; i3 < l; i3++) {
          this.array[index1 + i3] = attribute.array[index2 + i3];
        }
        return this;
      },
      copyArray: function(array) {
        this.array.set(array);
        return this;
      },
      copyColorsArray: function(colors) {
        var array = this.array, offset = 0;
        for (var i3 = 0, l = colors.length; i3 < l; i3++) {
          var color = colors[i3];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i3);
            color = new Color();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      },
      copyVector2sArray: function(vectors) {
        var array = this.array, offset = 0;
        for (var i3 = 0, l = vectors.length; i3 < l; i3++) {
          var vector = vectors[i3];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i3);
            vector = new Vector2();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      },
      copyVector3sArray: function(vectors) {
        var array = this.array, offset = 0;
        for (var i3 = 0, l = vectors.length; i3 < l; i3++) {
          var vector = vectors[i3];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i3);
            vector = new Vector3();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      },
      copyVector4sArray: function(vectors) {
        var array = this.array, offset = 0;
        for (var i3 = 0, l = vectors.length; i3 < l; i3++) {
          var vector = vectors[i3];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i3);
            vector = new Vector4();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      },
      applyMatrix3: function(m2) {
        for (var i3 = 0, l = this.count; i3 < l; i3++) {
          _vector$4.x = this.getX(i3);
          _vector$4.y = this.getY(i3);
          _vector$4.z = this.getZ(i3);
          _vector$4.applyMatrix3(m2);
          this.setXYZ(i3, _vector$4.x, _vector$4.y, _vector$4.z);
        }
        return this;
      },
      applyMatrix4: function(m2) {
        for (var i3 = 0, l = this.count; i3 < l; i3++) {
          _vector$4.x = this.getX(i3);
          _vector$4.y = this.getY(i3);
          _vector$4.z = this.getZ(i3);
          _vector$4.applyMatrix4(m2);
          this.setXYZ(i3, _vector$4.x, _vector$4.y, _vector$4.z);
        }
        return this;
      },
      applyNormalMatrix: function(m2) {
        for (var i3 = 0, l = this.count; i3 < l; i3++) {
          _vector$4.x = this.getX(i3);
          _vector$4.y = this.getY(i3);
          _vector$4.z = this.getZ(i3);
          _vector$4.applyNormalMatrix(m2);
          this.setXYZ(i3, _vector$4.x, _vector$4.y, _vector$4.z);
        }
        return this;
      },
      transformDirection: function(m2) {
        for (var i3 = 0, l = this.count; i3 < l; i3++) {
          _vector$4.x = this.getX(i3);
          _vector$4.y = this.getY(i3);
          _vector$4.z = this.getZ(i3);
          _vector$4.transformDirection(m2);
          this.setXYZ(i3, _vector$4.x, _vector$4.y, _vector$4.z);
        }
        return this;
      },
      set: function(value2, offset) {
        if (offset === void 0)
          offset = 0;
        this.array.set(value2, offset);
        return this;
      },
      getX: function(index2) {
        return this.array[index2 * this.itemSize];
      },
      setX: function(index2, x) {
        this.array[index2 * this.itemSize] = x;
        return this;
      },
      getY: function(index2) {
        return this.array[index2 * this.itemSize + 1];
      },
      setY: function(index2, y2) {
        this.array[index2 * this.itemSize + 1] = y2;
        return this;
      },
      getZ: function(index2) {
        return this.array[index2 * this.itemSize + 2];
      },
      setZ: function(index2, z) {
        this.array[index2 * this.itemSize + 2] = z;
        return this;
      },
      getW: function(index2) {
        return this.array[index2 * this.itemSize + 3];
      },
      setW: function(index2, w2) {
        this.array[index2 * this.itemSize + 3] = w2;
        return this;
      },
      setXY: function(index2, x, y2) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y2;
        return this;
      },
      setXYZ: function(index2, x, y2, z) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y2;
        this.array[index2 + 2] = z;
        return this;
      },
      setXYZW: function(index2, x, y2, z, w2) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x;
        this.array[index2 + 1] = y2;
        this.array[index2 + 2] = z;
        this.array[index2 + 3] = w2;
        return this;
      },
      onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
      },
      clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
      toJSON: function() {
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
      }
    });
    function Int8BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    function Uint8BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    function Int16BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    function Uint16BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    function Int32BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    function Uint32BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    function Float32BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    function Float64BufferAttribute(array, itemSize, normalized) {
      BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
    function DirectGeometry() {
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    }
    Object.assign(DirectGeometry.prototype, {
      computeGroups: function(geometry) {
        var group;
        var groups = [];
        var materialIndex = void 0;
        var faces = geometry.faces;
        for (var i3 = 0; i3 < faces.length; i3++) {
          var face = faces[i3];
          if (face.materialIndex !== materialIndex) {
            materialIndex = face.materialIndex;
            if (group !== void 0) {
              group.count = i3 * 3 - group.start;
              groups.push(group);
            }
            group = {
              start: i3 * 3,
              materialIndex
            };
          }
        }
        if (group !== void 0) {
          group.count = i3 * 3 - group.start;
          groups.push(group);
        }
        this.groups = groups;
      },
      fromGeometry: function(geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        var morphTargetsPosition;
        if (morphTargetsLength > 0) {
          morphTargetsPosition = [];
          for (var i3 = 0; i3 < morphTargetsLength; i3++) {
            morphTargetsPosition[i3] = {
              name: morphTargets[i3].name,
              data: []
            };
          }
          this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        var morphTargetsNormal;
        if (morphNormalsLength > 0) {
          morphTargetsNormal = [];
          for (var i3 = 0; i3 < morphNormalsLength; i3++) {
            morphTargetsNormal[i3] = {
              name: morphNormals[i3].name,
              data: []
            };
          }
          this.morphTargets.normal = morphTargetsNormal;
        }
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        if (vertices.length > 0 && faces.length === 0) {
          console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        }
        for (var i3 = 0; i3 < faces.length; i3++) {
          var face = faces[i3];
          this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
          } else {
            var normal = face.normal;
            this.normals.push(normal, normal, normal);
          }
          var vertexColors = face.vertexColors;
          if (vertexColors.length === 3) {
            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
          } else {
            var color = face.color;
            this.colors.push(color, color, color);
          }
          if (hasFaceVertexUv === true) {
            var vertexUvs = faceVertexUvs[0][i3];
            if (vertexUvs !== void 0) {
              this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i3);
              this.uvs.push(new Vector2(), new Vector2(), new Vector2());
            }
          }
          if (hasFaceVertexUv2 === true) {
            var vertexUvs = faceVertexUvs[1][i3];
            if (vertexUvs !== void 0) {
              this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i3);
              this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
            }
          }
          for (var j = 0; j < morphTargetsLength; j++) {
            var morphTarget = morphTargets[j].vertices;
            morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
          }
          for (var j = 0; j < morphNormalsLength; j++) {
            var morphNormal = morphNormals[j].vertexNormals[i3];
            morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
          }
          if (hasSkinIndices) {
            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
          }
          if (hasSkinWeights) {
            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
          }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      }
    });
    function arrayMax(array) {
      if (array.length === 0)
        return -Infinity;
      var max = array[0];
      for (var i3 = 1, l = array.length; i3 < l; ++i3) {
        if (array[i3] > max)
          max = array[i3];
      }
      return max;
    }
    var _bufferGeometryId = 1;
    var _m1$2 = new Matrix4();
    var _obj = new Object3D();
    var _offset = new Vector3();
    var _box$2 = new Box3();
    var _boxMorphTargets = new Box3();
    var _vector$5 = new Vector3();
    function BufferGeometry() {
      Object.defineProperty(this, "id", {
        value: _bufferGeometryId += 2
      });
      this.uuid = _Math.generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = {
        start: 0,
        count: Infinity
      };
      this.userData = {};
    }
    BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: BufferGeometry,
      isBufferGeometry: true,
      getIndex: function() {
        return this.index;
      },
      setIndex: function(index2) {
        if (Array.isArray(index2)) {
          this.index = new (arrayMax(index2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
        } else {
          this.index = index2;
        }
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      },
      deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
      },
      addGroup: function(start, count, materialIndex) {
        this.groups.push({
          start,
          count,
          materialIndex: materialIndex !== void 0 ? materialIndex : 0
        });
      },
      clearGroups: function() {
        this.groups = [];
      },
      setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      },
      applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== void 0) {
          var normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        var tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      },
      rotateX: function(angle) {
        _m1$2.makeRotationX(angle);
        this.applyMatrix(_m1$2);
        return this;
      },
      rotateY: function(angle) {
        _m1$2.makeRotationY(angle);
        this.applyMatrix(_m1$2);
        return this;
      },
      rotateZ: function(angle) {
        _m1$2.makeRotationZ(angle);
        this.applyMatrix(_m1$2);
        return this;
      },
      translate: function(x, y2, z) {
        _m1$2.makeTranslation(x, y2, z);
        this.applyMatrix(_m1$2);
        return this;
      },
      scale: function(x, y2, z) {
        _m1$2.makeScale(x, y2, z);
        this.applyMatrix(_m1$2);
        return this;
      },
      lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix(_obj.matrix);
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      },
      setFromObject: function(object) {
        var geometry = object.geometry;
        if (object.isPoints || object.isLine) {
          var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
          var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
          this.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
          this.setAttribute("color", colors.copyColorsArray(geometry.colors));
          if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
            var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
            this.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
          }
          if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
          }
          if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
          }
        } else if (object.isMesh) {
          if (geometry && geometry.isGeometry) {
            this.fromGeometry(geometry);
          }
        }
        return this;
      },
      setFromPoints: function(points) {
        var position = [];
        for (var i3 = 0, l = points.length; i3 < l; i3++) {
          var point = points[i3];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      },
      updateFromObject: function(object) {
        var geometry = object.geometry;
        if (object.isMesh) {
          var direct = geometry.__directGeometry;
          if (geometry.elementsNeedUpdate === true) {
            direct = void 0;
            geometry.elementsNeedUpdate = false;
          }
          if (direct === void 0) {
            return this.fromGeometry(geometry);
          }
          direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
          direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
          direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
          direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
          direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
          geometry.verticesNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.groupsNeedUpdate = false;
          geometry = direct;
        }
        var attribute;
        if (geometry.verticesNeedUpdate === true) {
          attribute = this.attributes.position;
          if (attribute !== void 0) {
            attribute.copyVector3sArray(geometry.vertices);
            attribute.needsUpdate = true;
          }
          geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
          attribute = this.attributes.normal;
          if (attribute !== void 0) {
            attribute.copyVector3sArray(geometry.normals);
            attribute.needsUpdate = true;
          }
          geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
          attribute = this.attributes.color;
          if (attribute !== void 0) {
            attribute.copyColorsArray(geometry.colors);
            attribute.needsUpdate = true;
          }
          geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
          attribute = this.attributes.uv;
          if (attribute !== void 0) {
            attribute.copyVector2sArray(geometry.uvs);
            attribute.needsUpdate = true;
          }
          geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
          attribute = this.attributes.lineDistance;
          if (attribute !== void 0) {
            attribute.copyArray(geometry.lineDistances);
            attribute.needsUpdate = true;
          }
          geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
          geometry.computeGroups(object.geometry);
          this.groups = geometry.groups;
          geometry.groupsNeedUpdate = false;
        }
        return this;
      },
      fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
      },
      fromDirectGeometry: function(geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
          var normals = new Float32Array(geometry.normals.length * 3);
          this.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
          var colors = new Float32Array(geometry.colors.length * 3);
          this.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
          var uvs = new Float32Array(geometry.uvs.length * 2);
          this.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
          var uvs2 = new Float32Array(geometry.uvs2.length * 2);
          this.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        this.groups = geometry.groups;
        for (var name in geometry.morphTargets) {
          var array = [];
          var morphTargets = geometry.morphTargets[name];
          for (var i3 = 0, l = morphTargets.length; i3 < l; i3++) {
            var morphTarget = morphTargets[i3];
            var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
            attribute.name = morphTarget.name;
            array.push(attribute.copyVector3sArray(morphTarget.data));
          }
          this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
          var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
          this.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
          var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
          this.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
              var morphAttribute = morphAttributesPosition[i3];
              _box$2.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$5.addVectors(this.boundingBox.min, _box$2.min);
                this.boundingBox.expandByPoint(_vector$5);
                _vector$5.addVectors(this.boundingBox.max, _box$2.max);
                this.boundingBox.expandByPoint(_vector$5);
              } else {
                this.boundingBox.expandByPoint(_box$2.min);
                this.boundingBox.expandByPoint(_box$2.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position) {
          var center = this.boundingSphere.center;
          _box$2.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
              var morphAttribute = morphAttributesPosition[i3];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$5.addVectors(_box$2.min, _boxMorphTargets.min);
                _box$2.expandByPoint(_vector$5);
                _vector$5.addVectors(_box$2.max, _boxMorphTargets.max);
                _box$2.expandByPoint(_vector$5);
              } else {
                _box$2.expandByPoint(_boxMorphTargets.min);
                _box$2.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$2.getCenter(center);
          var maxRadiusSq = 0;
          for (var i3 = 0, il = position.count; i3 < il; i3++) {
            _vector$5.fromBufferAttribute(position, i3);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$5));
          }
          if (morphAttributesPosition) {
            for (var i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
              var morphAttribute = morphAttributesPosition[i3];
              var morphTargetsRelative = this.morphTargetsRelative;
              for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
                _vector$5.fromBufferAttribute(morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j);
                  _vector$5.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$5));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      },
      computeFaceNormals: function() {
      },
      computeVertexNormals: function() {
        var index2 = this.index;
        var attributes = this.attributes;
        if (attributes.position) {
          var positions = attributes.position.array;
          if (attributes.normal === void 0) {
            this.setAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
          } else {
            var array = attributes.normal.array;
            for (var i3 = 0, il = array.length; i3 < il; i3++) {
              array[i3] = 0;
            }
          }
          var normals = attributes.normal.array;
          var vA, vB, vC;
          var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          var cb = new Vector3(), ab = new Vector3();
          if (index2) {
            var indices = index2.array;
            for (var i3 = 0, il = index2.count; i3 < il; i3 += 3) {
              vA = indices[i3 + 0] * 3;
              vB = indices[i3 + 1] * 3;
              vC = indices[i3 + 2] * 3;
              pA.fromArray(positions, vA);
              pB.fromArray(positions, vB);
              pC.fromArray(positions, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[vA] += cb.x;
              normals[vA + 1] += cb.y;
              normals[vA + 2] += cb.z;
              normals[vB] += cb.x;
              normals[vB + 1] += cb.y;
              normals[vB + 2] += cb.z;
              normals[vC] += cb.x;
              normals[vC + 1] += cb.y;
              normals[vC + 2] += cb.z;
            }
          } else {
            for (var i3 = 0, il = positions.length; i3 < il; i3 += 9) {
              pA.fromArray(positions, i3);
              pB.fromArray(positions, i3 + 3);
              pC.fromArray(positions, i3 + 6);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[i3] = cb.x;
              normals[i3 + 1] = cb.y;
              normals[i3 + 2] = cb.z;
              normals[i3 + 3] = cb.x;
              normals[i3 + 4] = cb.y;
              normals[i3 + 5] = cb.z;
              normals[i3 + 6] = cb.x;
              normals[i3 + 7] = cb.y;
              normals[i3 + 8] = cb.z;
            }
          }
          this.normalizeNormals();
          attributes.normal.needsUpdate = true;
        }
      },
      merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset === void 0) {
          offset = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === void 0)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeOffset = attribute2.itemSize * offset;
          var length2 = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (var i3 = 0, j = attributeOffset; i3 < length2; i3++, j++) {
            attributeArray1[j] = attributeArray2[i3];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        var normals = this.attributes.normal;
        for (var i3 = 0, il = normals.count; i3 < il; i3++) {
          _vector$5.x = normals.getX(i3);
          _vector$5.y = normals.getY(i3);
          _vector$5.z = normals.getZ(i3);
          _vector$5.normalize();
          normals.setXYZ(i3, _vector$5.x, _vector$5.y, _vector$5.z);
        }
      },
      toNonIndexed: function() {
        function convertBufferAttribute(attribute2, indices2) {
          var array = attribute2.array;
          var itemSize = attribute2.itemSize;
          var array2 = new array.constructor(indices2.length * itemSize);
          var index2 = 0, index22 = 0;
          for (var i4 = 0, l2 = indices2.length; i4 < l2; i4++) {
            index2 = indices2[i4] * itemSize;
            for (var j = 0; j < itemSize; j++) {
              array2[index22++] = array[index2++];
            }
          }
          return new BufferAttribute(array2, itemSize);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
          return this;
        }
        var geometry2 = new BufferGeometry();
        var indices = this.index.array;
        var attributes = this.attributes;
        for (var name in attributes) {
          var attribute = attributes[name];
          var newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        var morphAttributes = this.morphAttributes;
        for (name in morphAttributes) {
          var morphArray = [];
          var morphAttribute = morphAttributes[name];
          for (var i3 = 0, il = morphAttribute.length; i3 < il; i3++) {
            var attribute = morphAttribute[i3];
            var newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        var groups = this.groups;
        for (var i3 = 0, l = groups.length; i3 < l; i3++) {
          var group = groups[i3];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      },
      toJSON: function() {
        var data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = {
          attributes: {}
        };
        var index2 = this.index;
        if (index2 !== null) {
          data.data.index = {
            type: index2.array.constructor.name,
            array: Array.prototype.slice.call(index2.array)
          };
        }
        var attributes = this.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var attributeData = attribute.toJSON();
          if (attribute.name !== "")
            attributeData.name = attribute.name;
          data.data.attributes[key] = attributeData;
        }
        var morphAttributes = {};
        var hasMorphAttributes = false;
        for (var key in this.morphAttributes) {
          var attributeArray = this.morphAttributes[key];
          var array = [];
          for (var i3 = 0, il = attributeArray.length; i3 < il; i3++) {
            var attribute = attributeArray[i3];
            var attributeData = attribute.toJSON();
            if (attribute.name !== "")
              attributeData.name = attribute.name;
            array.push(attributeData);
          }
          if (array.length > 0) {
            morphAttributes[key] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        var groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      },
      clone: function() {
        return new BufferGeometry().copy(this);
      },
      copy: function(source) {
        var name, i3, l;
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.name = source.name;
        var index2 = source.index;
        if (index2 !== null) {
          this.setIndex(index2.clone());
        }
        var attributes = source.attributes;
        for (name in attributes) {
          var attribute = attributes[name];
          this.setAttribute(name, attribute.clone());
        }
        var morphAttributes = source.morphAttributes;
        for (name in morphAttributes) {
          var array = [];
          var morphAttribute = morphAttributes[name];
          for (i3 = 0, l = morphAttribute.length; i3 < l; i3++) {
            array.push(morphAttribute[i3].clone());
          }
          this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        var groups = source.groups;
        for (i3 = 0, l = groups.length; i3 < l; i3++) {
          var group = groups[i3];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        var boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    var _inverseMatrix = new Matrix4();
    var _ray = new Ray();
    var _sphere = new Sphere();
    var _vA = new Vector3();
    var _vB = new Vector3();
    var _vC = new Vector3();
    var _tempA = new Vector3();
    var _tempB = new Vector3();
    var _tempC = new Vector3();
    var _morphA = new Vector3();
    var _morphB = new Vector3();
    var _morphC = new Vector3();
    var _uvA = new Vector2();
    var _uvB = new Vector2();
    var _uvC = new Vector2();
    var _intersectionPoint = new Vector3();
    var _intersectionPointWorld = new Vector3();
    function Mesh(geometry, material2) {
      Object3D.call(this);
      this.type = "Mesh";
      this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
      this.material = material2 !== void 0 ? material2 : new MeshBasicMaterial({
        color: Math.random() * 16777215
      });
      this.updateMorphTargets();
    }
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Mesh,
      isMesh: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        return this;
      },
      updateMorphTargets: function() {
        var geometry = this.geometry;
        var m2, ml, name;
        if (geometry.isBufferGeometry) {
          var morphAttributes = geometry.morphAttributes;
          var keys2 = Object.keys(morphAttributes);
          if (keys2.length > 0) {
            var morphAttribute = morphAttributes[keys2[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                name = morphAttribute[m2].name || String(m2);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m2;
              }
            }
          }
        } else {
          var morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      },
      raycast: function(raycaster, intersects2) {
        var geometry = this.geometry;
        var material2 = this.material;
        var matrixWorld = this.matrixWorld;
        if (material2 === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false)
          return;
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (_ray.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        var intersection;
        if (geometry.isBufferGeometry) {
          var a, b, c;
          var index2 = geometry.index;
          var position = geometry.attributes.position;
          var morphPosition = geometry.morphAttributes.position;
          var morphTargetsRelative = geometry.morphTargetsRelative;
          var uv = geometry.attributes.uv;
          var uv2 = geometry.attributes.uv2;
          var groups = geometry.groups;
          var drawRange = geometry.drawRange;
          var i3, j, il, jl;
          var group, groupMaterial;
          var start, end;
          if (index2 !== null) {
            if (Array.isArray(material2)) {
              for (i3 = 0, il = groups.length; i3 < il; i3++) {
                group = groups[i3];
                groupMaterial = material2[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (j = start, jl = end; j < jl; j += 3) {
                  a = index2.getX(j);
                  b = index2.getX(j + 1);
                  c = index2.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              start = Math.max(0, drawRange.start);
              end = Math.min(index2.count, drawRange.start + drawRange.count);
              for (i3 = start, il = end; i3 < il; i3 += 3) {
                a = index2.getX(i3);
                b = index2.getX(i3 + 1);
                c = index2.getX(i3 + 2);
                intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i3 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material2)) {
              for (i3 = 0, il = groups.length; i3 < il; i3++) {
                group = groups[i3];
                groupMaterial = material2[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (j = start, jl = end; j < jl; j += 3) {
                  a = j;
                  b = j + 1;
                  c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              start = Math.max(0, drawRange.start);
              end = Math.min(position.count, drawRange.start + drawRange.count);
              for (i3 = start, il = end; i3 < il; i3 += 3) {
                a = i3;
                b = i3 + 1;
                c = i3 + 2;
                intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i3 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        } else if (geometry.isGeometry) {
          var fvA, fvB, fvC;
          var isMultiMaterial = Array.isArray(material2);
          var vertices = geometry.vertices;
          var faces = geometry.faces;
          var uvs;
          var faceVertexUvs = geometry.faceVertexUvs[0];
          if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
          for (var f = 0, fl = faces.length; f < fl; f++) {
            var face = faces[f];
            var faceMaterial = isMultiMaterial ? material2[face.materialIndex] : material2;
            if (faceMaterial === void 0)
              continue;
            fvA = vertices[face.a];
            fvB = vertices[face.b];
            fvC = vertices[face.c];
            intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
            if (intersection) {
              if (uvs && uvs[f]) {
                var uvs_f = uvs[f];
                _uvA.copy(uvs_f[0]);
                _uvB.copy(uvs_f[1]);
                _uvC.copy(uvs_f[2]);
                intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
              }
              intersection.face = face;
              intersection.faceIndex = f;
              intersects2.push(intersection);
            }
          }
        }
      },
      clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    function checkIntersection(object, material2, raycaster, ray, pA, pB, pC, point) {
      var intersect;
      if (material2.side === BackSide) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material2.side !== DoubleSide, point);
      }
      if (intersect === null)
        return null;
      _intersectionPointWorld.copy(point);
      _intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far)
        return null;
      return {
        distance,
        point: _intersectionPointWorld.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection(object, material2, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
      _vA.fromBufferAttribute(position, a);
      _vB.fromBufferAttribute(position, b);
      _vC.fromBufferAttribute(position, c);
      var morphInfluences = object.morphTargetInfluences;
      if (material2.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for (var i3 = 0, il = morphPosition.length; i3 < il; i3++) {
          var influence = morphInfluences[i3];
          var morphAttribute = morphPosition[i3];
          if (influence === 0)
            continue;
          _tempA.fromBufferAttribute(morphAttribute, a);
          _tempB.fromBufferAttribute(morphAttribute, b);
          _tempC.fromBufferAttribute(morphAttribute, c);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
            _morphB.addScaledVector(_tempB, influence);
            _morphC.addScaledVector(_tempC, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(_vA), influence);
            _morphB.addScaledVector(_tempB.sub(_vB), influence);
            _morphC.addScaledVector(_tempC.sub(_vC), influence);
          }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
      }
      var intersection = checkIntersection(object, material2, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
      if (intersection) {
        if (uv) {
          _uvA.fromBufferAttribute(uv, a);
          _uvB.fromBufferAttribute(uv, b);
          _uvC.fromBufferAttribute(uv, c);
          intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        if (uv2) {
          _uvA.fromBufferAttribute(uv2, a);
          _uvB.fromBufferAttribute(uv2, b);
          _uvC.fromBufferAttribute(uv2, c);
          intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        var face = new Face3(a, b, c);
        Triangle.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
      }
      return intersection;
    }
    var _geometryId = 0;
    var _m1$3 = new Matrix4();
    var _obj$1 = new Object3D();
    var _offset$1 = new Vector3();
    function Geometry() {
      Object.defineProperty(this, "id", {
        value: _geometryId += 2
      });
      this.uuid = _Math.generateUUID();
      this.name = "";
      this.type = "Geometry";
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.elementsNeedUpdate = false;
      this.verticesNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;
    }
    Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: Geometry,
      isGeometry: true,
      applyMatrix: function(matrix) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for (var i3 = 0, il = this.vertices.length; i3 < il; i3++) {
          var vertex = this.vertices[i3];
          vertex.applyMatrix4(matrix);
        }
        for (var i3 = 0, il = this.faces.length; i3 < il; i3++) {
          var face = this.faces[i3];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
      },
      rotateX: function(angle) {
        _m1$3.makeRotationX(angle);
        this.applyMatrix(_m1$3);
        return this;
      },
      rotateY: function(angle) {
        _m1$3.makeRotationY(angle);
        this.applyMatrix(_m1$3);
        return this;
      },
      rotateZ: function(angle) {
        _m1$3.makeRotationZ(angle);
        this.applyMatrix(_m1$3);
        return this;
      },
      translate: function(x, y2, z) {
        _m1$3.makeTranslation(x, y2, z);
        this.applyMatrix(_m1$3);
        return this;
      },
      scale: function(x, y2, z) {
        _m1$3.makeScale(x, y2, z);
        this.applyMatrix(_m1$3);
        return this;
      },
      lookAt: function(vector) {
        _obj$1.lookAt(vector);
        _obj$1.updateMatrix();
        this.applyMatrix(_obj$1.matrix);
        return this;
      },
      fromBufferGeometry: function(geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : void 0;
        var attributes = geometry.attributes;
        if (attributes.position === void 0) {
          console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
          return this;
        }
        var positions = attributes.position.array;
        var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
        var colors = attributes.color !== void 0 ? attributes.color.array : void 0;
        var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
        var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
        if (uvs2 !== void 0)
          this.faceVertexUvs[1] = [];
        for (var i3 = 0; i3 < positions.length; i3 += 3) {
          scope.vertices.push(new Vector3().fromArray(positions, i3));
          if (colors !== void 0) {
            scope.colors.push(new Color().fromArray(colors, i3));
          }
        }
        function addFace(a, b, c, materialIndex) {
          var vertexColors = colors === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
          var vertexNormals = normals === void 0 ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
          var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
          scope.faces.push(face);
          if (uvs !== void 0) {
            scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
          }
          if (uvs2 !== void 0) {
            scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
          }
        }
        var groups = geometry.groups;
        if (groups.length > 0) {
          for (var i3 = 0; i3 < groups.length; i3++) {
            var group = groups[i3];
            var start = group.start;
            var count = group.count;
            for (var j = start, jl = start + count; j < jl; j += 3) {
              if (indices !== void 0) {
                addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
              } else {
                addFace(j, j + 1, j + 2, group.materialIndex);
              }
            }
          }
        } else {
          if (indices !== void 0) {
            for (var i3 = 0; i3 < indices.length; i3 += 3) {
              addFace(indices[i3], indices[i3 + 1], indices[i3 + 2]);
            }
          } else {
            for (var i3 = 0; i3 < positions.length / 3; i3 += 3) {
              addFace(i3, i3 + 1, i3 + 2);
            }
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset$1).negate();
        this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
        return this;
      },
      normalize: function() {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s2 = radius === 0 ? 1 : 1 / radius;
        var matrix = new Matrix4();
        matrix.set(s2, 0, 0, -s2 * center.x, 0, s2, 0, -s2 * center.y, 0, 0, s2, -s2 * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
      },
      computeFaceNormals: function() {
        var cb = new Vector3(), ab = new Vector3();
        for (var f = 0, fl = this.faces.length; f < fl; f++) {
          var face = this.faces[f];
          var vA = this.vertices[face.a];
          var vB = this.vertices[face.b];
          var vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === void 0)
          areaWeighted = true;
        var v, vl, f, fl, face, vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new Vector3();
        }
        if (areaWeighted) {
          var vA, vB, vC;
          var cb = new Vector3(), ab = new Vector3();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vA = this.vertices[face.a];
            vB = this.vertices[face.b];
            vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          this.computeFaceNormals();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(vertices[face.a]);
            vertexNormals[1].copy(vertices[face.b]);
            vertexNormals[2].copy(vertices[face.c]);
          } else {
            vertexNormals[0] = vertices[face.a].clone();
            vertexNormals[1] = vertices[face.b].clone();
            vertexNormals[2] = vertices[face.c].clone();
          }
        }
        if (this.faces.length > 0) {
          this.normalsNeedUpdate = true;
        }
      },
      computeFlatVertexNormals: function() {
        var f, fl, face;
        this.computeFaceNormals();
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(face.normal);
            vertexNormals[1].copy(face.normal);
            vertexNormals[2].copy(face.normal);
          } else {
            vertexNormals[0] = face.normal.clone();
            vertexNormals[1] = face.normal.clone();
            vertexNormals[2] = face.normal.clone();
          }
        }
        if (this.faces.length > 0) {
          this.normalsNeedUpdate = true;
        }
      },
      computeMorphNormals: function() {
        var i3, il, f, fl, face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (i3 = 0, il = face.vertexNormals.length; i3 < il; i3++) {
            if (!face.__originalVertexNormals[i3]) {
              face.__originalVertexNormals[i3] = face.vertexNormals[i3].clone();
            } else {
              face.__originalVertexNormals[i3].copy(face.vertexNormals[i3]);
            }
          }
        }
        var tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for (i3 = 0, il = this.morphTargets.length; i3 < il; i3++) {
          if (!this.morphNormals[i3]) {
            this.morphNormals[i3] = {};
            this.morphNormals[i3].faceNormals = [];
            this.morphNormals[i3].vertexNormals = [];
            var dstNormalsFace = this.morphNormals[i3].faceNormals;
            var dstNormalsVertex = this.morphNormals[i3].vertexNormals;
            var faceNormal, vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
              faceNormal = new Vector3();
              vertexNormals = {
                a: new Vector3(),
                b: new Vector3(),
                c: new Vector3()
              };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          var morphNormals = this.morphNormals[i3];
          tmpGeo.vertices = this.morphTargets[i3].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          var faceNormal, vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            faceNormal = morphNormals.faceNormals[f];
            vertexNormals = morphNormals.vertexNormals[f];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
          console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
          return;
        }
        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === void 0)
          materialIndexOffset = 0;
        if (matrix !== void 0) {
          normalMatrix = new Matrix3().getNormalMatrix(matrix);
        }
        for (var i3 = 0, il = vertices2.length; i3 < il; i3++) {
          var vertex = vertices2[i3];
          var vertexCopy = vertex.clone();
          if (matrix !== void 0)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (var i3 = 0, il = colors2.length; i3 < il; i3++) {
          colors1.push(colors2[i3].clone());
        }
        for (i3 = 0, il = faces2.length; i3 < il; i3++) {
          var face = faces2[i3], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
          faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== void 0) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== void 0) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (var i3 = 0, il = geometry.faceVertexUvs.length; i3 < il; i3++) {
          var faceVertexUvs2 = geometry.faceVertexUvs[i3];
          if (this.faceVertexUvs[i3] === void 0)
            this.faceVertexUvs[i3] = [];
          for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
            var uvs2 = faceVertexUvs2[j], uvsCopy = [];
            for (var k = 0, kl = uvs2.length; k < kl; k++) {
              uvsCopy.push(uvs2[k].clone());
            }
            this.faceVertexUvs[i3].push(uvsCopy);
          }
        }
      },
      mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
          console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
          return;
        }
        if (mesh.matrixAutoUpdate)
          mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        var verticesMap = {};
        var unique = [], changes = [];
        var v, key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i3, il, face;
        var indices, j, jl;
        for (i3 = 0, il = this.vertices.length; i3 < il; i3++) {
          v = this.vertices[i3];
          key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
          if (verticesMap[key] === void 0) {
            verticesMap[key] = i3;
            unique.push(this.vertices[i3]);
            changes[i3] = unique.length - 1;
          } else {
            changes[i3] = changes[verticesMap[key]];
          }
        }
        var faceIndicesToRemove = [];
        for (i3 = 0, il = this.faces.length; i3 < il; i3++) {
          face = this.faces[i3];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          indices = [face.a, face.b, face.c];
          for (var n = 0; n < 3; n++) {
            if (indices[n] === indices[(n + 1) % 3]) {
              faceIndicesToRemove.push(i3);
              break;
            }
          }
        }
        for (i3 = faceIndicesToRemove.length - 1; i3 >= 0; i3--) {
          var idx = faceIndicesToRemove[i3];
          this.faces.splice(idx, 1);
          for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      setFromPoints: function(points) {
        this.vertices = [];
        for (var i3 = 0, l = points.length; i3 < l; i3++) {
          var point = points[i3];
          this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function() {
        var faces = this.faces;
        var length2 = faces.length;
        for (var i3 = 0; i3 < length2; i3++) {
          faces[i3]._id = i3;
        }
        function materialIndexSort(a, b) {
          return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length2)
          newUvs1 = [];
        if (uvs2 && uvs2.length === length2)
          newUvs2 = [];
        for (var i3 = 0; i3 < length2; i3++) {
          var id = faces[i3]._id;
          if (newUvs1)
            newUvs1.push(uvs1[id]);
          if (newUvs2)
            newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
          this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
          this.faceVertexUvs[1] = newUvs2;
      },
      toJSON: function() {
        var data = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.parameters !== void 0) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        var vertices = [];
        for (var i3 = 0; i3 < this.vertices.length; i3++) {
          var vertex = this.vertices[i3];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i3 = 0; i3 < this.faces.length; i3++) {
          var face = this.faces[i3];
          var hasMaterial = true;
          var hasFaceUv = false;
          var hasFaceVertexUv = this.faceVertexUvs[0][i3] !== void 0;
          var hasFaceNormal = face.normal.length() > 0;
          var hasFaceVertexNormal = face.vertexNormals.length > 0;
          var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          var hasFaceVertexColor = face.vertexColors.length > 0;
          var faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          faces.push(face.materialIndex);
          if (hasFaceVertexUv) {
            var faceVertexUvs = this.faceVertexUvs[0][i3];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            var vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            var vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value2, position, enabled) {
          return enabled ? value2 | 1 << position : value2 & ~(1 << position);
        }
        function getNormalIndex(normal) {
          var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash] !== void 0) {
            return normalsHash[hash];
          }
          normalsHash[hash] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash];
        }
        function getColorIndex(color) {
          var hash = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash] !== void 0) {
            return colorsHash[hash];
          }
          colorsHash[hash] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash];
        }
        function getUvIndex(uv) {
          var hash = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash] !== void 0) {
            return uvsHash[hash];
          }
          uvsHash[hash] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
          data.data.colors = colors;
        if (uvs.length > 0)
          data.data.uvs = [uvs];
        data.data.faces = faces;
        return data;
      },
      clone: function() {
        return new Geometry().copy(this);
      },
      copy: function(source) {
        var i3, il, j, jl, k, kl;
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.name = source.name;
        var vertices = source.vertices;
        for (i3 = 0, il = vertices.length; i3 < il; i3++) {
          this.vertices.push(vertices[i3].clone());
        }
        var colors = source.colors;
        for (i3 = 0, il = colors.length; i3 < il; i3++) {
          this.colors.push(colors[i3].clone());
        }
        var faces = source.faces;
        for (i3 = 0, il = faces.length; i3 < il; i3++) {
          this.faces.push(faces[i3].clone());
        }
        for (i3 = 0, il = source.faceVertexUvs.length; i3 < il; i3++) {
          var faceVertexUvs = source.faceVertexUvs[i3];
          if (this.faceVertexUvs[i3] === void 0) {
            this.faceVertexUvs[i3] = [];
          }
          for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
            var uvs = faceVertexUvs[j], uvsCopy = [];
            for (k = 0, kl = uvs.length; k < kl; k++) {
              var uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            this.faceVertexUvs[i3].push(uvsCopy);
          }
        }
        var morphTargets = source.morphTargets;
        for (i3 = 0, il = morphTargets.length; i3 < il; i3++) {
          var morphTarget = {};
          morphTarget.name = morphTargets[i3].name;
          if (morphTargets[i3].vertices !== void 0) {
            morphTarget.vertices = [];
            for (j = 0, jl = morphTargets[i3].vertices.length; j < jl; j++) {
              morphTarget.vertices.push(morphTargets[i3].vertices[j].clone());
            }
          }
          if (morphTargets[i3].normals !== void 0) {
            morphTarget.normals = [];
            for (j = 0, jl = morphTargets[i3].normals.length; j < jl; j++) {
              morphTarget.normals.push(morphTargets[i3].normals[j].clone());
            }
          }
          this.morphTargets.push(morphTarget);
        }
        var morphNormals = source.morphNormals;
        for (i3 = 0, il = morphNormals.length; i3 < il; i3++) {
          var morphNormal = {};
          if (morphNormals[i3].vertexNormals !== void 0) {
            morphNormal.vertexNormals = [];
            for (j = 0, jl = morphNormals[i3].vertexNormals.length; j < jl; j++) {
              var srcVertexNormal = morphNormals[i3].vertexNormals[j];
              var destVertexNormal = {};
              destVertexNormal.a = srcVertexNormal.a.clone();
              destVertexNormal.b = srcVertexNormal.b.clone();
              destVertexNormal.c = srcVertexNormal.c.clone();
              morphNormal.vertexNormals.push(destVertexNormal);
            }
          }
          if (morphNormals[i3].faceNormals !== void 0) {
            morphNormal.faceNormals = [];
            for (j = 0, jl = morphNormals[i3].faceNormals.length; j < jl; j++) {
              morphNormal.faceNormals.push(morphNormals[i3].faceNormals[j].clone());
            }
          }
          this.morphNormals.push(morphNormal);
        }
        var skinWeights = source.skinWeights;
        for (i3 = 0, il = skinWeights.length; i3 < il; i3++) {
          this.skinWeights.push(skinWeights[i3].clone());
        }
        var skinIndices = source.skinIndices;
        for (i3 = 0, il = skinIndices.length; i3 < il; i3++) {
          this.skinIndices.push(skinIndices[i3].clone());
        }
        var lineDistances = source.lineDistances;
        for (i3 = 0, il = lineDistances.length; i3 < il; i3++) {
          this.lineDistances.push(lineDistances[i3]);
        }
        var boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    class BoxGeometry extends Geometry {
      constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
      }
    }
    class BoxBufferGeometry extends BufferGeometry {
      constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
        super();
        this.type = "BoxBufferGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        var scope = this;
        width = width || 1;
        height = height || 1;
        depth = depth || 1;
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var numberOfVertices = 0;
        var groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          var segmentWidth = width2 / gridX;
          var segmentHeight = height2 / gridY;
          var widthHalf = width2 / 2;
          var heightHalf = height2 / 2;
          var depthHalf = depth2 / 2;
          var gridX1 = gridX + 1;
          var gridY1 = gridY + 1;
          var vertexCounter = 0;
          var groupCount = 0;
          var ix, iy;
          var vector = new Vector3();
          for (iy = 0; iy < gridY1; iy++) {
            var y2 = iy * segmentHeight - heightHalf;
            for (ix = 0; ix < gridX1; ix++) {
              var x = ix * segmentWidth - widthHalf;
              vector[u] = x * udir;
              vector[v] = y2 * vdir;
              vector[w2] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u] = 0;
              vector[v] = 0;
              vector[w2] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
              var a = numberOfVertices + ix + gridX1 * iy;
              var b = numberOfVertices + ix + gridX1 * (iy + 1);
              var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              var d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
    }
    function cloneUniforms(src) {
      var dst = {};
      for (var u in src) {
        dst[u] = {};
        for (var p in src[u]) {
          var property = src[u][p];
          if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
            dst[u][p] = property.clone();
          } else if (Array.isArray(property)) {
            dst[u][p] = property.slice();
          } else {
            dst[u][p] = property;
          }
        }
      }
      return dst;
    }
    function mergeUniforms(uniforms) {
      var merged = {};
      for (var u = 0; u < uniforms.length; u++) {
        var tmp2 = cloneUniforms(uniforms[u]);
        for (var p in tmp2) {
          merged[p] = tmp2[p];
        }
      }
      return merged;
    }
    var UniformsUtils = {
      clone: cloneUniforms,
      merge: mergeUniforms
    };
    var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    function ShaderMaterial(parameters) {
      Material.call(this);
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
      };
      this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      if (parameters !== void 0) {
        if (parameters.attributes !== void 0) {
          console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
      }
    }
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.extensions = source.extensions;
      return this;
    };
    ShaderMaterial.prototype.toJSON = function(meta) {
      var data = Material.prototype.toJSON.call(this, meta);
      data.uniforms = {};
      for (var name in this.uniforms) {
        var uniform = this.uniforms[name];
        var value2 = uniform.value;
        if (value2 && value2.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value2.toJSON(meta).uuid
          };
        } else if (value2 && value2.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value2.getHex()
          };
        } else if (value2 && value2.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value2.toArray()
          };
        } else if (value2 && value2.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value2.toArray()
          };
        } else if (value2 && value2.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value2.toArray()
          };
        } else if (value2 && value2.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value2.toArray()
          };
        } else if (value2 && value2.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value2.toArray()
          };
        } else {
          data.uniforms[name] = {
            value: value2
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      var extensions = {};
      for (var key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    };
    function Camera() {
      Object3D.call(this);
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
    }
    Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Camera,
      isCamera: true,
      copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      },
      getWorldDirection: function(target) {
        if (target === void 0) {
          console.warn("THREE.Camera: .getWorldDirection() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        var e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    });
    function PerspectiveCamera(fov2, aspect2, near, far) {
      Camera.call(this);
      this.type = "PerspectiveCamera";
      this.fov = fov2 !== void 0 ? fov2 : 50;
      this.zoom = 1;
      this.near = near !== void 0 ? near : 0.1;
      this.far = far !== void 0 ? far : 2000;
      this.focus = 10;
      this.aspect = aspect2 !== void 0 ? aspect2 : 1;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
      constructor: PerspectiveCamera,
      isPerspectiveCamera: true,
      copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      },
      setFocalLength: function(focalLength) {
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      },
      getFocalLength: function() {
        var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      },
      getEffectiveFOV: function() {
        return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
      },
      getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function(fullWidth, fullHeight, x, y2, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      },
      clearViewOffset: function() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function() {
        var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
        if (this.view !== null && this.view.enabled) {
          var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    });
    var fov = 90, aspect = 1;
    function CubeCamera(near, far, cubeResolution, options) {
      Object3D.call(this);
      this.type = "CubeCamera";
      var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);
      var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);
      var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);
      var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);
      var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);
      var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);
      options = options || {
        format: RGBFormat,
        magFilter: LinearFilter,
        minFilter: LinearFilter
      };
      this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
      this.renderTarget.texture.name = "CubeCamera";
      this.update = function(renderer, scene) {
        if (this.parent === null)
          this.updateMatrixWorld();
        var currentRenderTarget = renderer.getRenderTarget();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
      };
      this.clear = function(renderer, color, depth, stencil) {
        var currentRenderTarget = renderer.getRenderTarget();
        var renderTarget = this.renderTarget;
        for (var i3 = 0; i3 < 6; i3++) {
          renderer.setRenderTarget(renderTarget, i3);
          renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
      };
    }
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;
    function WebGLRenderTargetCube(width, height, options) {
      WebGLRenderTarget.call(this, width, height, options);
    }
    WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
    WebGLRenderTargetCube.prototype.fromEquirectangularTexture = function(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.format = texture.format;
      this.texture.encoding = texture.encoding;
      var scene = new Scene();
      var shader = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "	vWorldDirection = transformDirection( position, modelMatrix );", "	#include <begin_vertex>", "	#include <project_vertex>", "}"].join("\n"),
        fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "	vec3 direction = normalize( vWorldDirection );", "	vec2 sampleUV;", "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "	gl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
      };
      var material2 = new ShaderMaterial({
        type: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material2.uniforms.tEquirect.value = texture;
      var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material2);
      scene.add(mesh);
      var camera = new CubeCamera(1, 10, 1);
      camera.renderTarget = this;
      camera.renderTarget.texture.name = "CubeCameraTexture";
      camera.update(renderer, scene);
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    };
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1
      };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.needsUpdate = true;
    }
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;
    var _sphere$1 = new Sphere();
    var _vector$6 = new Vector3();
    function Frustum(p0, p1, p2, p3, p4, p5) {
      this.planes = [p0 !== void 0 ? p0 : new Plane(), p1 !== void 0 ? p1 : new Plane(), p2 !== void 0 ? p2 : new Plane(), p3 !== void 0 ? p3 : new Plane(), p4 !== void 0 ? p4 : new Plane(), p5 !== void 0 ? p5 : new Plane()];
    }
    Object.assign(Frustum.prototype, {
      set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(frustum) {
        var planes = this.planes;
        for (var i3 = 0; i3 < 6; i3++) {
          planes[i3].copy(frustum.planes[i3]);
        }
        return this;
      },
      setFromMatrix: function(m2) {
        var planes = this.planes;
        var me = m2.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function(object) {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$1);
      },
      intersectsSprite: function(sprite) {
        _sphere$1.center.set(0, 0, 0);
        _sphere$1.radius = 0.7071067811865476;
        _sphere$1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$1);
      },
      intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i3 = 0; i3 < 6; i3++) {
          var distance = planes[i3].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function(box) {
        var planes = this.planes;
        for (var i3 = 0; i3 < 6; i3++) {
          var plane = planes[i3];
          _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$6) < 0) {
            return false;
          }
        }
        return true;
      },
      containsPoint: function(point) {
        var planes = this.planes;
        for (var i3 = 0; i3 < 6; i3++) {
          if (planes[i3].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
    });
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
    var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    var begin_vertex = "vec3 transformed = vec3( position );";
    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha  = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif";
    var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
    var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
    var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	transformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
    var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		}  else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), 0.0 );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) { \n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    var fog_vertex = "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
    var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif";
    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n		  vec3 reflectVec = reflect( -viewDir, normal );\n		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = saturate( clearcoat );	material.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
    var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
    var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n	transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n	transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n	transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
    var normal_fragment_begin = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif";
    var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif";
    var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif";
    var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}";
    var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
    var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}";
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n	uniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSPARENCY\n		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}";
    var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var ShaderChunk = {
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      encodings_fragment,
      encodings_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_fragment,
      lightmap_pars_fragment,
      lights_lambert_vertex,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_normalmap_pars_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      uv2_pars_fragment,
      uv2_pars_vertex,
      uv2_vertex,
      worldpos_vertex,
      background_frag,
      background_vert,
      cube_frag,
      cube_vert,
      depth_frag,
      depth_vert,
      distanceRGBA_frag,
      distanceRGBA_vert,
      equirect_frag,
      equirect_vert,
      linedashed_frag,
      linedashed_vert,
      meshbasic_frag,
      meshbasic_vert,
      meshlambert_frag,
      meshlambert_vert,
      meshmatcap_frag,
      meshmatcap_vert,
      meshtoon_frag,
      meshtoon_vert,
      meshphong_frag,
      meshphong_vert,
      meshphysical_frag,
      meshphysical_vert,
      normal_frag,
      normal_vert,
      points_frag,
      points_vert,
      shadow_frag,
      shadow_vert,
      sprite_frag,
      sprite_vert
    };
    var UniformsLib = {
      common: {
        diffuse: {
          value: new Color(15658734)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        uvTransform: {
          value: new Matrix3()
        },
        uv2Transform: {
          value: new Matrix3()
        },
        alphaMap: {
          value: null
        }
      },
      specularmap: {
        specularMap: {
          value: null
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        refractionRatio: {
          value: 0.98
        },
        maxMipLevel: {
          value: 0
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalScale: {
          value: new Vector2(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 0.00025
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2000
        },
        fogColor: {
          value: new Color(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: {
          value: []
        },
        spotShadowMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        }
      },
      points: {
        diffuse: {
          value: new Color(15658734)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new Matrix3()
        }
      },
      sprite: {
        diffuse: {
          value: new Color(15658734)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new Vector2(0.5, 0.5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new Matrix3()
        }
      }
    };
    var ShaderLib = {
      basic: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
          emissive: {
            value: new Color(0)
          }
        }]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
          emissive: {
            value: new Color(0)
          },
          specular: {
            value: new Color(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
          emissive: {
            value: new Color(0)
          },
          roughness: {
            value: 0.5
          },
          metalness: {
            value: 0.5
          },
          envMapIntensity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
          emissive: {
            value: new Color(0)
          },
          specular: {
            value: new Color(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
          matcap: {
            value: null
          }
        }]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
      },
      sprite: {
        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new Matrix3()
          },
          t2D: {
            value: null
          }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      cube: {
        uniforms: mergeUniforms([UniformsLib.envmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
          referencePosition: {
            value: new Vector3()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1000
          }
        }]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
          color: {
            value: new Color(0)
          },
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        transparency: {
          value: 0
        },
        clearcoat: {
          value: 0
        },
        clearcoatRoughness: {
          value: 0
        },
        sheen: {
          value: new Color(0)
        },
        clearcoatNormalScale: {
          value: new Vector2(1, 1)
        },
        clearcoatNormalMap: {
          value: null
        }
      }]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    function WebGLAnimation() {
      var context = null;
      var isAnimating = false;
      var animationLoop = null;
      function onAnimationFrame(time2, frame) {
        if (isAnimating === false)
          return;
        animationLoop(time2, frame);
        context.requestAnimationFrame(onAnimationFrame);
      }
      return {
        start: function() {
          if (isAnimating === true)
            return;
          if (animationLoop === null)
            return;
          context.requestAnimationFrame(onAnimationFrame);
          isAnimating = true;
        },
        stop: function() {
          isAnimating = false;
        },
        setAnimationLoop: function(callback) {
          animationLoop = callback;
        },
        setContext: function(value2) {
          context = value2;
        }
      };
    }
    function WebGLAttributes(gl) {
      var buffers = new WeakMap();
      function createBuffer(attribute, bufferType) {
        var array = attribute.array;
        var usage = attribute.usage;
        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        var type = 5126;
        if (array instanceof Float32Array) {
          type = 5126;
        } else if (array instanceof Float64Array) {
          console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
        } else if (array instanceof Uint16Array) {
          type = 5123;
        } else if (array instanceof Int16Array) {
          type = 5122;
        } else if (array instanceof Uint32Array) {
          type = 5125;
        } else if (array instanceof Int32Array) {
          type = 5124;
        } else if (array instanceof Int8Array) {
          type = 5120;
        } else if (array instanceof Uint8Array) {
          type = 5121;
        }
        return {
          buffer,
          type,
          bytesPerElement: array.BYTES_PER_ELEMENT,
          version: attribute.version
        };
      }
      function updateBuffer(buffer, attribute, bufferType) {
        var array = attribute.array;
        var updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) {
          gl.bufferSubData(bufferType, 0, array);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
          updateRange.count = -1;
        }
      }
      function get(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        return buffers.get(attribute);
      }
      function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data) {
          gl.deleteBuffer(data.buffer);
          buffers.delete(attribute);
        }
      }
      function update2(attribute, bufferType) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data === void 0) {
          buffers.set(attribute, createBuffer(attribute, bufferType));
        } else if (data.version < attribute.version) {
          updateBuffer(data.buffer, attribute, bufferType);
          data.version = attribute.version;
        }
      }
      return {
        get,
        remove,
        update: update2
      };
    }
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
      Geometry.call(this);
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
      this.mergeVertices();
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
      BufferGeometry.call(this);
      this.type = "PlaneBufferGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      width = width || 1;
      height = height || 1;
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = Math.floor(widthSegments) || 1;
      var gridY = Math.floor(heightSegments) || 1;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;
      var ix, iy;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      for (iy = 0; iy < gridY1; iy++) {
        var y2 = iy * segment_height - height_half;
        for (ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices.push(x, -y2, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = ix + 1 + gridX1 * (iy + 1);
          var d2 = ix + 1 + gridX1 * iy;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
    function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
      var clearColor = new Color(0);
      var clearAlpha = 0;
      var planeMesh;
      var boxMesh;
      var currentBackground = null;
      var currentBackgroundVersion = 0;
      function render(renderList, scene, camera, forceClear) {
        var background = scene.background;
        var xr = renderer.xr;
        var session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === "additive") {
          background = null;
        }
        if (background === null) {
          setClear(clearColor, clearAlpha);
          currentBackground = null;
          currentBackgroundVersion = 0;
        } else if (background && background.isColor) {
          setClear(background, 1);
          forceClear = true;
          currentBackground = null;
          currentBackgroundVersion = 0;
        }
        if (renderer.autoClear || forceClear) {
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        }
        if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube || background.mapping === CubeUVReflectionMapping)) {
          if (boxMesh === void 0) {
            boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
              type: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.cube.uniforms),
              vertexShader: ShaderLib.cube.vertexShader,
              fragmentShader: ShaderLib.cube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            boxMesh.geometry.deleteAttribute("normal");
            boxMesh.geometry.deleteAttribute("uv");
            boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
              this.matrixWorld.copyPosition(camera2.matrixWorld);
            };
            Object.defineProperty(boxMesh.material, "envMap", {
              get: function() {
                return this.uniforms.envMap.value;
              }
            });
            objects.update(boxMesh);
          }
          var texture = background.isWebGLRenderTargetCube ? background.texture : background;
          boxMesh.material.uniforms.envMap.value = texture;
          boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;
          if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
            boxMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = texture.version;
          }
          renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
          if (planeMesh === void 0) {
            planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
              type: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            planeMesh.geometry.deleteAttribute("normal");
            Object.defineProperty(planeMesh.material, "map", {
              get: function() {
                return this.uniforms.t2D.value;
              }
            });
            objects.update(planeMesh);
          }
          planeMesh.material.uniforms.t2D.value = background;
          if (background.matrixAutoUpdate === true) {
            background.updateMatrix();
          }
          planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
          if (currentBackground !== background || currentBackgroundVersion !== background.version) {
            planeMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = background.version;
          }
          renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
      }
      function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
      }
      return {
        getClearColor: function() {
          return clearColor;
        },
        setClearColor: function(color, alpha) {
          clearColor.set(color);
          clearAlpha = alpha !== void 0 ? alpha : 1;
          setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
          return clearAlpha;
        },
        setClearAlpha: function(alpha) {
          clearAlpha = alpha;
          setClear(clearColor, clearAlpha);
        },
        render
      };
    }
    function WebGLBufferRenderer(gl, extensions, info, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      var mode;
      function setMode(value2) {
        mode = value2;
      }
      function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode);
      }
      function renderInstances(geometry, start, count, primcount) {
        if (primcount === 0)
          return;
        var extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawArraysInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawArraysInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.render = render;
      this.renderInstances = renderInstances;
    }
    function WebGLCapabilities(gl, extensions, parameters) {
      var maxAnisotropy;
      function getMaxAnisotropy() {
        if (maxAnisotropy !== void 0)
          return maxAnisotropy;
        var extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension !== null) {
          maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
          maxAnisotropy = 0;
        }
        return maxAnisotropy;
      }
      function getMaxPrecision(precision2) {
        if (precision2 === "highp") {
          if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
            return "highp";
          }
          precision2 = "mediump";
        }
        if (precision2 === "mediump") {
          if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
            return "mediump";
          }
        }
        return "lowp";
      }
      var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
      var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
      var maxPrecision = getMaxPrecision(precision);
      if (maxPrecision !== precision) {
        console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
        precision = maxPrecision;
      }
      var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
      var maxTextures = gl.getParameter(34930);
      var maxVertexTextures = gl.getParameter(35660);
      var maxTextureSize = gl.getParameter(3379);
      var maxCubemapSize = gl.getParameter(34076);
      var maxAttributes = gl.getParameter(34921);
      var maxVertexUniforms = gl.getParameter(36347);
      var maxVaryings = gl.getParameter(36348);
      var maxFragmentUniforms = gl.getParameter(36349);
      var vertexTextures = maxVertexTextures > 0;
      var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
      var floatVertexTextures = vertexTextures && floatFragmentTextures;
      var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
      return {
        isWebGL2,
        getMaxAnisotropy,
        getMaxPrecision,
        precision,
        logarithmicDepthBuffer,
        maxTextures,
        maxVertexTextures,
        maxTextureSize,
        maxCubemapSize,
        maxAttributes,
        maxVertexUniforms,
        maxVaryings,
        maxFragmentUniforms,
        vertexTextures,
        floatFragmentTextures,
        floatVertexTextures,
        maxSamples
      };
    }
    function WebGLClipping() {
      var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
      };
      this.uniform = uniform;
      this.numPlanes = 0;
      this.numIntersection = 0;
      this.init = function(planes, enableLocalClipping, camera) {
        var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
      };
      this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
      };
      this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
      };
      this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
          if (renderingShadows) {
            projectPlanes(null);
          } else {
            resetGlobalState();
          }
        } else {
          var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
          uniform.value = dstArray;
          dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
          for (var i3 = 0; i3 !== lGlobal; ++i3) {
            dstArray[i3] = globalState[i3];
          }
          cache.clippingState = dstArray;
          this.numIntersection = clipIntersection ? this.numPlanes : 0;
          this.numPlanes += nGlobal;
        }
      };
      function resetGlobalState() {
        if (uniform.value !== globalState) {
          uniform.value = globalState;
          uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
      }
      function projectPlanes(planes, camera, dstOffset, skipTransform) {
        var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
        if (nPlanes !== 0) {
          dstArray = uniform.value;
          if (skipTransform !== true || dstArray === null) {
            var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
            viewNormalMatrix.getNormalMatrix(viewMatrix);
            if (dstArray === null || dstArray.length < flatSize) {
              dstArray = new Float32Array(flatSize);
            }
            for (var i3 = 0, i4 = dstOffset; i3 !== nPlanes; ++i3, i4 += 4) {
              plane.copy(planes[i3]).applyMatrix4(viewMatrix, viewNormalMatrix);
              plane.normal.toArray(dstArray, i4);
              dstArray[i4 + 3] = plane.constant;
            }
          }
          uniform.value = dstArray;
          uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        return dstArray;
      }
    }
    function WebGLExtensions(gl) {
      var extensions = {};
      return {
        get: function(name) {
          if (extensions[name] !== void 0) {
            return extensions[name];
          }
          var extension;
          switch (name) {
            case "WEBGL_depth_texture":
              extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              extension = gl.getExtension(name);
          }
          if (extension === null) {
            console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
          }
          extensions[name] = extension;
          return extension;
        }
      };
    }
    function WebGLGeometries(gl, attributes, info) {
      var geometries = new WeakMap();
      var wireframeAttributes = new WeakMap();
      function onGeometryDispose(event2) {
        var geometry = event2.target;
        var buffergeometry = geometries.get(geometry);
        if (buffergeometry.index !== null) {
          attributes.remove(buffergeometry.index);
        }
        for (var name in buffergeometry.attributes) {
          attributes.remove(buffergeometry.attributes[name]);
        }
        geometry.removeEventListener("dispose", onGeometryDispose);
        geometries.delete(geometry);
        var attribute = wireframeAttributes.get(buffergeometry);
        if (attribute) {
          attributes.remove(attribute);
          wireframeAttributes.delete(buffergeometry);
        }
        info.memory.geometries--;
      }
      function get(object, geometry) {
        var buffergeometry = geometries.get(geometry);
        if (buffergeometry)
          return buffergeometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        if (geometry.isBufferGeometry) {
          buffergeometry = geometry;
        } else if (geometry.isGeometry) {
          if (geometry._bufferGeometry === void 0) {
            geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
          }
          buffergeometry = geometry._bufferGeometry;
        }
        geometries.set(geometry, buffergeometry);
        info.memory.geometries++;
        return buffergeometry;
      }
      function update2(geometry) {
        var index2 = geometry.index;
        var geometryAttributes = geometry.attributes;
        if (index2 !== null) {
          attributes.update(index2, 34963);
        }
        for (var name in geometryAttributes) {
          attributes.update(geometryAttributes[name], 34962);
        }
        var morphAttributes = geometry.morphAttributes;
        for (var name in morphAttributes) {
          var array = morphAttributes[name];
          for (var i3 = 0, l = array.length; i3 < l; i3++) {
            attributes.update(array[i3], 34962);
          }
        }
      }
      function updateWireframeAttribute(geometry) {
        var indices = [];
        var geometryIndex = geometry.index;
        var geometryPosition = geometry.attributes.position;
        var version = 0;
        if (geometryIndex !== null) {
          var array = geometryIndex.array;
          version = geometryIndex.version;
          for (var i3 = 0, l = array.length; i3 < l; i3 += 3) {
            var a = array[i3 + 0];
            var b = array[i3 + 1];
            var c = array[i3 + 2];
            indices.push(a, b, b, c, c, a);
          }
        } else {
          var array = geometryPosition.array;
          version = geometryPosition.version;
          for (var i3 = 0, l = array.length / 3 - 1; i3 < l; i3 += 3) {
            var a = i3 + 0;
            var b = i3 + 1;
            var c = i3 + 2;
            indices.push(a, b, b, c, c, a);
          }
        }
        var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;
        attributes.update(attribute, 34963);
        var previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute)
          attributes.remove(previousAttribute);
        wireframeAttributes.set(geometry, attribute);
      }
      function getWireframeAttribute(geometry) {
        var currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
          var geometryIndex = geometry.index;
          if (geometryIndex !== null) {
            if (currentAttribute.version < geometryIndex.version) {
              updateWireframeAttribute(geometry);
            }
          }
        } else {
          updateWireframeAttribute(geometry);
        }
        return wireframeAttributes.get(geometry);
      }
      return {
        get,
        update: update2,
        getWireframeAttribute
      };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      var mode;
      function setMode(value2) {
        mode = value2;
      }
      var type, bytesPerElement;
      function setIndex(value2) {
        type = value2.type;
        bytesPerElement = value2.bytesPerElement;
      }
      function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode);
      }
      function renderInstances(geometry, start, count, primcount) {
        if (primcount === 0)
          return;
        var extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawElementsInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawElementsInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render;
      this.renderInstances = renderInstances;
    }
    function WebGLInfo(gl) {
      var memory = {
        geometries: 0,
        textures: 0
      };
      var render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      function update2(count, mode, instanceCount) {
        instanceCount = instanceCount || 1;
        render.calls++;
        switch (mode) {
          case 4:
            render.triangles += instanceCount * (count / 3);
            break;
          case 1:
            render.lines += instanceCount * (count / 2);
            break;
          case 3:
            render.lines += instanceCount * (count - 1);
            break;
          case 2:
            render.lines += instanceCount * count;
            break;
          case 0:
            render.points += instanceCount * count;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
            break;
        }
      }
      function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
      }
      return {
        memory,
        render,
        programs: null,
        autoReset: true,
        reset,
        update: update2
      };
    }
    function absNumericalSort(a, b) {
      return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
      var influencesList = {};
      var morphInfluences = new Float32Array(8);
      function update2(object, geometry, material2, program) {
        var objectInfluences = object.morphTargetInfluences;
        var length2 = objectInfluences === void 0 ? 0 : objectInfluences.length;
        var influences = influencesList[geometry.id];
        if (influences === void 0) {
          influences = [];
          for (var i3 = 0; i3 < length2; i3++) {
            influences[i3] = [i3, 0];
          }
          influencesList[geometry.id] = influences;
        }
        var morphTargets = material2.morphTargets && geometry.morphAttributes.position;
        var morphNormals = material2.morphNormals && geometry.morphAttributes.normal;
        for (var i3 = 0; i3 < length2; i3++) {
          var influence = influences[i3];
          if (influence[1] !== 0) {
            if (morphTargets)
              geometry.deleteAttribute("morphTarget" + i3);
            if (morphNormals)
              geometry.deleteAttribute("morphNormal" + i3);
          }
        }
        for (var i3 = 0; i3 < length2; i3++) {
          var influence = influences[i3];
          influence[0] = i3;
          influence[1] = objectInfluences[i3];
        }
        influences.sort(absNumericalSort);
        var morphInfluencesSum = 0;
        for (var i3 = 0; i3 < 8; i3++) {
          var influence = influences[i3];
          if (influence) {
            var index2 = influence[0];
            var value2 = influence[1];
            if (value2) {
              if (morphTargets)
                geometry.setAttribute("morphTarget" + i3, morphTargets[index2]);
              if (morphNormals)
                geometry.setAttribute("morphNormal" + i3, morphNormals[index2]);
              morphInfluences[i3] = value2;
              morphInfluencesSum += value2;
              continue;
            }
          }
          morphInfluences[i3] = 0;
        }
        var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
      return {
        update: update2
      };
    }
    function WebGLObjects(gl, geometries, attributes, info) {
      var updateList = {};
      function update2(object) {
        var frame = info.render.frame;
        var geometry = object.geometry;
        var buffergeometry = geometries.get(object, geometry);
        if (updateList[buffergeometry.id] !== frame) {
          if (geometry.isGeometry) {
            buffergeometry.updateFromObject(object);
          }
          geometries.update(buffergeometry);
          updateList[buffergeometry.id] = frame;
        }
        if (object.isInstancedMesh) {
          attributes.update(object.instanceMatrix, 34962);
        }
        return buffergeometry;
      }
      function dispose() {
        updateList = {};
      }
      return {
        update: update2,
        dispose
      };
    }
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      format = format !== void 0 ? format : RGBFormat;
      Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.flipY = false;
    }
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, "images", {
      get: function() {
        return this.image;
      },
      set: function(value2) {
        this.image = value2;
      }
    });
    function DataTexture2DArray(data, width, height, depth) {
      Texture.call(this, null);
      this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
      };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.needsUpdate = true;
    }
    DataTexture2DArray.prototype = Object.create(Texture.prototype);
    DataTexture2DArray.prototype.constructor = DataTexture2DArray;
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    function DataTexture3D(data, width, height, depth) {
      Texture.call(this, null);
      this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
      };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.needsUpdate = true;
    }
    DataTexture3D.prototype = Object.create(Texture.prototype);
    DataTexture3D.prototype.constructor = DataTexture3D;
    DataTexture3D.prototype.isDataTexture3D = true;
    var emptyTexture = new Texture();
    var emptyTexture2dArray = new DataTexture2DArray();
    var emptyTexture3d = new DataTexture3D();
    var emptyCubeTexture = new CubeTexture();
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);
    var mat2array = new Float32Array(4);
    function flatten(array, nBlocks, blockSize) {
      var firstElem = array[0];
      if (firstElem <= 0 || firstElem > 0)
        return array;
      var n = nBlocks * blockSize, r = arrayCacheF32[n];
      if (r === void 0) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
      }
      if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for (var i3 = 1, offset = 0; i3 !== nBlocks; ++i3) {
          offset += blockSize;
          array[i3].toArray(r, offset);
        }
      }
      return r;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length)
        return false;
      for (var i3 = 0, l = a.length; i3 < l; i3++) {
        if (a[i3] !== b[i3])
          return false;
      }
      return true;
    }
    function copyArray(a, b) {
      for (var i3 = 0, l = b.length; i3 < l; i3++) {
        a[i3] = b[i3];
      }
    }
    function allocTexUnits(textures, n) {
      var r = arrayCacheI32[n];
      if (r === void 0) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
      }
      for (var i3 = 0; i3 !== n; ++i3)
        r[i3] = textures.allocateTextureUnit();
      return r;
    }
    function setValueV1f(gl, v) {
      var cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1f(this.addr, v);
      cache[0] = v;
    }
    function setValueV2f(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
          gl.uniform2f(this.addr, v.x, v.y);
          cache[0] = v.x;
          cache[1] = v.y;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueV3f(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
          gl.uniform3f(this.addr, v.x, v.y, v.z);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
        }
      } else if (v.r !== void 0) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
          gl.uniform3f(this.addr, v.r, v.g, v.b);
          cache[0] = v.r;
          cache[1] = v.g;
          cache[2] = v.b;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueV4f(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
          gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
          cache[3] = v.w;
        }
      } else {
        if (arraysEqual(cache, v))
          return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
      }
    }
    function setValueM2(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
      }
    }
    function setValueM3(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
      }
    }
    function setValueM4(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual(cache, v))
          return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
      } else {
        if (arraysEqual(cache, elements))
          return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
      }
    }
    function setValueT1(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTexture2D(v || emptyTexture, unit);
    }
    function setValueT2DArray1(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture2DArray(v || emptyTexture2dArray, unit);
    }
    function setValueT3D1(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture3D(v || emptyTexture3d, unit);
    }
    function setValueT6(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTextureCube(v || emptyCubeTexture, unit);
    }
    function setValueV1i(gl, v) {
      var cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1i(this.addr, v);
      cache[0] = v;
    }
    function setValueV2i(gl, v) {
      var cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform2iv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV3i(gl, v) {
      var cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform3iv(this.addr, v);
      copyArray(cache, v);
    }
    function setValueV4i(gl, v) {
      var cache = this.cache;
      if (arraysEqual(cache, v))
        return;
      gl.uniform4iv(this.addr, v);
      copyArray(cache, v);
    }
    function getSingularSetter(type) {
      switch (type) {
        case 5126:
          return setValueV1f;
        case 35664:
          return setValueV2f;
        case 35665:
          return setValueV3f;
        case 35666:
          return setValueV4f;
        case 35674:
          return setValueM2;
        case 35675:
          return setValueM3;
        case 35676:
          return setValueM4;
        case 35678:
        case 36198:
          return setValueT1;
        case 35679:
          return setValueT3D1;
        case 35680:
          return setValueT6;
        case 36289:
          return setValueT2DArray1;
        case 5124:
        case 35670:
          return setValueV1i;
        case 35667:
        case 35671:
          return setValueV2i;
        case 35668:
        case 35672:
          return setValueV3i;
        case 35669:
        case 35673:
          return setValueV4i;
      }
    }
    function setValueV1fArray(gl, v) {
      gl.uniform1fv(this.addr, v);
    }
    function setValueV1iArray(gl, v) {
      gl.uniform1iv(this.addr, v);
    }
    function setValueV2iArray(gl, v) {
      gl.uniform2iv(this.addr, v);
    }
    function setValueV3iArray(gl, v) {
      gl.uniform3iv(this.addr, v);
    }
    function setValueV4iArray(gl, v) {
      gl.uniform4iv(this.addr, v);
    }
    function setValueV2fArray(gl, v) {
      var data = flatten(v, this.size, 2);
      gl.uniform2fv(this.addr, data);
    }
    function setValueV3fArray(gl, v) {
      var data = flatten(v, this.size, 3);
      gl.uniform3fv(this.addr, data);
    }
    function setValueV4fArray(gl, v) {
      var data = flatten(v, this.size, 4);
      gl.uniform4fv(this.addr, data);
    }
    function setValueM2Array(gl, v) {
      var data = flatten(v, this.size, 4);
      gl.uniformMatrix2fv(this.addr, false, data);
    }
    function setValueM3Array(gl, v) {
      var data = flatten(v, this.size, 9);
      gl.uniformMatrix3fv(this.addr, false, data);
    }
    function setValueM4Array(gl, v) {
      var data = flatten(v, this.size, 16);
      gl.uniformMatrix4fv(this.addr, false, data);
    }
    function setValueT1Array(gl, v, textures) {
      var n = v.length;
      var units = allocTexUnits(textures, n);
      gl.uniform1iv(this.addr, units);
      for (var i3 = 0; i3 !== n; ++i3) {
        textures.safeSetTexture2D(v[i3] || emptyTexture, units[i3]);
      }
    }
    function setValueT6Array(gl, v, textures) {
      var n = v.length;
      var units = allocTexUnits(textures, n);
      gl.uniform1iv(this.addr, units);
      for (var i3 = 0; i3 !== n; ++i3) {
        textures.safeSetTextureCube(v[i3] || emptyCubeTexture, units[i3]);
      }
    }
    function getPureArraySetter(type) {
      switch (type) {
        case 5126:
          return setValueV1fArray;
        case 35664:
          return setValueV2fArray;
        case 35665:
          return setValueV3fArray;
        case 35666:
          return setValueV4fArray;
        case 35674:
          return setValueM2Array;
        case 35675:
          return setValueM3Array;
        case 35676:
          return setValueM4Array;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
          return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
          return setValueT6Array;
        case 5124:
        case 35670:
          return setValueV1iArray;
        case 35667:
        case 35671:
          return setValueV2iArray;
        case 35668:
        case 35672:
          return setValueV3iArray;
        case 35669:
        case 35673:
          return setValueV4iArray;
      }
    }
    function SingleUniform(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);
    }
    PureArrayUniform.prototype.updateCache = function(data) {
      var cache = this.cache;
      if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
      }
      copyArray(cache, data);
    };
    function StructuredUniform(id) {
      this.id = id;
      this.seq = [];
      this.map = {};
    }
    StructuredUniform.prototype.setValue = function(gl, value2, textures) {
      var seq = this.seq;
      for (var i3 = 0, n = seq.length; i3 !== n; ++i3) {
        var u = seq[i3];
        u.setValue(gl, value2[u.id], textures);
      }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    function addUniform(container, uniformObject) {
      container.seq.push(uniformObject);
      container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
      var path = activeInfo.name, pathLength = path.length;
      RePathPart.lastIndex = 0;
      while (true) {
        var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex)
          id = id | 0;
        if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
          addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
          break;
        } else {
          var map2 = container.map, next = map2[id];
          if (next === void 0) {
            next = new StructuredUniform(id);
            addUniform(container, next);
          }
          container = next;
        }
      }
    }
    function WebGLUniforms(gl, program) {
      this.seq = [];
      this.map = {};
      var n = gl.getProgramParameter(program, 35718);
      for (var i3 = 0; i3 < n; ++i3) {
        var info = gl.getActiveUniform(program, i3), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
      }
    }
    WebGLUniforms.prototype.setValue = function(gl, name, value2, textures) {
      var u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value2, textures);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
      var v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, textures) {
      for (var i3 = 0, n = seq.length; i3 !== n; ++i3) {
        var u = seq[i3], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
      var r = [];
      for (var i3 = 0, n = seq.length; i3 !== n; ++i3) {
        var u = seq[i3];
        if (u.id in values)
          r.push(u);
      }
      return r;
    };
    function WebGLShader(gl, type, string) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, string);
      gl.compileShader(shader);
      return shader;
    }
    var programIdCount = 0;
    function addLineNumbers(string) {
      var lines = string.split("\n");
      for (var i3 = 0; i3 < lines.length; i3++) {
        lines[i3] = i3 + 1 + ": " + lines[i3];
      }
      return lines.join("\n");
    }
    function getEncodingComponents(encoding) {
      switch (encoding) {
        case LinearEncoding:
          return ["Linear", "( value )"];
        case sRGBEncoding:
          return ["sRGB", "( value )"];
        case RGBEEncoding:
          return ["RGBE", "( value )"];
        case RGBM7Encoding:
          return ["RGBM", "( value, 7.0 )"];
        case RGBM16Encoding:
          return ["RGBM", "( value, 16.0 )"];
        case RGBDEncoding:
          return ["RGBD", "( value, 256.0 )"];
        case GammaEncoding:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case LogLuvEncoding:
          return ["LogLuv", "( value )"];
        default:
          throw new Error("unsupported encoding: " + encoding);
      }
    }
    function getShaderErrors(gl, shader, type) {
      var status2 = gl.getShaderParameter(shader, 35713);
      var log = gl.getShaderInfoLog(shader).trim();
      if (status2 && log === "")
        return "";
      var source = gl.getShaderSource(shader);
      return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
    }
    function getTexelDecodingFunction(functionName, encoding) {
      var components = getEncodingComponents(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
      var components = getEncodingComponents(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
      var toneMappingName;
      switch (toneMapping) {
        case LinearToneMapping:
          toneMappingName = "Linear";
          break;
        case ReinhardToneMapping:
          toneMappingName = "Reinhard";
          break;
        case Uncharted2ToneMapping:
          toneMappingName = "Uncharted2";
          break;
        case CineonToneMapping:
          toneMappingName = "OptimizedCineon";
          break;
        case ACESFilmicToneMapping:
          toneMappingName = "ACESFilmic";
          break;
        default:
          throw new Error("unsupported toneMapping: " + toneMapping);
      }
      return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
      extensions = extensions || {};
      var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
      return chunks.filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
      var chunks = [];
      for (var name in defines) {
        var value2 = defines[name];
        if (value2 === false)
          continue;
        chunks.push("#define " + name + " " + value2);
      }
      return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program) {
      var attributes = {};
      var n = gl.getProgramParameter(program, 35721);
      for (var i3 = 0; i3 < n; i3++) {
        var info = gl.getActiveAttrib(program, i3);
        var name = info.name;
        attributes[name] = gl.getAttribLocation(program, name);
      }
      return attributes;
    }
    function filterEmptyLine(string) {
      return string !== "";
    }
    function replaceLightNums(string, parameters) {
      return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
    }
    function replaceClippingPlaneNums(string, parameters) {
      return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
    }
    var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function resolveIncludes(string) {
      return string.replace(includePattern, includeReplacer);
    }
    function includeReplacer(match, include) {
      var string = ShaderChunk[include];
      if (string === void 0) {
        throw new Error("Can not resolve #include <" + include + ">");
      }
      return resolveIncludes(string);
    }
    var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function unrollLoops(string) {
      return string.replace(loopPattern, loopReplacer);
    }
    function loopReplacer(match, start, end, snippet) {
      var string = "";
      for (var i3 = parseInt(start); i3 < parseInt(end); i3++) {
        string += snippet.replace(/\[ i \]/g, "[ " + i3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i3);
      }
      return string;
    }
    function generatePrecision(parameters) {
      var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
      if (parameters.precision === "highp") {
        precisionstring += "\n#define HIGH_PRECISION";
      } else if (parameters.precision === "mediump") {
        precisionstring += "\n#define MEDIUM_PRECISION";
      } else if (parameters.precision === "lowp") {
        precisionstring += "\n#define LOW_PRECISION";
      }
      return precisionstring;
    }
    function generateShadowMapTypeDefine(parameters) {
      var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
      if (parameters.shadowMapType === PCFShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
      } else if (parameters.shadowMapType === PCFSoftShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
      } else if (parameters.shadowMapType === VSMShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
      }
      return shadowMapTypeDefine;
    }
    function generateEnvMapTypeDefine(parameters) {
      var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeReflectionMapping:
          case CubeRefractionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            break;
          case CubeUVReflectionMapping:
          case CubeUVRefractionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
            break;
          case EquirectangularReflectionMapping:
          case EquirectangularRefractionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
            break;
          case SphericalReflectionMapping:
            envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
            break;
        }
      }
      return envMapTypeDefine;
    }
    function generateEnvMapModeDefine(parameters) {
      var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeRefractionMapping:
          case EquirectangularRefractionMapping:
            envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            break;
        }
      }
      return envMapModeDefine;
    }
    function generateEnvMapBlendingDefine(parameters) {
      var envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
      if (parameters.envMap) {
        switch (parameters.combine) {
          case MultiplyOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case MixOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
            break;
          case AddOperation:
            envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            break;
        }
      }
      return envMapBlendingDefine;
    }
    function WebGLProgram(renderer, extensions, cacheKey, material2, shader, parameters) {
      var gl = renderer.getContext();
      var defines = material2.defines;
      var vertexShader6 = shader.vertexShader;
      var fragmentShader6 = shader.fragmentShader;
      var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
      var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
      var envMapModeDefine = generateEnvMapModeDefine(parameters);
      var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
      var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
      var customExtensions = parameters.isWebGL2 ? "" : generateExtensions(material2.extensions, parameters, extensions);
      var customDefines = generateDefines(defines);
      var program = gl.createProgram();
      var prefixVertex, prefixFragment;
      var numMultiviewViews = parameters.numMultiviewViews;
      if (material2.isRawShaderMaterial) {
        prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
        if (prefixVertex.length > 0) {
          prefixVertex += "\n";
        }
        prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
        if (prefixFragment.length > 0) {
          prefixFragment += "\n";
        }
      } else {
        prefixVertex = [generatePrecision(parameters), "#define SHADER_NAME " + shader.name, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && (parameters.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
        prefixFragment = [customExtensions, generatePrecision(parameters), "#define SHADER_NAME " + shader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.matcap ? "#define USE_MATCAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.sheen ? "#define USE_SHEEN" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && (parameters.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", ((material2.extensions ? material2.extensions.shaderTextureLOD : false) || parameters.envMap) && (parameters.isWebGL2 || extensions.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.lightMapEncoding ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material2.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n");
      }
      vertexShader6 = resolveIncludes(vertexShader6);
      vertexShader6 = replaceLightNums(vertexShader6, parameters);
      vertexShader6 = replaceClippingPlaneNums(vertexShader6, parameters);
      fragmentShader6 = resolveIncludes(fragmentShader6);
      fragmentShader6 = replaceLightNums(fragmentShader6, parameters);
      fragmentShader6 = replaceClippingPlaneNums(fragmentShader6, parameters);
      vertexShader6 = unrollLoops(vertexShader6);
      fragmentShader6 = unrollLoops(fragmentShader6);
      if (parameters.isWebGL2 && !material2.isRawShaderMaterial) {
        var isGLSL3ShaderMaterial = false;
        var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
        if (material2.isShaderMaterial && vertexShader6.match(versionRegex) !== null && fragmentShader6.match(versionRegex) !== null) {
          isGLSL3ShaderMaterial = true;
          vertexShader6 = vertexShader6.replace(versionRegex, "");
          fragmentShader6 = fragmentShader6.replace(versionRegex, "");
        }
        prefixVertex = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
        prefixFragment = ["#version 300 es\n", "#define varying in", isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;", isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
        if (numMultiviewViews > 0) {
          prefixVertex = prefixVertex.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + numMultiviewViews + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"));
          prefixVertex = prefixVertex.replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + numMultiviewViews + "];", "uniform mat4 projectionMatrices[" + numMultiviewViews + "];", "uniform mat4 viewMatrices[" + numMultiviewViews + "];", "uniform mat3 normalMatrices[" + numMultiviewViews + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n"));
          prefixFragment = prefixFragment.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"));
          prefixFragment = prefixFragment.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + numMultiviewViews + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"));
        }
      }
      var vertexGlsl = prefixVertex + vertexShader6;
      var fragmentGlsl = prefixFragment + fragmentShader6;
      var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
      var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      if (material2.index0AttributeName !== void 0) {
        gl.bindAttribLocation(program, 0, material2.index0AttributeName);
      } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, "position");
      }
      gl.linkProgram(program);
      if (renderer.debug.checkShaderErrors) {
        var programLog = gl.getProgramInfoLog(program).trim();
        var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
          runnable = false;
          var vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          var fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          this.diagnostics = {
            runnable,
            material: material2,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      var cachedUniforms;
      this.getUniforms = function() {
        if (cachedUniforms === void 0) {
          cachedUniforms = new WebGLUniforms(gl, program);
        }
        return cachedUniforms;
      };
      var cachedAttributes;
      this.getAttributes = function() {
        if (cachedAttributes === void 0) {
          cachedAttributes = fetchAttributeLocations(gl, program);
        }
        return cachedAttributes;
      };
      this.destroy = function() {
        gl.deleteProgram(program);
        this.program = void 0;
      };
      this.name = shader.name;
      this.id = programIdCount++;
      this.cacheKey = cacheKey;
      this.usedTimes = 1;
      this.program = program;
      this.vertexShader = glVertexShader;
      this.fragmentShader = glFragmentShader;
      this.numMultiviewViews = numMultiviewViews;
      return this;
    }
    function WebGLPrograms(renderer, extensions, capabilities) {
      var programs = [];
      var isWebGL2 = capabilities.isWebGL2;
      var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
      var floatVertexTextures = capabilities.floatVertexTextures;
      var precision = capabilities.precision;
      var maxVertexUniforms = capabilities.maxVertexUniforms;
      var vertexTextures = capabilities.vertexTextures;
      var shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      };
      var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];
      function allocateBones(object) {
        var skeleton = object.skeleton;
        var bones = skeleton.bones;
        if (floatVertexTextures) {
          return 1024;
        } else {
          var nVertexUniforms = maxVertexUniforms;
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = Math.min(nVertexMatrices, bones.length);
          if (maxBones < bones.length) {
            console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
            return 0;
          }
          return maxBones;
        }
      }
      function getTextureEncodingFromMap(map2) {
        var encoding;
        if (!map2) {
          encoding = LinearEncoding;
        } else if (map2.isTexture) {
          encoding = map2.encoding;
        } else if (map2.isWebGLRenderTarget) {
          console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
          encoding = map2.texture.encoding;
        }
        return encoding;
      }
      this.getParameters = function(material2, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
        var fog = scene.fog;
        var environment = material2.isMeshStandardMaterial ? scene.environment : null;
        var envMap = material2.envMap || environment;
        var shaderID = shaderIDs[material2.type];
        var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
        if (material2.precision !== null) {
          precision = capabilities.getMaxPrecision(material2.precision);
          if (precision !== material2.precision) {
            console.warn("THREE.WebGLProgram.getParameters:", material2.precision, "not supported, using", precision, "instead.");
          }
        }
        var currentRenderTarget = renderer.getRenderTarget();
        var numMultiviewViews = currentRenderTarget && currentRenderTarget.isWebGLMultiviewRenderTarget ? currentRenderTarget.numViews : 0;
        var parameters = {
          isWebGL2,
          shaderID,
          precision,
          instancing: object.isInstancedMesh === true,
          supportsVertexTextures: vertexTextures,
          numMultiviewViews,
          outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
          map: !!material2.map,
          mapEncoding: getTextureEncodingFromMap(material2.map),
          matcap: !!material2.matcap,
          matcapEncoding: getTextureEncodingFromMap(material2.matcap),
          envMap: !!envMap,
          envMapMode: envMap && envMap.mapping,
          envMapEncoding: getTextureEncodingFromMap(envMap),
          envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
          lightMap: !!material2.lightMap,
          lightMapEncoding: getTextureEncodingFromMap(material2.lightMap),
          aoMap: !!material2.aoMap,
          emissiveMap: !!material2.emissiveMap,
          emissiveMapEncoding: getTextureEncodingFromMap(material2.emissiveMap),
          bumpMap: !!material2.bumpMap,
          normalMap: !!material2.normalMap,
          objectSpaceNormalMap: material2.normalMapType === ObjectSpaceNormalMap,
          tangentSpaceNormalMap: material2.normalMapType === TangentSpaceNormalMap,
          clearcoatNormalMap: !!material2.clearcoatNormalMap,
          displacementMap: !!material2.displacementMap,
          roughnessMap: !!material2.roughnessMap,
          metalnessMap: !!material2.metalnessMap,
          specularMap: !!material2.specularMap,
          alphaMap: !!material2.alphaMap,
          gradientMap: !!material2.gradientMap,
          sheen: !!material2.sheen,
          combine: material2.combine,
          vertexTangents: material2.normalMap && material2.vertexTangents,
          vertexColors: material2.vertexColors,
          vertexUvs: !!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatNormalMap || !!material2.displacementMap,
          uvsVertexOnly: !(!!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatNormalMap) && !!material2.displacementMap,
          fog: !!fog,
          useFog: material2.fog,
          fogExp2: fog && fog.isFogExp2,
          flatShading: material2.flatShading,
          sizeAttenuation: material2.sizeAttenuation,
          logarithmicDepthBuffer,
          skinning: material2.skinning && maxBones > 0,
          maxBones,
          useVertexTexture: floatVertexTextures,
          morphTargets: material2.morphTargets,
          morphNormals: material2.morphNormals,
          maxMorphTargets: renderer.maxMorphTargets,
          maxMorphNormals: renderer.maxMorphNormals,
          numDirLights: lights.directional.length,
          numPointLights: lights.point.length,
          numSpotLights: lights.spot.length,
          numRectAreaLights: lights.rectArea.length,
          numHemiLights: lights.hemi.length,
          numDirLightShadows: lights.directionalShadowMap.length,
          numPointLightShadows: lights.pointShadowMap.length,
          numSpotLightShadows: lights.spotShadowMap.length,
          numClippingPlanes: nClipPlanes,
          numClipIntersection: nClipIntersection,
          dithering: material2.dithering,
          shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
          shadowMapType: renderer.shadowMap.type,
          toneMapping: material2.toneMapped ? renderer.toneMapping : NoToneMapping,
          physicallyCorrectLights: renderer.physicallyCorrectLights,
          premultipliedAlpha: material2.premultipliedAlpha,
          alphaTest: material2.alphaTest,
          doubleSided: material2.side === DoubleSide,
          flipSided: material2.side === BackSide,
          depthPacking: material2.depthPacking !== void 0 ? material2.depthPacking : false
        };
        return parameters;
      };
      this.getProgramCacheKey = function(material2, parameters) {
        var array = [];
        if (parameters.shaderID) {
          array.push(parameters.shaderID);
        } else {
          array.push(material2.fragmentShader);
          array.push(material2.vertexShader);
        }
        if (material2.defines !== void 0) {
          for (var name in material2.defines) {
            array.push(name);
            array.push(material2.defines[name]);
          }
        }
        if (material2.isRawShaderMaterial === void 0) {
          for (var i3 = 0; i3 < parameterNames.length; i3++) {
            array.push(parameters[parameterNames[i3]]);
          }
          array.push(renderer.outputEncoding);
          array.push(renderer.gammaFactor);
        }
        array.push(material2.onBeforeCompile.toString());
        return array.join();
      };
      this.acquireProgram = function(material2, shader, parameters, cacheKey) {
        var program;
        for (var p = 0, pl = programs.length; p < pl; p++) {
          var preexistingProgram = programs[p];
          if (preexistingProgram.cacheKey === cacheKey) {
            program = preexistingProgram;
            ++program.usedTimes;
            break;
          }
        }
        if (program === void 0) {
          program = new WebGLProgram(renderer, extensions, cacheKey, material2, shader, parameters);
          programs.push(program);
        }
        return program;
      };
      this.releaseProgram = function(program) {
        if (--program.usedTimes === 0) {
          var i3 = programs.indexOf(program);
          programs[i3] = programs[programs.length - 1];
          programs.pop();
          program.destroy();
        }
      };
      this.programs = programs;
    }
    function WebGLProperties() {
      var properties = new WeakMap();
      function get(object) {
        var map2 = properties.get(object);
        if (map2 === void 0) {
          map2 = {};
          properties.set(object, map2);
        }
        return map2;
      }
      function remove(object) {
        properties.delete(object);
      }
      function update2(object, key, value2) {
        properties.get(object)[key] = value2;
      }
      function dispose() {
        properties = new WeakMap();
      }
      return {
        get,
        remove,
        update: update2,
        dispose
      };
    }
    function painterSortStable(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.program !== b.program) {
        return a.program.id - b.program.id;
      } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
      } else if (a.z !== b.z) {
        return a.z - b.z;
      } else {
        return a.id - b.id;
      }
    }
    function reversePainterSortStable(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.z !== b.z) {
        return b.z - a.z;
      } else {
        return a.id - b.id;
      }
    }
    function WebGLRenderList() {
      var renderItems = [];
      var renderItemsIndex = 0;
      var opaque = [];
      var transparent = [];
      var defaultProgram = {
        id: -1
      };
      function init3() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
      }
      function getNextRenderItem(object, geometry, material2, groupOrder, z, group) {
        var renderItem = renderItems[renderItemsIndex];
        if (renderItem === void 0) {
          renderItem = {
            id: object.id,
            object,
            geometry,
            material: material2,
            program: material2.program || defaultProgram,
            groupOrder,
            renderOrder: object.renderOrder,
            z,
            group
          };
          renderItems[renderItemsIndex] = renderItem;
        } else {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material2;
          renderItem.program = material2.program || defaultProgram;
          renderItem.groupOrder = groupOrder;
          renderItem.renderOrder = object.renderOrder;
          renderItem.z = z;
          renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
      }
      function push(object, geometry, material2, groupOrder, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material2, groupOrder, z, group);
        (material2.transparent === true ? transparent : opaque).push(renderItem);
      }
      function unshift(object, geometry, material2, groupOrder, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material2, groupOrder, z, group);
        (material2.transparent === true ? transparent : opaque).unshift(renderItem);
      }
      function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1)
          opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1)
          transparent.sort(customTransparentSort || reversePainterSortStable);
      }
      return {
        opaque,
        transparent,
        init: init3,
        push,
        unshift,
        sort
      };
    }
    function WebGLRenderLists() {
      var lists = new WeakMap();
      function onSceneDispose(event2) {
        var scene = event2.target;
        scene.removeEventListener("dispose", onSceneDispose);
        lists.delete(scene);
      }
      function get(scene, camera) {
        var cameras = lists.get(scene);
        var list;
        if (cameras === void 0) {
          list = new WebGLRenderList();
          lists.set(scene, new WeakMap());
          lists.get(scene).set(camera, list);
          scene.addEventListener("dispose", onSceneDispose);
        } else {
          list = cameras.get(camera);
          if (list === void 0) {
            list = new WebGLRenderList();
            cameras.set(camera, list);
          }
        }
        return list;
      }
      function dispose() {
        lists = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    function UniformsCache() {
      var lights = {};
      return {
        get: function(light) {
          if (lights[light.id] !== void 0) {
            return lights[light.id];
          }
          var uniforms;
          switch (light.type) {
            case "DirectionalLight":
              uniforms = {
                direction: new Vector3(),
                color: new Color(),
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
              };
              break;
            case "SpotLight":
              uniforms = {
                position: new Vector3(),
                direction: new Vector3(),
                color: new Color(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
              };
              break;
            case "PointLight":
              uniforms = {
                position: new Vector3(),
                color: new Color(),
                distance: 0,
                decay: 0,
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2(),
                shadowCameraNear: 1,
                shadowCameraFar: 1000
              };
              break;
            case "HemisphereLight":
              uniforms = {
                direction: new Vector3(),
                skyColor: new Color(),
                groundColor: new Color()
              };
              break;
            case "RectAreaLight":
              uniforms = {
                color: new Color(),
                position: new Vector3(),
                halfWidth: new Vector3(),
                halfHeight: new Vector3()
              };
              break;
          }
          lights[light.id] = uniforms;
          return uniforms;
        }
      };
    }
    var nextVersion = 0;
    function shadowCastingLightsFirst(lightA, lightB) {
      return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
    }
    function WebGLLights() {
      var cache = new UniformsCache();
      var state = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      };
      for (var i3 = 0; i3 < 9; i3++)
        state.probe.push(new Vector3());
      var vector3 = new Vector3();
      var matrix4 = new Matrix4();
      var matrix42 = new Matrix4();
      function setup2(lights, shadows, camera) {
        var r = 0, g = 0, b = 0;
        for (var i4 = 0; i4 < 9; i4++)
          state.probe[i4].set(0, 0, 0);
        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var rectAreaLength = 0;
        var hemiLength = 0;
        var numDirectionalShadows = 0;
        var numPointShadows = 0;
        var numSpotShadows = 0;
        var viewMatrix = camera.matrixWorldInverse;
        lights.sort(shadowCastingLightsFirst);
        for (var i4 = 0, l = lights.length; i4 < l; i4++) {
          var light = lights[i4];
          var color = light.color;
          var intensity = light.intensity;
          var distance = light.distance;
          var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
          if (light.isAmbientLight) {
            r += color.r * intensity;
            g += color.g * intensity;
            b += color.b * intensity;
          } else if (light.isLightProbe) {
            for (var j = 0; j < 9; j++) {
              state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            }
          } else if (light.isDirectionalLight) {
            var uniforms = cache.get(light);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(vector3);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
              var shadow = light.shadow;
              uniforms.shadowBias = shadow.bias;
              uniforms.shadowRadius = shadow.radius;
              uniforms.shadowMapSize = shadow.mapSize;
              state.directionalShadowMap[directionalLength] = shadowMap;
              state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
              numDirectionalShadows++;
            }
            state.directional[directionalLength] = uniforms;
            directionalLength++;
          } else if (light.isSpotLight) {
            var uniforms = cache.get(light);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            uniforms.color.copy(color).multiplyScalar(intensity);
            uniforms.distance = distance;
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(vector3);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.coneCos = Math.cos(light.angle);
            uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
            uniforms.decay = light.decay;
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
              var shadow = light.shadow;
              uniforms.shadowBias = shadow.bias;
              uniforms.shadowRadius = shadow.radius;
              uniforms.shadowMapSize = shadow.mapSize;
              state.spotShadowMap[spotLength] = shadowMap;
              state.spotShadowMatrix[spotLength] = light.shadow.matrix;
              numSpotShadows++;
            }
            state.spot[spotLength] = uniforms;
            spotLength++;
          } else if (light.isRectAreaLight) {
            var uniforms = cache.get(light);
            uniforms.color.copy(color).multiplyScalar(intensity);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            matrix42.identity();
            matrix4.copy(light.matrixWorld);
            matrix4.premultiply(viewMatrix);
            matrix42.extractRotation(matrix4);
            uniforms.halfWidth.set(light.width * 0.5, 0, 0);
            uniforms.halfHeight.set(0, light.height * 0.5, 0);
            uniforms.halfWidth.applyMatrix4(matrix42);
            uniforms.halfHeight.applyMatrix4(matrix42);
            state.rectArea[rectAreaLength] = uniforms;
            rectAreaLength++;
          } else if (light.isPointLight) {
            var uniforms = cache.get(light);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
            uniforms.distance = light.distance;
            uniforms.decay = light.decay;
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
              var shadow = light.shadow;
              uniforms.shadowBias = shadow.bias;
              uniforms.shadowRadius = shadow.radius;
              uniforms.shadowMapSize = shadow.mapSize;
              uniforms.shadowCameraNear = shadow.camera.near;
              uniforms.shadowCameraFar = shadow.camera.far;
              state.pointShadowMap[pointLength] = shadowMap;
              state.pointShadowMatrix[pointLength] = light.shadow.matrix;
              numPointShadows++;
            }
            state.point[pointLength] = uniforms;
            pointLength++;
          } else if (light.isHemisphereLight) {
            var uniforms = cache.get(light);
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.direction.normalize();
            uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
            uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
            state.hemi[hemiLength] = uniforms;
            hemiLength++;
          }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        var hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
          state.directional.length = directionalLength;
          state.spot.length = spotLength;
          state.rectArea.length = rectAreaLength;
          state.point.length = pointLength;
          state.hemi.length = hemiLength;
          state.directionalShadowMap.length = numDirectionalShadows;
          state.pointShadowMap.length = numPointShadows;
          state.spotShadowMap.length = numSpotShadows;
          state.directionalShadowMatrix.length = numDirectionalShadows;
          state.pointShadowMatrix.length = numPointShadows;
          state.spotShadowMatrix.length = numSpotShadows;
          hash.directionalLength = directionalLength;
          hash.pointLength = pointLength;
          hash.spotLength = spotLength;
          hash.rectAreaLength = rectAreaLength;
          hash.hemiLength = hemiLength;
          hash.numDirectionalShadows = numDirectionalShadows;
          hash.numPointShadows = numPointShadows;
          hash.numSpotShadows = numSpotShadows;
          state.version = nextVersion++;
        }
      }
      return {
        setup: setup2,
        state
      };
    }
    function WebGLRenderState() {
      var lights = new WebGLLights();
      var lightsArray = [];
      var shadowsArray = [];
      function init3() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
      }
      function pushLight(light) {
        lightsArray.push(light);
      }
      function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
      }
      function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
      }
      var state = {
        lightsArray,
        shadowsArray,
        lights
      };
      return {
        init: init3,
        state,
        setupLights,
        pushLight,
        pushShadow
      };
    }
    function WebGLRenderStates() {
      var renderStates = new WeakMap();
      function onSceneDispose(event2) {
        var scene = event2.target;
        scene.removeEventListener("dispose", onSceneDispose);
        renderStates.delete(scene);
      }
      function get(scene, camera) {
        var renderState;
        if (renderStates.has(scene) === false) {
          renderState = new WebGLRenderState();
          renderStates.set(scene, new WeakMap());
          renderStates.get(scene).set(camera, renderState);
          scene.addEventListener("dispose", onSceneDispose);
        } else {
          if (renderStates.get(scene).has(camera) === false) {
            renderState = new WebGLRenderState();
            renderStates.get(scene).set(camera, renderState);
          } else {
            renderState = renderStates.get(scene).get(camera);
          }
        }
        return renderState;
      }
      function dispose() {
        renderStates = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    function MeshDepthMaterial(parameters) {
      Material.call(this);
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.skinning = false;
      this.morphTargets = false;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.setValues(parameters);
    }
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.depthPacking = source.depthPacking;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    function MeshDistanceMaterial(parameters) {
      Material.call(this);
      this.type = "MeshDistanceMaterial";
      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1000;
      this.skinning = false;
      this.morphTargets = false;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.fog = false;
      this.setValues(parameters);
    }
    MeshDistanceMaterial.prototype = Object.create(Material.prototype);
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    };
    var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
    function WebGLShadowMap(_renderer2, _objects, maxTextureSize) {
      var _frustum = new Frustum(), _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
      var shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
      };
      var shadowMaterialVertical = new ShaderMaterial({
        defines: {
          SAMPLE_RATE: 2 / 8,
          HALF_SAMPLE_RATE: 1 / 8
        },
        uniforms: {
          shadow_pass: {
            value: null
          },
          resolution: {
            value: new Vector2()
          },
          radius: {
            value: 4
          }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
      });
      var shadowMaterialHorizonal = shadowMaterialVertical.clone();
      shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
      var fullScreenTri = new BufferGeometry();
      fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
      var scope = this;
      this.enabled = false;
      this.autoUpdate = true;
      this.needsUpdate = false;
      this.type = PCFShadowMap;
      this.render = function(lights, scene, camera) {
        if (scope.enabled === false)
          return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
          return;
        if (lights.length === 0)
          return;
        var currentRenderTarget = _renderer2.getRenderTarget();
        var activeCubeFace = _renderer2.getActiveCubeFace();
        var activeMipmapLevel = _renderer2.getActiveMipmapLevel();
        var _state = _renderer2.state;
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        for (var i3 = 0, il = lights.length; i3 < il; i3++) {
          var light = lights[i3];
          var shadow = light.shadow;
          if (shadow === void 0) {
            console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
            continue;
          }
          _shadowMapSize.copy(shadow.mapSize);
          var shadowFrameExtents = shadow.getFrameExtents();
          _shadowMapSize.multiply(shadowFrameExtents);
          _viewportSize.copy(shadow.mapSize);
          if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
            console.warn("THREE.WebGLShadowMap:", light, "has shadow exceeding max texture size, reducing");
            if (_shadowMapSize.x > maxTextureSize) {
              _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
              _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
              shadow.mapSize.x = _viewportSize.x;
            }
            if (_shadowMapSize.y > maxTextureSize) {
              _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
              _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
              shadow.mapSize.y = _viewportSize.y;
            }
          }
          if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
            var pars = {
              minFilter: LinearFilter,
              magFilter: LinearFilter,
              format: RGBAFormat
            };
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.camera.updateProjectionMatrix();
          }
          if (shadow.map === null) {
            var pars = {
              minFilter: NearestFilter,
              magFilter: NearestFilter,
              format: RGBAFormat
            };
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.camera.updateProjectionMatrix();
          }
          _renderer2.setRenderTarget(shadow.map);
          _renderer2.clear();
          var viewportCount = shadow.getViewportCount();
          for (var vp = 0; vp < viewportCount; vp++) {
            var viewport = shadow.getViewport(vp);
            _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
            _state.viewport(_viewport);
            shadow.updateMatrices(light, vp);
            _frustum = shadow.getFrustum();
            renderObject(scene, camera, shadow.camera, light, this.type);
          }
          if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
            VSMPass(shadow, camera);
          }
        }
        scope.needsUpdate = false;
        _renderer2.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
      };
      function VSMPass(shadow, camera) {
        var geometry = _objects.update(fullScreenMesh);
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer2.setRenderTarget(shadow.mapPass);
        _renderer2.clear();
        _renderer2.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
        _renderer2.setRenderTarget(shadow.map);
        _renderer2.clear();
        _renderer2.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
      }
      function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        var index2 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        var material2 = _depthMaterials[index2];
        if (material2 === void 0) {
          material2 = new MeshDepthMaterial({
            depthPacking: RGBADepthPacking,
            morphTargets: useMorphing,
            skinning: useSkinning
          });
          _depthMaterials[index2] = material2;
        }
        return material2;
      }
      function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        var index2 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        var material2 = _distanceMaterials[index2];
        if (material2 === void 0) {
          material2 = new MeshDistanceMaterial({
            morphTargets: useMorphing,
            skinning: useSkinning
          });
          _distanceMaterials[index2] = material2;
        }
        return material2;
      }
      function getDepthMaterial(object, material2, light, shadowCameraNear, shadowCameraFar, type) {
        var geometry = object.geometry;
        var result = null;
        var getMaterialVariant = getDepthMaterialVariant;
        var customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
          getMaterialVariant = getDistanceMaterialVariant;
          customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === void 0) {
          var useMorphing = false;
          if (material2.morphTargets === true) {
            if (geometry.isBufferGeometry === true) {
              useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            } else if (geometry.isGeometry === true) {
              useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
            }
          }
          var useSkinning = false;
          if (object.isSkinnedMesh === true) {
            if (material2.skinning === true) {
              useSkinning = true;
            } else {
              console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
            }
          }
          var useInstancing = object.isInstancedMesh === true;
          result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else {
          result = customMaterial;
        }
        if (_renderer2.localClippingEnabled && material2.clipShadows === true && material2.clippingPlanes.length !== 0) {
          var keyA = result.uuid, keyB = material2.uuid;
          var materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          var cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
          }
          result = cachedMaterial;
        }
        result.visible = material2.visible;
        result.wireframe = material2.wireframe;
        if (type === VSMShadowMap) {
          result.side = material2.shadowSide !== null ? material2.shadowSide : material2.side;
        } else {
          result.side = material2.shadowSide !== null ? material2.shadowSide : shadowSide[material2.side];
        }
        result.clipShadows = material2.clipShadows;
        result.clippingPlanes = material2.clippingPlanes;
        result.clipIntersection = material2.clipIntersection;
        result.wireframeLinewidth = material2.wireframeLinewidth;
        result.linewidth = material2.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
          result.referencePosition.setFromMatrixPosition(light.matrixWorld);
          result.nearDistance = shadowCameraNear;
          result.farDistance = shadowCameraFar;
        }
        return result;
      }
      function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false)
          return;
        var visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
          if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
            object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
            var geometry = _objects.update(object);
            var material2 = object.material;
            if (Array.isArray(material2)) {
              var groups = geometry.groups;
              for (var k = 0, kl = groups.length; k < kl; k++) {
                var group = groups[k];
                var groupMaterial = material2[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                  _renderer2.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                }
              }
            } else if (material2.visible) {
              var depthMaterial = getDepthMaterial(object, material2, light, shadowCamera.near, shadowCamera.far, type);
              _renderer2.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
            }
          }
        }
        var children2 = object.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          renderObject(children2[i3], camera, shadowCamera, light, type);
        }
      }
    }
    function WebGLState(gl, extensions, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      function ColorBuffer() {
        var locked = false;
        var color = new Vector4();
        var currentColorMask = null;
        var currentColorClear = new Vector4(0, 0, 0, 0);
        return {
          setMask: function(colorMask) {
            if (currentColorMask !== colorMask && !locked) {
              gl.colorMask(colorMask, colorMask, colorMask, colorMask);
              currentColorMask = colorMask;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(r, g, b, a, premultipliedAlpha) {
            if (premultipliedAlpha === true) {
              r *= a;
              g *= a;
              b *= a;
            }
            color.set(r, g, b, a);
            if (currentColorClear.equals(color) === false) {
              gl.clearColor(r, g, b, a);
              currentColorClear.copy(color);
            }
          },
          reset: function() {
            locked = false;
            currentColorMask = null;
            currentColorClear.set(-1, 0, 0, 0);
          }
        };
      }
      function DepthBuffer() {
        var locked = false;
        var currentDepthMask = null;
        var currentDepthFunc = null;
        var currentDepthClear = null;
        return {
          setTest: function(depthTest) {
            if (depthTest) {
              enable2(2929);
            } else {
              disable2(2929);
            }
          },
          setMask: function(depthMask) {
            if (currentDepthMask !== depthMask && !locked) {
              gl.depthMask(depthMask);
              currentDepthMask = depthMask;
            }
          },
          setFunc: function(depthFunc) {
            if (currentDepthFunc !== depthFunc) {
              if (depthFunc) {
                switch (depthFunc) {
                  case NeverDepth:
                    gl.depthFunc(512);
                    break;
                  case AlwaysDepth:
                    gl.depthFunc(519);
                    break;
                  case LessDepth:
                    gl.depthFunc(513);
                    break;
                  case LessEqualDepth:
                    gl.depthFunc(515);
                    break;
                  case EqualDepth:
                    gl.depthFunc(514);
                    break;
                  case GreaterEqualDepth:
                    gl.depthFunc(518);
                    break;
                  case GreaterDepth:
                    gl.depthFunc(516);
                    break;
                  case NotEqualDepth:
                    gl.depthFunc(517);
                    break;
                  default:
                    gl.depthFunc(515);
                }
              } else {
                gl.depthFunc(515);
              }
              currentDepthFunc = depthFunc;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(depth) {
            if (currentDepthClear !== depth) {
              gl.clearDepth(depth);
              currentDepthClear = depth;
            }
          },
          reset: function() {
            locked = false;
            currentDepthMask = null;
            currentDepthFunc = null;
            currentDepthClear = null;
          }
        };
      }
      function StencilBuffer() {
        var locked = false;
        var currentStencilMask = null;
        var currentStencilFunc = null;
        var currentStencilRef = null;
        var currentStencilFuncMask = null;
        var currentStencilFail = null;
        var currentStencilZFail = null;
        var currentStencilZPass = null;
        var currentStencilClear = null;
        return {
          setTest: function(stencilTest) {
            if (!locked) {
              if (stencilTest) {
                enable2(2960);
              } else {
                disable2(2960);
              }
            }
          },
          setMask: function(stencilMask) {
            if (currentStencilMask !== stencilMask && !locked) {
              gl.stencilMask(stencilMask);
              currentStencilMask = stencilMask;
            }
          },
          setFunc: function(stencilFunc, stencilRef, stencilMask) {
            if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
              gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
              currentStencilFunc = stencilFunc;
              currentStencilRef = stencilRef;
              currentStencilFuncMask = stencilMask;
            }
          },
          setOp: function(stencilFail, stencilZFail, stencilZPass) {
            if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
              gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
              currentStencilFail = stencilFail;
              currentStencilZFail = stencilZFail;
              currentStencilZPass = stencilZPass;
            }
          },
          setLocked: function(lock) {
            locked = lock;
          },
          setClear: function(stencil) {
            if (currentStencilClear !== stencil) {
              gl.clearStencil(stencil);
              currentStencilClear = stencil;
            }
          },
          reset: function() {
            locked = false;
            currentStencilMask = null;
            currentStencilFunc = null;
            currentStencilRef = null;
            currentStencilFuncMask = null;
            currentStencilFail = null;
            currentStencilZFail = null;
            currentStencilZPass = null;
            currentStencilClear = null;
          }
        };
      }
      var colorBuffer = new ColorBuffer();
      var depthBuffer = new DepthBuffer();
      var stencilBuffer = new StencilBuffer();
      var maxVertexAttributes = gl.getParameter(34921);
      var newAttributes = new Uint8Array(maxVertexAttributes);
      var enabledAttributes = new Uint8Array(maxVertexAttributes);
      var attributeDivisors = new Uint8Array(maxVertexAttributes);
      var enabledCapabilities = {};
      var currentProgram = null;
      var currentBlendingEnabled = null;
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentPremultipledAlpha = false;
      var currentFlipSided = null;
      var currentCullFace = null;
      var currentLineWidth = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      var maxTextures = gl.getParameter(35661);
      var lineWidthAvailable = false;
      var version = 0;
      var glVersion = gl.getParameter(7938);
      if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
      } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
      }
      var currentTextureSlot = null;
      var currentBoundTextures = {};
      var currentScissor = new Vector4();
      var currentViewport = new Vector4();
      function createTexture(type, target, count) {
        var data = new Uint8Array(4);
        var texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for (var i3 = 0; i3 < count; i3++) {
          gl.texImage2D(target + i3, 0, 6408, 1, 1, 0, 6408, 5121, data);
        }
        return texture;
      }
      var emptyTextures = {};
      emptyTextures[3553] = createTexture(3553, 3553, 1);
      emptyTextures[34067] = createTexture(34067, 34069, 6);
      colorBuffer.setClear(0, 0, 0, 1);
      depthBuffer.setClear(1);
      stencilBuffer.setClear(0);
      enable2(2929);
      depthBuffer.setFunc(LessEqualDepth);
      setFlipSided(false);
      setCullFace(CullFaceBack);
      enable2(2884);
      setBlending(NoBlending);
      function initAttributes() {
        for (var i3 = 0, l = newAttributes.length; i3 < l; i3++) {
          newAttributes[i3] = 0;
        }
      }
      function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
      }
      function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
          var extension2 = isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
          extension2[isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
          attributeDivisors[attribute] = meshPerAttribute;
        }
      }
      function disableUnusedAttributes() {
        for (var i3 = 0, l = enabledAttributes.length; i3 !== l; ++i3) {
          if (enabledAttributes[i3] !== newAttributes[i3]) {
            gl.disableVertexAttribArray(i3);
            enabledAttributes[i3] = 0;
          }
        }
      }
      function enable2(id) {
        if (enabledCapabilities[id] !== true) {
          gl.enable(id);
          enabledCapabilities[id] = true;
        }
      }
      function disable2(id) {
        if (enabledCapabilities[id] !== false) {
          gl.disable(id);
          enabledCapabilities[id] = false;
        }
      }
      function useProgram(program) {
        if (currentProgram !== program) {
          gl.useProgram(program);
          currentProgram = program;
          return true;
        }
        return false;
      }
      var equationToGL = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
      };
      if (isWebGL2) {
        equationToGL[MinEquation] = 32775;
        equationToGL[MaxEquation] = 32776;
      } else {
        var extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
          equationToGL[MinEquation] = extension.MIN_EXT;
          equationToGL[MaxEquation] = extension.MAX_EXT;
        }
      }
      var factorToGL = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
      };
      function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
          if (currentBlendingEnabled) {
            disable2(3042);
            currentBlendingEnabled = false;
          }
          return;
        }
        if (!currentBlendingEnabled) {
          enable2(3042);
          currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
          if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
            if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
              gl.blendEquation(32774);
              currentBlendEquation = AddEquation;
              currentBlendEquationAlpha = AddEquation;
            }
            if (premultipliedAlpha) {
              switch (blending) {
                case NormalBlending:
                  gl.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case AdditiveBlending:
                  gl.blendFunc(1, 1);
                  break;
                case SubtractiveBlending:
                  gl.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case MultiplyBlending:
                  gl.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            } else {
              switch (blending) {
                case NormalBlending:
                  gl.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case AdditiveBlending:
                  gl.blendFunc(770, 1);
                  break;
                case SubtractiveBlending:
                  gl.blendFunc(0, 769);
                  break;
                case MultiplyBlending:
                  gl.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            }
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
          }
          return;
        }
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
          gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
          currentBlendEquation = blendEquation;
          currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
          gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
          currentBlendSrc = blendSrc;
          currentBlendDst = blendDst;
          currentBlendSrcAlpha = blendSrcAlpha;
          currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
      }
      function setMaterial(material2, frontFaceCW) {
        material2.side === DoubleSide ? disable2(2884) : enable2(2884);
        var flipSided = material2.side === BackSide;
        if (frontFaceCW)
          flipSided = !flipSided;
        setFlipSided(flipSided);
        material2.blending === NormalBlending && material2.transparent === false ? setBlending(NoBlending) : setBlending(material2.blending, material2.blendEquation, material2.blendSrc, material2.blendDst, material2.blendEquationAlpha, material2.blendSrcAlpha, material2.blendDstAlpha, material2.premultipliedAlpha);
        depthBuffer.setFunc(material2.depthFunc);
        depthBuffer.setTest(material2.depthTest);
        depthBuffer.setMask(material2.depthWrite);
        colorBuffer.setMask(material2.colorWrite);
        var stencilWrite = material2.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
          stencilBuffer.setMask(material2.stencilWriteMask);
          stencilBuffer.setFunc(material2.stencilFunc, material2.stencilRef, material2.stencilFuncMask);
          stencilBuffer.setOp(material2.stencilFail, material2.stencilZFail, material2.stencilZPass);
        }
        setPolygonOffset(material2.polygonOffset, material2.polygonOffsetFactor, material2.polygonOffsetUnits);
      }
      function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(2304);
          } else {
            gl.frontFace(2305);
          }
          currentFlipSided = flipSided;
        }
      }
      function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
          enable2(2884);
          if (cullFace !== currentCullFace) {
            if (cullFace === CullFaceBack) {
              gl.cullFace(1029);
            } else if (cullFace === CullFaceFront) {
              gl.cullFace(1028);
            } else {
              gl.cullFace(1032);
            }
          }
        } else {
          disable2(2884);
        }
        currentCullFace = cullFace;
      }
      function setLineWidth(width) {
        if (width !== currentLineWidth) {
          if (lineWidthAvailable)
            gl.lineWidth(width);
          currentLineWidth = width;
        }
      }
      function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
          enable2(32823);
          if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
            gl.polygonOffset(factor, units);
            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;
          }
        } else {
          disable2(32823);
        }
      }
      function setScissorTest(scissorTest) {
        if (scissorTest) {
          enable2(3089);
        } else {
          disable2(3089);
        }
      }
      function activeTexture(webglSlot) {
        if (webglSlot === void 0)
          webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
      }
      function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) {
          activeTexture();
        }
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === void 0) {
          boundTexture = {
            type: void 0,
            texture: void 0
          };
          currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      }
      function unbindTexture() {
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== void 0 && boundTexture.type !== void 0) {
          gl.bindTexture(boundTexture.type, null);
          boundTexture.type = void 0;
          boundTexture.texture = void 0;
        }
      }
      function compressedTexImage2D() {
        try {
          gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage2D() {
        try {
          gl.texImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage3D() {
        try {
          gl.texImage3D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function scissor(scissor2) {
        if (currentScissor.equals(scissor2) === false) {
          gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
          currentScissor.copy(scissor2);
        }
      }
      function viewport(viewport2) {
        if (currentViewport.equals(viewport2) === false) {
          gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
          currentViewport.copy(viewport2);
        }
      }
      function reset() {
        for (var i3 = 0; i3 < enabledAttributes.length; i3++) {
          if (enabledAttributes[i3] === 1) {
            gl.disableVertexAttribArray(i3);
            enabledAttributes[i3] = 0;
          }
        }
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
      }
      return {
        buffers: {
          color: colorBuffer,
          depth: depthBuffer,
          stencil: stencilBuffer
        },
        initAttributes,
        enableAttribute,
        enableAttributeAndDivisor,
        disableUnusedAttributes,
        enable: enable2,
        disable: disable2,
        useProgram,
        setBlending,
        setMaterial,
        setFlipSided,
        setCullFace,
        setLineWidth,
        setPolygonOffset,
        setScissorTest,
        activeTexture,
        bindTexture,
        unbindTexture,
        compressedTexImage2D,
        texImage2D,
        texImage3D,
        scissor,
        viewport,
        reset
      };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
      var isWebGL2 = capabilities.isWebGL2;
      var maxTextures = capabilities.maxTextures;
      var maxCubemapSize = capabilities.maxCubemapSize;
      var maxTextureSize = capabilities.maxTextureSize;
      var maxSamples = capabilities.maxSamples;
      var _videoTextures = new WeakMap();
      var _canvas2;
      var useOffscreenCanvas = false;
      try {
        useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
      } catch (err) {
      }
      function createCanvas(width, height) {
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        var scale = 1;
        if (image.width > maxSize || image.height > maxSize) {
          scale = maxSize / Math.max(image.width, image.height);
        }
        if (scale < 1 || needsPowerOfTwo === true) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
            var width = floor(scale * image.width);
            var height = floor(scale * image.height);
            if (_canvas2 === void 0)
              _canvas2 = createCanvas(width, height);
            var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, width, height);
            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
            return canvas;
          } else {
            if ("data" in image) {
              console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
            }
            return image;
          }
        }
        return image;
      }
      function isPowerOfTwo(image) {
        return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
      }
      function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2)
          return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      }
      function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      }
      function generateMipmap(target, texture, width, height) {
        _gl.generateMipmap(target);
        var textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
      }
      function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false)
          return glFormat;
        if (internalFormatName !== null) {
          if (_gl[internalFormatName] !== void 0)
            return _gl[internalFormatName];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
        }
        var internalFormat = glFormat;
        if (glFormat === 6403) {
          if (glType === 5126)
            internalFormat = 33326;
          if (glType === 5131)
            internalFormat = 33325;
          if (glType === 5121)
            internalFormat = 33321;
        }
        if (glFormat === 6407) {
          if (glType === 5126)
            internalFormat = 34837;
          if (glType === 5131)
            internalFormat = 34843;
          if (glType === 5121)
            internalFormat = 32849;
        }
        if (glFormat === 6408) {
          if (glType === 5126)
            internalFormat = 34836;
          if (glType === 5131)
            internalFormat = 34842;
          if (glType === 5121)
            internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
          extensions.get("EXT_color_buffer_float");
        } else if (internalFormat === 34843 || internalFormat === 34837) {
          console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
        }
        return internalFormat;
      }
      function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
          return 9728;
        }
        return 9729;
      }
      function onTextureDispose(event2) {
        var texture = event2.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) {
          _videoTextures.delete(texture);
        }
        info.memory.textures--;
      }
      function onRenderTargetDispose(event2) {
        var renderTarget = event2.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
      }
      function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === void 0)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
      }
      function deallocateRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget)
          return;
        if (textureProperties.__webglTexture !== void 0) {
          _gl.deleteTexture(textureProperties.__webglTexture);
        }
        if (renderTarget.depthTexture) {
          renderTarget.depthTexture.dispose();
        }
        if (renderTarget.isWebGLRenderTargetCube) {
          for (var i3 = 0; i3 < 6; i3++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i3]);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i3]);
          }
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        }
        if (renderTarget.isWebGLMultiviewRenderTarget) {
          _gl.deleteTexture(renderTargetProperties.__webglColorTexture);
          _gl.deleteTexture(renderTargetProperties.__webglDepthStencilTexture);
          info.memory.textures -= 2;
          for (var i3 = 0, il = renderTargetProperties.__webglViewFramebuffers.length; i3 < il; i3++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglViewFramebuffers[i3]);
          }
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
      }
      var textureUnits = 0;
      function resetTextureUnits() {
        textureUnits = 0;
      }
      function allocateTextureUnit() {
        var textureUnit = textureUnits;
        if (textureUnit >= maxTextures) {
          console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
        }
        textureUnits += 1;
        return textureUnit;
      }
      function setTexture2D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.isVideoTexture)
          updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          var image = texture.image;
          if (image === void 0) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
          } else if (image.complete === false) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          } else {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
      }
      function setTexture2DArray(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
      }
      function setTexture3D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
      }
      function setTextureCube(texture, slot) {
        if (texture.image.length !== 6)
          return;
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          initTexture(textureProperties, texture);
          state.activeTexture(33984 + slot);
          state.bindTexture(34067, textureProperties.__webglTexture);
          _gl.pixelStorei(37440, texture.flipY);
          var isCompressed = texture && texture.isCompressedTexture;
          var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
          var cubeImage = [];
          for (var i3 = 0; i3 < 6; i3++) {
            if (!isCompressed && !isDataTexture) {
              cubeImage[i3] = resizeImage(texture.image[i3], false, true, maxCubemapSize);
            } else {
              cubeImage[i3] = isDataTexture ? texture.image[i3].image : texture.image[i3];
            }
          }
          var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          setTextureParameters(34067, texture, supportsMips);
          var mipmaps;
          if (isCompressed) {
            for (var i3 = 0; i3 < 6; i3++) {
              mipmaps = cubeImage[i3].mipmaps;
              for (var j = 0; j < mipmaps.length; j++) {
                var mipmap = mipmaps[j];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                  if (glFormat !== null) {
                    state.compressedTexImage2D(34069 + i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                  }
                } else {
                  state.texImage2D(34069 + i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            mipmaps = texture.mipmaps;
            for (var i3 = 0; i3 < 6; i3++) {
              if (isDataTexture) {
                state.texImage2D(34069 + i3, 0, glInternalFormat, cubeImage[i3].width, cubeImage[i3].height, 0, glFormat, glType, cubeImage[i3].data);
                for (var j = 0; j < mipmaps.length; j++) {
                  var mipmap = mipmaps[j];
                  var mipmapImage = mipmap.image[i3].image;
                  state.texImage2D(34069 + i3, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(34069 + i3, 0, glInternalFormat, glFormat, glType, cubeImage[i3]);
                for (var j = 0; j < mipmaps.length; j++) {
                  var mipmap = mipmaps[j];
                  state.texImage2D(34069 + i3, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i3]);
                }
              }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(34067, texture, image.width, image.height);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        } else {
          state.activeTexture(33984 + slot);
          state.bindTexture(34067, textureProperties.__webglTexture);
        }
      }
      function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, properties.get(texture).__webglTexture);
      }
      var wrappingToGL = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
      };
      var filterToGL = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
      };
      function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
          _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
          _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
          }
          _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
          _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
          _gl.texParameteri(textureType, 10242, 33071);
          _gl.texParameteri(textureType, 10243, 33071);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, 33071);
          }
          if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
          }
          _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
          if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
          }
        }
        var extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension) {
          if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
            return;
          if (texture.type === HalfFloatType && (isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null)
            return;
          if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === void 0) {
          textureProperties.__webglInit = true;
          texture.addEventListener("dispose", onTextureDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          info.memory.textures++;
        }
      }
      function uploadTexture(textureProperties, texture, slot) {
        var textureType = 3553;
        if (texture.isDataTexture2DArray)
          textureType = 35866;
        if (texture.isDataTexture3D)
          textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        var supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        var mipmap, mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (texture.type === FloatType) {
            if (isWebGL2 === false)
              throw new Error("Float Depth Texture only supported in WebGL2.0");
            glInternalFormat = 36012;
          } else if (isWebGL2) {
            glInternalFormat = 33189;
          }
          if (texture.format === DepthFormat && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedShortType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            for (var i3 = 0, il = mipmaps.length; i3 < il; i3++) {
              mipmap = mipmaps[i3];
              state.texImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
          }
        } else if (texture.isCompressedTexture) {
          for (var i3 = 0, il = mipmaps.length; i3 < il; i3++) {
            mipmap = mipmaps[i3];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              state.texImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            for (var i3 = 0, il = mipmaps.length; i3 < il; i3++) {
              mipmap = mipmaps[i3];
              state.texImage2D(3553, i3, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        var glFormat = utils.convert(renderTarget.texture.format);
        var glType = utils.convert(renderTarget.texture.type);
        var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(36160, null);
      }
      function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          if (isMultisample) {
            var samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          if (isMultisample) {
            var samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
          var glFormat = utils.convert(renderTarget.texture.format);
          var glType = utils.convert(renderTarget.texture.type);
          var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          if (isMultisample) {
            var samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
        _gl.bindRenderbuffer(36161, null);
      }
      function setupDepthTexture(framebuffer, renderTarget) {
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        if (isCube)
          throw new Error("Depth Texture with cube render targets is not supported");
        _gl.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        }
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
          renderTarget.depthTexture.image.width = renderTarget.width;
          renderTarget.depthTexture.image.height = renderTarget.height;
          renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        } else {
          throw new Error("Unknown depthTexture format");
        }
      }
      function setupDepthRenderbuffer(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var isCube = renderTarget.isWebGLRenderTargetCube === true;
        if (renderTarget.depthTexture) {
          if (isCube)
            throw new Error("target.depthTexture not supported in Cube render targets");
          setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else {
          if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for (var i3 = 0; i3 < 6; i3++) {
              _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i3]);
              renderTargetProperties.__webglDepthbuffer[i3] = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i3], renderTarget);
            }
          } else {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
          }
        }
        _gl.bindFramebuffer(36160, null);
      }
      function setupRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        var isCube = renderTarget.isWebGLRenderTargetCube === true;
        var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        var isMultiview = renderTarget.isWebGLMultiviewRenderTarget === true;
        var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (isCube) {
          renderTargetProperties.__webglFramebuffer = [];
          for (var i3 = 0; i3 < 6; i3++) {
            renderTargetProperties.__webglFramebuffer[i3] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
          if (isMultisample) {
            if (isWebGL2) {
              renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
              renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
              _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
              var glFormat = utils.convert(renderTarget.texture.format);
              var glType = utils.convert(renderTarget.texture.type);
              var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
              var samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
              _gl.bindRenderbuffer(36161, null);
              if (renderTarget.depthBuffer) {
                renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
              }
              _gl.bindFramebuffer(36160, null);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          } else if (isMultiview) {
            var width = renderTarget.width;
            var height = renderTarget.height;
            var numViews = renderTarget.numViews;
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            var ext = extensions.get("OVR_multiview2");
            info.memory.textures += 2;
            var colorTexture = _gl.createTexture();
            _gl.bindTexture(35866, colorTexture);
            _gl.texParameteri(35866, 10240, 9728);
            _gl.texParameteri(35866, 10241, 9728);
            _gl.texImage3D(35866, 0, 32856, width, height, numViews, 0, 6408, 5121, null);
            ext.framebufferTextureMultiviewOVR(36160, 36064, colorTexture, 0, 0, numViews);
            var depthStencilTexture = _gl.createTexture();
            _gl.bindTexture(35866, depthStencilTexture);
            _gl.texParameteri(35866, 10240, 9728);
            _gl.texParameteri(35866, 10241, 9728);
            _gl.texImage3D(35866, 0, 35056, width, height, numViews, 0, 34041, 34042, null);
            ext.framebufferTextureMultiviewOVR(36160, 33306, depthStencilTexture, 0, 0, numViews);
            var viewFramebuffers = new Array(numViews);
            for (var i3 = 0; i3 < numViews; ++i3) {
              viewFramebuffers[i3] = _gl.createFramebuffer();
              _gl.bindFramebuffer(36160, viewFramebuffers[i3]);
              _gl.framebufferTextureLayer(36160, 36064, colorTexture, 0, i3);
            }
            renderTargetProperties.__webglColorTexture = colorTexture;
            renderTargetProperties.__webglDepthStencilTexture = depthStencilTexture;
            renderTargetProperties.__webglViewFramebuffers = viewFramebuffers;
            _gl.bindFramebuffer(36160, null);
            _gl.bindTexture(35866, null);
          }
        }
        if (isCube) {
          state.bindTexture(34067, textureProperties.__webglTexture);
          setTextureParameters(34067, renderTarget.texture, supportsMips);
          for (var i3 = 0; i3 < 6; i3++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i3], renderTarget, 36064, 34069 + i3);
          }
          if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
            generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
          }
          state.bindTexture(34067, null);
        } else if (!isMultiview) {
          state.bindTexture(3553, textureProperties.__webglTexture);
          setTextureParameters(3553, renderTarget.texture, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
          if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
            generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
          }
          state.bindTexture(3553, null);
        }
        if (renderTarget.depthBuffer) {
          setupDepthRenderbuffer(renderTarget);
        }
      }
      function updateRenderTargetMipmap(renderTarget) {
        var texture = renderTarget.texture;
        var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
          var webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target, texture, renderTarget.width, renderTarget.height);
          state.bindTexture(target, null);
        }
      }
      function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
          if (isWebGL2) {
            var renderTargetProperties = properties.get(renderTarget);
            _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
            var width = renderTarget.width;
            var height = renderTarget.height;
            var mask = 16384;
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
      }
      function updateVideoTexture(texture) {
        var frame = info.render.frame;
        if (_videoTextures.get(texture) !== frame) {
          _videoTextures.set(texture, frame);
          texture.update();
        }
      }
      var warnedTexture2D = false;
      var warnedTextureCube = false;
      function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
          if (warnedTexture2D === false) {
            console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
            warnedTexture2D = true;
          }
          texture = texture.texture;
        }
        setTexture2D(texture, slot);
      }
      function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLRenderTargetCube) {
          if (warnedTextureCube === false) {
            console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
            warnedTextureCube = true;
          }
          texture = texture.texture;
        }
        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
          setTextureCube(texture, slot);
        } else {
          setTextureCubeDynamic(texture, slot);
        }
      }
      this.allocateTextureUnit = allocateTextureUnit;
      this.resetTextureUnits = resetTextureUnits;
      this.setTexture2D = setTexture2D;
      this.setTexture2DArray = setTexture2DArray;
      this.setTexture3D = setTexture3D;
      this.setTextureCube = setTextureCube;
      this.setTextureCubeDynamic = setTextureCubeDynamic;
      this.setupRenderTarget = setupRenderTarget;
      this.updateRenderTargetMipmap = updateRenderTargetMipmap;
      this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
      this.safeSetTexture2D = safeSetTexture2D;
      this.safeSetTextureCube = safeSetTextureCube;
    }
    function WebGLUtils(gl, extensions, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      function convert(p) {
        var extension;
        if (p === UnsignedByteType)
          return 5121;
        if (p === UnsignedShort4444Type)
          return 32819;
        if (p === UnsignedShort5551Type)
          return 32820;
        if (p === UnsignedShort565Type)
          return 33635;
        if (p === ByteType)
          return 5120;
        if (p === ShortType)
          return 5122;
        if (p === UnsignedShortType)
          return 5123;
        if (p === IntType)
          return 5124;
        if (p === UnsignedIntType)
          return 5125;
        if (p === FloatType)
          return 5126;
        if (p === HalfFloatType) {
          if (isWebGL2)
            return 5131;
          extension = extensions.get("OES_texture_half_float");
          if (extension !== null) {
            return extension.HALF_FLOAT_OES;
          } else {
            return null;
          }
        }
        if (p === AlphaFormat)
          return 6406;
        if (p === RGBFormat)
          return 6407;
        if (p === RGBAFormat)
          return 6408;
        if (p === LuminanceFormat)
          return 6409;
        if (p === LuminanceAlphaFormat)
          return 6410;
        if (p === DepthFormat)
          return 6402;
        if (p === DepthStencilFormat)
          return 34041;
        if (p === RedFormat)
          return 6403;
        if (p === RedIntegerFormat)
          return 36244;
        if (p === RGFormat)
          return 33319;
        if (p === RGIntegerFormat)
          return 33320;
        if (p === RGBIntegerFormat)
          return 36248;
        if (p === RGBAIntegerFormat)
          return 36249;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
          extension = extensions.get("WEBGL_compressed_texture_pvrtc");
          if (extension !== null) {
            if (p === RGB_PVRTC_4BPPV1_Format)
              return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === RGB_PVRTC_2BPPV1_Format)
              return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === RGBA_PVRTC_4BPPV1_Format)
              return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === RGBA_PVRTC_2BPPV1_Format)
              return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else {
            return null;
          }
        }
        if (p === RGB_ETC1_Format) {
          extension = extensions.get("WEBGL_compressed_texture_etc1");
          if (extension !== null) {
            return extension.COMPRESSED_RGB_ETC1_WEBGL;
          } else {
            return null;
          }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
          extension = extensions.get("WEBGL_compressed_texture_astc");
          if (extension !== null) {
            return p;
          } else {
            return null;
          }
        }
        if (p === UnsignedInt248Type) {
          if (isWebGL2)
            return 34042;
          extension = extensions.get("WEBGL_depth_texture");
          if (extension !== null) {
            return extension.UNSIGNED_INT_24_8_WEBGL;
          } else {
            return null;
          }
        }
      }
      return {
        convert
      };
    }
    function WebGLMultiviewRenderTarget(width, height, numViews, options) {
      WebGLRenderTarget.call(this, width, height, options);
      this.depthBuffer = false;
      this.stencilBuffer = false;
      this.numViews = numViews;
    }
    WebGLMultiviewRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
      constructor: WebGLMultiviewRenderTarget,
      isWebGLMultiviewRenderTarget: true,
      copy: function(source) {
        WebGLRenderTarget.prototype.copy.call(this, source);
        this.numViews = source.numViews;
        return this;
      },
      setNumViews: function(numViews) {
        if (this.numViews !== numViews) {
          this.numViews = numViews;
          this.dispose();
        }
        return this;
      }
    });
    function WebGLMultiview(renderer, gl) {
      var DEFAULT_NUMVIEWS = 2;
      var extensions = renderer.extensions;
      var properties = renderer.properties;
      var renderTarget, currentRenderTarget;
      var mat3, mat4, cameraArray, renderSize;
      var available;
      var maxNumViews = 0;
      function isAvailable() {
        if (available === void 0) {
          var extension = extensions.get("OVR_multiview2");
          available = extension !== null && gl.getContextAttributes().antialias === false;
          if (available) {
            maxNumViews = gl.getParameter(extension.MAX_VIEWS_OVR);
            renderTarget = new WebGLMultiviewRenderTarget(0, 0, DEFAULT_NUMVIEWS);
            renderSize = new Vector2();
            mat4 = [];
            mat3 = [];
            cameraArray = [];
            for (var i3 = 0; i3 < maxNumViews; i3++) {
              mat4[i3] = new Matrix4();
              mat3[i3] = new Matrix3();
            }
          }
        }
        return available;
      }
      function getCameraArray(camera) {
        if (camera.isArrayCamera)
          return camera.cameras;
        cameraArray[0] = camera;
        return cameraArray;
      }
      function updateCameraProjectionMatricesUniform(camera, uniforms) {
        var cameras = getCameraArray(camera);
        for (var i3 = 0; i3 < cameras.length; i3++) {
          mat4[i3].copy(cameras[i3].projectionMatrix);
        }
        uniforms.setValue(gl, "projectionMatrices", mat4);
      }
      function updateCameraViewMatricesUniform(camera, uniforms) {
        var cameras = getCameraArray(camera);
        for (var i3 = 0; i3 < cameras.length; i3++) {
          mat4[i3].copy(cameras[i3].matrixWorldInverse);
        }
        uniforms.setValue(gl, "viewMatrices", mat4);
      }
      function updateObjectMatricesUniforms(object, camera, uniforms) {
        var cameras = getCameraArray(camera);
        for (var i3 = 0; i3 < cameras.length; i3++) {
          mat4[i3].multiplyMatrices(cameras[i3].matrixWorldInverse, object.matrixWorld);
          mat3[i3].getNormalMatrix(mat4[i3]);
        }
        uniforms.setValue(gl, "modelViewMatrices", mat4);
        uniforms.setValue(gl, "normalMatrices", mat3);
      }
      function isMultiviewCompatible(camera) {
        if (camera.isArrayCamera === void 0)
          return true;
        var cameras = camera.cameras;
        if (cameras.length > maxNumViews)
          return false;
        for (var i3 = 1, il = cameras.length; i3 < il; i3++) {
          if (cameras[0].viewport.z !== cameras[i3].viewport.z || cameras[0].viewport.w !== cameras[i3].viewport.w)
            return false;
        }
        return true;
      }
      function resizeRenderTarget(camera) {
        if (currentRenderTarget) {
          renderSize.set(currentRenderTarget.width, currentRenderTarget.height);
        } else {
          renderer.getDrawingBufferSize(renderSize);
        }
        if (camera.isArrayCamera) {
          var viewport = camera.cameras[0].viewport;
          renderTarget.setSize(viewport.z, viewport.w);
          renderTarget.setNumViews(camera.cameras.length);
        } else {
          renderTarget.setSize(renderSize.x, renderSize.y);
          renderTarget.setNumViews(DEFAULT_NUMVIEWS);
        }
      }
      function attachCamera(camera) {
        if (isMultiviewCompatible(camera) === false)
          return;
        currentRenderTarget = renderer.getRenderTarget();
        resizeRenderTarget(camera);
        renderer.setRenderTarget(renderTarget);
      }
      function detachCamera(camera) {
        if (renderTarget !== renderer.getRenderTarget())
          return;
        renderer.setRenderTarget(currentRenderTarget);
        flush2(camera);
      }
      function flush2(camera) {
        var srcRenderTarget = renderTarget;
        var numViews = srcRenderTarget.numViews;
        var srcFramebuffers = properties.get(srcRenderTarget).__webglViewFramebuffers;
        var viewWidth = srcRenderTarget.width;
        var viewHeight = srcRenderTarget.height;
        if (camera.isArrayCamera) {
          for (var i3 = 0; i3 < numViews; i3++) {
            var viewport = camera.cameras[i3].viewport;
            var x1 = viewport.x;
            var y1 = viewport.y;
            var x2 = x1 + viewport.z;
            var y2 = y1 + viewport.w;
            gl.bindFramebuffer(36008, srcFramebuffers[i3]);
            gl.blitFramebuffer(0, 0, viewWidth, viewHeight, x1, y1, x2, y2, 16384, 9728);
          }
        } else {
          gl.bindFramebuffer(36008, srcFramebuffers[0]);
          gl.blitFramebuffer(0, 0, viewWidth, viewHeight, 0, 0, renderSize.x, renderSize.y, 16384, 9728);
        }
      }
      this.isAvailable = isAvailable;
      this.attachCamera = attachCamera;
      this.detachCamera = detachCamera;
      this.updateCameraProjectionMatricesUniform = updateCameraProjectionMatricesUniform;
      this.updateCameraViewMatricesUniform = updateCameraViewMatricesUniform;
      this.updateObjectMatricesUniforms = updateObjectMatricesUniforms;
    }
    function ArrayCamera(array) {
      PerspectiveCamera.call(this);
      this.cameras = array || [];
    }
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
      constructor: ArrayCamera,
      isArrayCamera: true
    });
    function Group() {
      Object3D.call(this);
      this.type = "Group";
    }
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Group,
      isGroup: true
    });
    function WebXRManager(renderer, gl) {
      var scope = this;
      var session = null;
      var referenceSpace = null;
      var referenceSpaceType = "local-floor";
      var pose = null;
      var controllers = [];
      var inputSourcesMap = new Map();
      var cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();
      var cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();
      var cameraVR = new ArrayCamera([cameraL, cameraR]);
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(id) {
        var controller = controllers[id];
        if (controller === void 0) {
          controller = new Group();
          controller.matrixAutoUpdate = false;
          controller.visible = false;
          controllers[id] = controller;
        }
        return controller;
      };
      function onSessionEvent(event2) {
        var controller = inputSourcesMap.get(event2.inputSource);
        if (controller) {
          controller.dispatchEvent({
            type: event2.type
          });
        }
      }
      function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
          controller.dispatchEvent({
            type: "disconnected",
            data: inputSource
          });
          controller.visible = false;
        });
        inputSourcesMap.clear();
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget());
        animation.stop();
        scope.dispatchEvent({
          type: "sessionend"
        });
        scope.isPresenting = false;
      }
      function onRequestReferenceSpace(value2) {
        referenceSpace = value2;
        animation.setContext(session);
        animation.start();
        scope.dispatchEvent({
          type: "sessionstart"
        });
        scope.isPresenting = true;
      }
      this.setFramebufferScaleFactor = function() {
      };
      this.setReferenceSpaceType = function(value2) {
        referenceSpaceType = value2;
      };
      this.getReferenceSpace = function() {
        return referenceSpace;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = function(value2) {
        session = value2;
        if (session !== null) {
          session.addEventListener("select", onSessionEvent);
          session.addEventListener("selectstart", onSessionEvent);
          session.addEventListener("selectend", onSessionEvent);
          session.addEventListener("squeeze", onSessionEvent);
          session.addEventListener("squeezestart", onSessionEvent);
          session.addEventListener("squeezeend", onSessionEvent);
          session.addEventListener("end", onSessionEnd);
          var attributes = gl.getContextAttributes();
          var layerInit = {
            antialias: attributes.antialias,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil
          };
          var baseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({
            baseLayer
          });
          session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
          session.addEventListener("inputsourceschange", updateInputSources);
        }
      };
      function updateInputSources(event2) {
        var inputSources = session.inputSources;
        for (var i3 = 0; i3 < controllers.length; i3++) {
          inputSourcesMap.set(inputSources[i3], controllers[i3]);
        }
        for (var i3 = 0; i3 < event2.removed.length; i3++) {
          var inputSource = event2.removed[i3];
          var controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({
              type: "disconnected",
              data: inputSource
            });
            inputSourcesMap.delete(inputSource);
          }
        }
        for (var i3 = 0; i3 < event2.added.length; i3++) {
          var inputSource = event2.added[i3];
          var controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({
              type: "connected",
              data: inputSource
            });
          }
        }
      }
      var cameraLPos = new Vector3();
      var cameraRPos = new Vector3();
      function setProjectionFromUnion(camera, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        var ipd = cameraLPos.distanceTo(cameraRPos);
        var projL = cameraL2.projectionMatrix.elements;
        var projR = cameraR2.projectionMatrix.elements;
        var near = projL[14] / (projL[10] - 1);
        var far = projL[14] / (projL[10] + 1);
        var topFov = (projL[9] + 1) / projL[5];
        var bottomFov = (projL[9] - 1) / projL[5];
        var leftFov = (projL[8] - 1) / projL[0];
        var rightFov = (projR[8] + 1) / projR[0];
        var left = near * leftFov;
        var right = near * rightFov;
        var zOffset = ipd / (-leftFov + rightFov);
        var xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        var near2 = near + zOffset;
        var far2 = far + zOffset;
        var left2 = left - xOffset;
        var right2 = right + (ipd - xOffset);
        var top2 = topFov * far / far2 * near2;
        var bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      }
      function updateCamera(camera, parent) {
        if (parent === null) {
          camera.matrixWorld.copy(camera.matrix);
        } else {
          camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
      }
      this.getCamera = function(camera) {
        var parent = camera.parent;
        var cameras = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (var i3 = 0; i3 < cameras.length; i3++) {
          updateCamera(cameras[i3], parent);
        }
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        var children2 = camera.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          children2[i3].updateMatrixWorld(true);
        }
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
        return cameraVR;
      };
      var onAnimationFrameCallback = null;
      function onAnimationFrame(time2, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
          var views = pose.views;
          var baseLayer = session.renderState.baseLayer;
          renderer.setFramebuffer(baseLayer.framebuffer);
          for (var i3 = 0; i3 < views.length; i3++) {
            var view = views[i3];
            var viewport = baseLayer.getViewport(view);
            var viewMatrix = view.transform.inverse.matrix;
            var camera = cameraVR.cameras[i3];
            camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i3 === 0) {
              cameraVR.matrix.copy(camera.matrix);
            }
          }
        }
        var inputSources = session.inputSources;
        for (var i3 = 0; i3 < controllers.length; i3++) {
          var controller = controllers[i3];
          var inputSource = inputSources[i3];
          if (inputSource) {
            var inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (inputPose !== null) {
              controller.matrix.fromArray(inputPose.transform.matrix);
              controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
              controller.visible = true;
              continue;
            }
          }
          controller.visible = false;
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time2, frame);
      }
      var animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
    Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
    function WebGLRenderer(parameters) {
      parameters = parameters || {};
      var _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
      var currentRenderList = null;
      var currentRenderState = null;
      this.domElement = _canvas2;
      this.debug = {
        checkShaderErrors: true
      };
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.clippingPlanes = [];
      this.localClippingEnabled = false;
      this.gammaFactor = 2;
      this.outputEncoding = LinearEncoding;
      this.physicallyCorrectLights = false;
      this.toneMapping = LinearToneMapping;
      this.toneMappingExposure = 1;
      this.toneMappingWhitePoint = 1;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      var _this = this, _isContextLost = false, _framebuffer = null, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = {
        geometry: null,
        program: null,
        wireframe: false
      }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _width = _canvas2.width, _height = _canvas2.height, _pixelRatio = 1, _opaqueSort = null, _transparentSort = null, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
      function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
      }
      var _gl;
      try {
        var contextAttributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer,
          powerPreference: _powerPreference,
          failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
          xrCompatible: true
        };
        _canvas2.addEventListener("webglcontextlost", onContextLost, false);
        _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
        _gl = _context2 || _canvas2.getContext("webgl", contextAttributes) || _canvas2.getContext("experimental-webgl", contextAttributes);
        if (_gl === null) {
          if (_canvas2.getContext("webgl") !== null) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
        if (_gl.getShaderPrecisionFormat === void 0) {
          _gl.getShaderPrecisionFormat = function() {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1
            };
          };
        }
      } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
      }
      var extensions, capabilities, state, info;
      var properties, textures, attributes, geometries, objects;
      var programCache, renderLists, renderStates;
      var background, morphtargets, bufferRenderer, indexedBufferRenderer;
      var utils;
      function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        if (capabilities.isWebGL2 === false) {
          extensions.get("WEBGL_depth_texture");
          extensions.get("OES_texture_float");
          extensions.get("OES_texture_half_float");
          extensions.get("OES_texture_half_float_linear");
          extensions.get("OES_standard_derivatives");
          extensions.get("OES_element_index_uint");
          extensions.get("ANGLE_instanced_arrays");
        }
        extensions.get("OES_texture_float_linear");
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        attributes = new WebGLAttributes(_gl);
        geometries = new WebGLGeometries(_gl, attributes, info);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl);
        programCache = new WebGLPrograms(_this, extensions, capabilities);
        renderLists = new WebGLRenderLists();
        renderStates = new WebGLRenderStates();
        background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
      }
      initGLContext();
      var xr = new WebXRManager(_this, _gl);
      this.xr = xr;
      var multiview = new WebGLMultiview(_this, _gl);
      var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
      this.shadowMap = shadowMap;
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.loseContext();
      };
      this.forceContextRestore = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.restoreContext();
      };
      this.getPixelRatio = function() {
        return _pixelRatio;
      };
      this.setPixelRatio = function(value2) {
        if (value2 === void 0)
          return;
        _pixelRatio = value2;
        this.setSize(_width, _height, false);
      };
      this.getSize = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
          target = new Vector2();
        }
        return target.set(_width, _height);
      };
      this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        _width = width;
        _height = height;
        _canvas2.width = Math.floor(width * _pixelRatio);
        _canvas2.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
          _canvas2.style.width = width + "px";
          _canvas2.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
      };
      this.getDrawingBufferSize = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
          target = new Vector2();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
      };
      this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas2.width = Math.floor(width * pixelRatio);
        _canvas2.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
      };
      this.getCurrentViewport = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
          target = new Vector4();
        }
        return target.copy(_currentViewport);
      };
      this.getViewport = function(target) {
        return target.copy(_viewport);
      };
      this.setViewport = function(x, y2, width, height) {
        if (x.isVector4) {
          _viewport.set(x.x, x.y, x.z, x.w);
        } else {
          _viewport.set(x, y2, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissor = function(target) {
        return target.copy(_scissor);
      };
      this.setScissor = function(x, y2, width, height) {
        if (x.isVector4) {
          _scissor.set(x.x, x.y, x.z, x.w);
        } else {
          _scissor.set(x, y2, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissorTest = function() {
        return _scissorTest;
      };
      this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
      };
      this.setOpaqueSort = function(method) {
        _opaqueSort = method;
      };
      this.setTransparentSort = function(method) {
        _transparentSort = method;
      };
      this.getClearColor = function() {
        return background.getClearColor();
      };
      this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
      };
      this.getClearAlpha = function() {
        return background.getClearAlpha();
      };
      this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === void 0 || color)
          bits |= 16384;
        if (depth === void 0 || depth)
          bits |= 256;
        if (stencil === void 0 || stencil)
          bits |= 1024;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        this.clear(true, false, false);
      };
      this.clearDepth = function() {
        this.clear(false, true, false);
      };
      this.clearStencil = function() {
        this.clear(false, false, true);
      };
      this.dispose = function() {
        _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        objects.dispose();
        xr.dispose();
        animation.stop();
      };
      function onContextLost(event2) {
        event2.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
      }
      function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        initGLContext();
      }
      function onMaterialDispose(event2) {
        var material2 = event2.target;
        material2.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material2);
      }
      function deallocateMaterial(material2) {
        releaseMaterialProgramReference(material2);
        properties.remove(material2);
      }
      function releaseMaterialProgramReference(material2) {
        var programInfo = properties.get(material2).program;
        material2.program = void 0;
        if (programInfo !== void 0) {
          programCache.releaseProgram(programInfo);
        }
      }
      function renderObjectImmediate(object, program) {
        object.render(function(object2) {
          _this.renderBufferImmediate(object2, program);
        });
      }
      this.renderBufferImmediate = function(object, program) {
        state.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position)
          buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
          buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
          buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color)
          buffers.color = _gl.createBuffer();
        var programAttributes = program.getAttributes();
        if (object.hasPositions) {
          _gl.bindBuffer(34962, buffers.position);
          _gl.bufferData(34962, object.positionArray, 35048);
          state.enableAttribute(programAttributes.position);
          _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(34962, buffers.normal);
          _gl.bufferData(34962, object.normalArray, 35048);
          state.enableAttribute(programAttributes.normal);
          _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
          _gl.bindBuffer(34962, buffers.uv);
          _gl.bufferData(34962, object.uvArray, 35048);
          state.enableAttribute(programAttributes.uv);
          _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
          _gl.bindBuffer(34962, buffers.color);
          _gl.bufferData(34962, object.colorArray, 35048);
          state.enableAttribute(programAttributes.color);
          _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
      };
      var tempScene = new Scene();
      this.renderBufferDirect = function(camera, scene, geometry, material2, object, group) {
        if (scene === null)
          scene = tempScene;
        var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        var program = setProgram(camera, scene, material2, object);
        state.setMaterial(material2, frontFaceCW);
        var updateBuffers = false;
        if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material2.wireframe === true)) {
          _currentGeometryProgram.geometry = geometry.id;
          _currentGeometryProgram.program = program.id;
          _currentGeometryProgram.wireframe = material2.wireframe === true;
          updateBuffers = true;
        }
        if (material2.morphTargets || material2.morphNormals) {
          morphtargets.update(object, geometry, material2, program);
          updateBuffers = true;
        }
        var index2 = geometry.index;
        var position = geometry.attributes.position;
        if (index2 === null) {
          if (position === void 0 || position.count === 0)
            return;
        } else if (index2.count === 0) {
          return;
        }
        var rangeFactor = 1;
        if (material2.wireframe === true) {
          index2 = geometries.getWireframeAttribute(geometry);
          rangeFactor = 2;
        }
        var attribute;
        var renderer = bufferRenderer;
        if (index2 !== null) {
          attribute = attributes.get(index2);
          renderer = indexedBufferRenderer;
          renderer.setIndex(attribute);
        }
        if (updateBuffers) {
          setupVertexAttributes(object, geometry, material2, program);
          if (index2 !== null) {
            _gl.bindBuffer(34963, attribute.buffer);
          }
        }
        var dataCount = index2 !== null ? index2.count : position.count;
        var rangeStart = geometry.drawRange.start * rangeFactor;
        var rangeCount = geometry.drawRange.count * rangeFactor;
        var groupStart = group !== null ? group.start * rangeFactor : 0;
        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
        var drawStart = Math.max(rangeStart, groupStart);
        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0)
          return;
        if (object.isMesh) {
          if (material2.wireframe === true) {
            state.setLineWidth(material2.wireframeLinewidth * getTargetPixelRatio());
            renderer.setMode(1);
          } else {
            renderer.setMode(4);
          }
        } else if (object.isLine) {
          var lineWidth = material2.linewidth;
          if (lineWidth === void 0)
            lineWidth = 1;
          state.setLineWidth(lineWidth * getTargetPixelRatio());
          if (object.isLineSegments) {
            renderer.setMode(1);
          } else if (object.isLineLoop) {
            renderer.setMode(2);
          } else {
            renderer.setMode(3);
          }
        } else if (object.isPoints) {
          renderer.setMode(0);
        } else if (object.isSprite) {
          renderer.setMode(4);
        }
        if (object.isInstancedMesh) {
          renderer.renderInstances(geometry, drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
          renderer.renderInstances(geometry, drawStart, drawCount, geometry.maxInstancedCount);
        } else {
          renderer.render(drawStart, drawCount);
        }
      };
      function setupVertexAttributes(object, geometry, material2, program) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
          if (extensions.get("ANGLE_instanced_arrays") === null)
            return;
        }
        state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material2.defaultAttributeValues;
        for (var name in programAttributes) {
          var programAttribute = programAttributes[name];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[name];
            if (geometryAttribute !== void 0) {
              var normalized = geometryAttribute.normalized;
              var size = geometryAttribute.itemSize;
              var attribute = attributes.get(geometryAttribute);
              if (attribute === void 0)
                continue;
              var buffer = attribute.buffer;
              var type = attribute.type;
              var bytesPerElement = attribute.bytesPerElement;
              if (geometryAttribute.isInterleavedBufferAttribute) {
                var data = geometryAttribute.data;
                var stride = data.stride;
                var offset = geometryAttribute.offset;
                if (data && data.isInstancedInterleavedBuffer) {
                  state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                  if (geometry.maxInstancedCount === void 0) {
                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(34962, buffer);
                _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
              } else {
                if (geometryAttribute.isInstancedBufferAttribute) {
                  state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                  if (geometry.maxInstancedCount === void 0) {
                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(34962, buffer);
                _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
              }
            } else if (name === "instanceMatrix") {
              var attribute = attributes.get(object.instanceMatrix);
              if (attribute === void 0)
                continue;
              var buffer = attribute.buffer;
              var type = attribute.type;
              state.enableAttributeAndDivisor(programAttribute + 0, 1);
              state.enableAttributeAndDivisor(programAttribute + 1, 1);
              state.enableAttributeAndDivisor(programAttribute + 2, 1);
              state.enableAttributeAndDivisor(programAttribute + 3, 1);
              _gl.bindBuffer(34962, buffer);
              _gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
              _gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
              _gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
              _gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
            } else if (materialDefaultAttributeValues !== void 0) {
              var value2 = materialDefaultAttributeValues[name];
              if (value2 !== void 0) {
                switch (value2.length) {
                  case 2:
                    _gl.vertexAttrib2fv(programAttribute, value2);
                    break;
                  case 3:
                    _gl.vertexAttrib3fv(programAttribute, value2);
                    break;
                  case 4:
                    _gl.vertexAttrib4fv(programAttribute, value2);
                    break;
                  default:
                    _gl.vertexAttrib1fv(programAttribute, value2);
                }
              }
            }
          }
        }
        state.disableUnusedAttributes();
      }
      this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverse(function(object) {
          if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
        currentRenderState.setupLights(camera);
        scene.traverse(function(object) {
          if (object.material) {
            if (Array.isArray(object.material)) {
              for (var i3 = 0; i3 < object.material.length; i3++) {
                initMaterial(object.material[i3], scene, object);
              }
            } else {
              initMaterial(object.material, scene, object);
            }
          }
        });
      };
      var onAnimationFrameCallback = null;
      function onAnimationFrame(time2) {
        if (xr.isPresenting)
          return;
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time2);
      }
      var animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      if (typeof window !== "undefined")
        animation.setContext(window);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        animation.start();
      };
      this.render = function(scene, camera) {
        var renderTarget, forceClear;
        if (arguments[2] !== void 0) {
          console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
          renderTarget = arguments[2];
        }
        if (arguments[3] !== void 0) {
          console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
          forceClear = arguments[3];
        }
        if (!(camera && camera.isCamera)) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (_isContextLost)
          return;
        _currentGeometryProgram.geometry = null;
        _currentGeometryProgram.program = null;
        _currentGeometryProgram.wireframe = false;
        _currentMaterialId = -1;
        _currentCamera = null;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === null)
          camera.updateMatrixWorld();
        if (xr.enabled && xr.isPresenting) {
          camera = xr.getCamera(camera);
        }
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        if (_this.sortObjects === true) {
          currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        if (_clippingEnabled)
          _clipping.beginShadows();
        var shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled)
          _clipping.endShadows();
        if (this.info.autoReset)
          this.info.reset();
        if (renderTarget !== void 0) {
          this.setRenderTarget(renderTarget);
        }
        if (xr.enabled && multiview.isAvailable()) {
          multiview.attachCamera(camera);
        }
        background.render(currentRenderList, scene, camera, forceClear);
        var opaqueObjects = currentRenderList.opaque;
        var transparentObjects = currentRenderList.transparent;
        if (scene.overrideMaterial) {
          var overrideMaterial = scene.overrideMaterial;
          if (opaqueObjects.length)
            renderObjects(opaqueObjects, scene, camera, overrideMaterial);
          if (transparentObjects.length)
            renderObjects(transparentObjects, scene, camera, overrideMaterial);
        } else {
          if (opaqueObjects.length)
            renderObjects(opaqueObjects, scene, camera);
          if (transparentObjects.length)
            renderObjects(transparentObjects, scene, camera);
        }
        scene.onAfterRender(_this, scene, camera);
        if (_currentRenderTarget !== null) {
          textures.updateRenderTargetMipmap(_currentRenderTarget);
          textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        if (xr.enabled) {
          if (multiview.isAvailable()) {
            multiview.detachCamera(camera);
          }
        }
        currentRenderList = null;
        currentRenderState = null;
      };
      function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false)
          return;
        var visible = object.layers.test(camera.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
          } else if (object.isLOD) {
            if (object.autoUpdate === true)
              object.update(camera);
          } else if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (sortObjects) {
                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              var geometry = objects.update(object);
              var material2 = object.material;
              if (material2.visible) {
                currentRenderList.push(object, geometry, material2, groupOrder, _vector3.z, null);
              }
            }
          } else if (object.isImmediateRenderObject) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (object.isSkinnedMesh) {
              if (object.skeleton.frame !== info.render.frame) {
                object.skeleton.update();
                object.skeleton.frame = info.render.frame;
              }
            }
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              if (sortObjects) {
                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              var geometry = objects.update(object);
              var material2 = object.material;
              if (Array.isArray(material2)) {
                var groups = geometry.groups;
                for (var i3 = 0, l = groups.length; i3 < l; i3++) {
                  var group = groups[i3];
                  var groupMaterial = material2[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                  }
                }
              } else if (material2.visible) {
                currentRenderList.push(object, geometry, material2, groupOrder, _vector3.z, null);
              }
            }
          }
        }
        var children2 = object.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          projectObject(children2[i3], camera, groupOrder, sortObjects);
        }
      }
      function renderObjects(renderList, scene, camera, overrideMaterial) {
        for (var i3 = 0, l = renderList.length; i3 < l; i3++) {
          var renderItem = renderList[i3];
          var object = renderItem.object;
          var geometry = renderItem.geometry;
          var material2 = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
          var group = renderItem.group;
          if (camera.isArrayCamera) {
            _currentArrayCamera = camera;
            if (xr.enabled && multiview.isAvailable()) {
              renderObject(object, scene, camera, geometry, material2, group);
            } else {
              var cameras = camera.cameras;
              for (var j = 0, jl = cameras.length; j < jl; j++) {
                var camera2 = cameras[j];
                if (object.layers.test(camera2.layers)) {
                  state.viewport(_currentViewport.copy(camera2.viewport));
                  currentRenderState.setupLights(camera2);
                  renderObject(object, scene, camera2, geometry, material2, group);
                }
              }
            }
          } else {
            _currentArrayCamera = null;
            renderObject(object, scene, camera, geometry, material2, group);
          }
        }
      }
      function renderObject(object, scene, camera, geometry, material2, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material2, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
          var program = setProgram(camera, scene, material2, object);
          state.setMaterial(material2);
          _currentGeometryProgram.geometry = null;
          _currentGeometryProgram.program = null;
          _currentGeometryProgram.wireframe = false;
          renderObjectImmediate(object, program);
        } else {
          _this.renderBufferDirect(camera, scene, geometry, material2, object, group);
        }
        object.onAfterRender(_this, scene, camera, geometry, material2, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
      }
      function initMaterial(material2, scene, object) {
        var materialProperties = properties.get(material2);
        var lights = currentRenderState.state.lights;
        var shadowsArray = currentRenderState.state.shadowsArray;
        var lightsStateVersion = lights.state.version;
        var parameters2 = programCache.getParameters(material2, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
        var programCacheKey = programCache.getProgramCacheKey(material2, parameters2);
        var program = materialProperties.program;
        var programChange = true;
        if (program === void 0) {
          material2.addEventListener("dispose", onMaterialDispose);
        } else if (program.cacheKey !== programCacheKey) {
          releaseMaterialProgramReference(material2);
        } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
          materialProperties.lightsStateVersion = lightsStateVersion;
          programChange = false;
        } else if (parameters2.shaderID !== void 0) {
          return;
        } else {
          programChange = false;
        }
        if (programChange) {
          if (parameters2.shaderID) {
            var shader = ShaderLib[parameters2.shaderID];
            materialProperties.shader = {
              name: material2.type,
              uniforms: cloneUniforms(shader.uniforms),
              vertexShader: shader.vertexShader,
              fragmentShader: shader.fragmentShader
            };
          } else {
            materialProperties.shader = {
              name: material2.type,
              uniforms: material2.uniforms,
              vertexShader: material2.vertexShader,
              fragmentShader: material2.fragmentShader
            };
          }
          material2.onBeforeCompile(materialProperties.shader, _this);
          programCacheKey = programCache.getProgramCacheKey(material2, parameters2);
          program = programCache.acquireProgram(material2, materialProperties.shader, parameters2, programCacheKey);
          materialProperties.program = program;
          materialProperties.environment = material2.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.outputEncoding = _this.outputEncoding;
          material2.program = program;
        }
        var programAttributes = program.getAttributes();
        if (material2.morphTargets) {
          material2.numSupportedMorphTargets = 0;
          for (var i3 = 0; i3 < _this.maxMorphTargets; i3++) {
            if (programAttributes["morphTarget" + i3] >= 0) {
              material2.numSupportedMorphTargets++;
            }
          }
        }
        if (material2.morphNormals) {
          material2.numSupportedMorphNormals = 0;
          for (var i3 = 0; i3 < _this.maxMorphNormals; i3++) {
            if (programAttributes["morphNormal" + i3] >= 0) {
              material2.numSupportedMorphNormals++;
            }
          }
        }
        var uniforms = materialProperties.shader.uniforms;
        if (!material2.isShaderMaterial && !material2.isRawShaderMaterial || material2.clipping === true) {
          materialProperties.numClippingPlanes = _clipping.numPlanes;
          materialProperties.numIntersection = _clipping.numIntersection;
          uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.fog = scene.fog;
        materialProperties.needsLights = materialNeedsLights(material2);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
          uniforms.ambientLightColor.value = lights.state.ambient;
          uniforms.lightProbe.value = lights.state.probe;
          uniforms.directionalLights.value = lights.state.directional;
          uniforms.spotLights.value = lights.state.spot;
          uniforms.rectAreaLights.value = lights.state.rectArea;
          uniforms.pointLights.value = lights.state.point;
          uniforms.hemisphereLights.value = lights.state.hemi;
          uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
          uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
          uniforms.spotShadowMap.value = lights.state.spotShadowMap;
          uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
          uniforms.pointShadowMap.value = lights.state.pointShadowMap;
          uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
      }
      function setProgram(camera, scene, material2, object) {
        textures.resetTextureUnits();
        var fog = scene.fog;
        var environment = material2.isMeshStandardMaterial ? scene.environment : null;
        var materialProperties = properties.get(material2);
        var lights = currentRenderState.state.lights;
        if (_clippingEnabled) {
          if (_localClippingEnabled || camera !== _currentCamera) {
            var useCache = camera === _currentCamera && material2.id === _currentMaterialId;
            _clipping.setState(material2.clippingPlanes, material2.clipIntersection, material2.clipShadows, camera, materialProperties, useCache);
          }
        }
        if (material2.version === materialProperties.__version) {
          if (materialProperties.program === void 0) {
            material2.needsUpdate = true;
          } else if (material2.fog && materialProperties.fog !== fog) {
            material2.needsUpdate = true;
          } else if (materialProperties.environment !== environment) {
            material2.needsUpdate = true;
          } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            material2.needsUpdate = true;
          } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
            material2.needsUpdate = true;
          } else if (materialProperties.outputEncoding !== _this.outputEncoding) {
            material2.needsUpdate = true;
          }
        }
        if (material2.version !== materialProperties.__version) {
          initMaterial(material2, scene, object);
          materialProperties.__version = material2.version;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
        if (state.useProgram(program.program)) {
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material2.id !== _currentMaterialId) {
          _currentMaterialId = material2.id;
          refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
          if (program.numMultiviewViews > 0) {
            multiview.updateCameraProjectionMatricesUniform(camera, p_uniforms);
          } else {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
          }
          if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
          }
          if (_currentCamera !== camera) {
            _currentCamera = camera;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material2.isShaderMaterial || material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshStandardMaterial || material2.envMap) {
            var uCamPos = p_uniforms.map.cameraPosition;
            if (uCamPos !== void 0) {
              uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
          }
          if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial) {
            p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
          }
          if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial || material2.skinning) {
            if (program.numMultiviewViews > 0) {
              multiview.updateCameraViewMatricesUniform(camera, p_uniforms);
            } else {
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
          }
        }
        if (material2.skinning) {
          p_uniforms.setOptional(_gl, object, "bindMatrix");
          p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
          var skeleton = object.skeleton;
          if (skeleton) {
            var bones = skeleton.bones;
            if (capabilities.floatVertexTextures) {
              if (skeleton.boneTexture === void 0) {
                var size = Math.sqrt(bones.length * 4);
                size = _Math.ceilPowerOfTwo(size);
                size = Math.max(size, 4);
                var boneMatrices = new Float32Array(size * size * 4);
                boneMatrices.set(skeleton.boneMatrices);
                var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                skeleton.boneMatrices = boneMatrices;
                skeleton.boneTexture = boneTexture;
                skeleton.boneTextureSize = size;
              }
              p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
              p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
            } else {
              p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
            }
          }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
          materialProperties.receiveShadow = object.receiveShadow;
          p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (refreshMaterial) {
          p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
          p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
          if (materialProperties.needsLights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
          }
          if (fog && material2.fog) {
            refreshUniformsFog(m_uniforms, fog);
          }
          if (material2.isMeshBasicMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
          } else if (material2.isMeshLambertMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsLambert(m_uniforms, material2);
          } else if (material2.isMeshToonMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsToon(m_uniforms, material2);
          } else if (material2.isMeshPhongMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsPhong(m_uniforms, material2);
          } else if (material2.isMeshStandardMaterial) {
            refreshUniformsCommon(m_uniforms, material2, environment);
            if (material2.isMeshPhysicalMaterial) {
              refreshUniformsPhysical(m_uniforms, material2, environment);
            } else {
              refreshUniformsStandard(m_uniforms, material2, environment);
            }
          } else if (material2.isMeshMatcapMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsMatcap(m_uniforms, material2);
          } else if (material2.isMeshDepthMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsDepth(m_uniforms, material2);
          } else if (material2.isMeshDistanceMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsDistance(m_uniforms, material2);
          } else if (material2.isMeshNormalMaterial) {
            refreshUniformsCommon(m_uniforms, material2);
            refreshUniformsNormal(m_uniforms, material2);
          } else if (material2.isLineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material2);
            if (material2.isLineDashedMaterial) {
              refreshUniformsDash(m_uniforms, material2);
            }
          } else if (material2.isPointsMaterial) {
            refreshUniformsPoints(m_uniforms, material2);
          } else if (material2.isSpriteMaterial) {
            refreshUniformsSprites(m_uniforms, material2);
          } else if (material2.isShadowMaterial) {
            m_uniforms.color.value.copy(material2.color);
            m_uniforms.opacity.value = material2.opacity;
          }
          if (m_uniforms.ltc_1 !== void 0)
            m_uniforms.ltc_1.value = UniformsLib.LTC_1;
          if (m_uniforms.ltc_2 !== void 0)
            m_uniforms.ltc_2.value = UniformsLib.LTC_2;
          WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          if (material2.isShaderMaterial) {
            material2.uniformsNeedUpdate = false;
          }
        }
        if (material2.isShaderMaterial && material2.uniformsNeedUpdate === true) {
          WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          material2.uniformsNeedUpdate = false;
        }
        if (material2.isSpriteMaterial) {
          p_uniforms.setValue(_gl, "center", object.center);
        }
        if (program.numMultiviewViews > 0) {
          multiview.updateObjectMatricesUniforms(object, camera, p_uniforms);
        } else {
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        }
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
      }
      function refreshUniformsCommon(uniforms, material2, environment) {
        uniforms.opacity.value = material2.opacity;
        if (material2.color) {
          uniforms.diffuse.value.copy(material2.color);
        }
        if (material2.emissive) {
          uniforms.emissive.value.copy(material2.emissive).multiplyScalar(material2.emissiveIntensity);
        }
        if (material2.map) {
          uniforms.map.value = material2.map;
        }
        if (material2.alphaMap) {
          uniforms.alphaMap.value = material2.alphaMap;
        }
        if (material2.specularMap) {
          uniforms.specularMap.value = material2.specularMap;
        }
        var envMap = material2.envMap || environment;
        if (envMap) {
          uniforms.envMap.value = envMap;
          uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
          uniforms.reflectivity.value = material2.reflectivity;
          uniforms.refractionRatio.value = material2.refractionRatio;
          uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
        }
        if (material2.lightMap) {
          uniforms.lightMap.value = material2.lightMap;
          uniforms.lightMapIntensity.value = material2.lightMapIntensity;
        }
        if (material2.aoMap) {
          uniforms.aoMap.value = material2.aoMap;
          uniforms.aoMapIntensity.value = material2.aoMapIntensity;
        }
        var uvScaleMap;
        if (material2.map) {
          uvScaleMap = material2.map;
        } else if (material2.specularMap) {
          uvScaleMap = material2.specularMap;
        } else if (material2.displacementMap) {
          uvScaleMap = material2.displacementMap;
        } else if (material2.normalMap) {
          uvScaleMap = material2.normalMap;
        } else if (material2.bumpMap) {
          uvScaleMap = material2.bumpMap;
        } else if (material2.roughnessMap) {
          uvScaleMap = material2.roughnessMap;
        } else if (material2.metalnessMap) {
          uvScaleMap = material2.metalnessMap;
        } else if (material2.alphaMap) {
          uvScaleMap = material2.alphaMap;
        } else if (material2.emissiveMap) {
          uvScaleMap = material2.emissiveMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
          }
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        var uv2ScaleMap;
        if (material2.aoMap) {
          uv2ScaleMap = material2.aoMap;
        } else if (material2.lightMap) {
          uv2ScaleMap = material2.lightMap;
        }
        if (uv2ScaleMap !== void 0) {
          if (uv2ScaleMap.isWebGLRenderTarget) {
            uv2ScaleMap = uv2ScaleMap.texture;
          }
          if (uv2ScaleMap.matrixAutoUpdate === true) {
            uv2ScaleMap.updateMatrix();
          }
          uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
      }
      function refreshUniformsLine(uniforms, material2) {
        uniforms.diffuse.value.copy(material2.color);
        uniforms.opacity.value = material2.opacity;
      }
      function refreshUniformsDash(uniforms, material2) {
        uniforms.dashSize.value = material2.dashSize;
        uniforms.totalSize.value = material2.dashSize + material2.gapSize;
        uniforms.scale.value = material2.scale;
      }
      function refreshUniformsPoints(uniforms, material2) {
        uniforms.diffuse.value.copy(material2.color);
        uniforms.opacity.value = material2.opacity;
        uniforms.size.value = material2.size * _pixelRatio;
        uniforms.scale.value = _height * 0.5;
        if (material2.map) {
          uniforms.map.value = material2.map;
        }
        if (material2.alphaMap) {
          uniforms.alphaMap.value = material2.alphaMap;
        }
        var uvScaleMap;
        if (material2.map) {
          uvScaleMap = material2.map;
        } else if (material2.alphaMap) {
          uvScaleMap = material2.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsSprites(uniforms, material2) {
        uniforms.diffuse.value.copy(material2.color);
        uniforms.opacity.value = material2.opacity;
        uniforms.rotation.value = material2.rotation;
        if (material2.map) {
          uniforms.map.value = material2.map;
        }
        if (material2.alphaMap) {
          uniforms.alphaMap.value = material2.alphaMap;
        }
        var uvScaleMap;
        if (material2.map) {
          uvScaleMap = material2.map;
        } else if (material2.alphaMap) {
          uvScaleMap = material2.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshUniformsLambert(uniforms, material2) {
        if (material2.emissiveMap) {
          uniforms.emissiveMap.value = material2.emissiveMap;
        }
      }
      function refreshUniformsPhong(uniforms, material2) {
        uniforms.specular.value.copy(material2.specular);
        uniforms.shininess.value = Math.max(material2.shininess, 0.0001);
        if (material2.emissiveMap) {
          uniforms.emissiveMap.value = material2.emissiveMap;
        }
        if (material2.bumpMap) {
          uniforms.bumpMap.value = material2.bumpMap;
          uniforms.bumpScale.value = material2.bumpScale;
          if (material2.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material2.normalMap) {
          uniforms.normalMap.value = material2.normalMap;
          uniforms.normalScale.value.copy(material2.normalScale);
          if (material2.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
      }
      function refreshUniformsToon(uniforms, material2) {
        uniforms.specular.value.copy(material2.specular);
        uniforms.shininess.value = Math.max(material2.shininess, 0.0001);
        if (material2.gradientMap) {
          uniforms.gradientMap.value = material2.gradientMap;
        }
        if (material2.emissiveMap) {
          uniforms.emissiveMap.value = material2.emissiveMap;
        }
        if (material2.bumpMap) {
          uniforms.bumpMap.value = material2.bumpMap;
          uniforms.bumpScale.value = material2.bumpScale;
          if (material2.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material2.normalMap) {
          uniforms.normalMap.value = material2.normalMap;
          uniforms.normalScale.value.copy(material2.normalScale);
          if (material2.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
      }
      function refreshUniformsStandard(uniforms, material2, environment) {
        uniforms.roughness.value = material2.roughness;
        uniforms.metalness.value = material2.metalness;
        if (material2.roughnessMap) {
          uniforms.roughnessMap.value = material2.roughnessMap;
        }
        if (material2.metalnessMap) {
          uniforms.metalnessMap.value = material2.metalnessMap;
        }
        if (material2.emissiveMap) {
          uniforms.emissiveMap.value = material2.emissiveMap;
        }
        if (material2.bumpMap) {
          uniforms.bumpMap.value = material2.bumpMap;
          uniforms.bumpScale.value = material2.bumpScale;
          if (material2.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material2.normalMap) {
          uniforms.normalMap.value = material2.normalMap;
          uniforms.normalScale.value.copy(material2.normalScale);
          if (material2.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
        if (material2.envMap || environment) {
          uniforms.envMapIntensity.value = material2.envMapIntensity;
        }
      }
      function refreshUniformsPhysical(uniforms, material2, environment) {
        refreshUniformsStandard(uniforms, material2, environment);
        uniforms.reflectivity.value = material2.reflectivity;
        uniforms.clearcoat.value = material2.clearcoat;
        uniforms.clearcoatRoughness.value = material2.clearcoatRoughness;
        if (material2.sheen)
          uniforms.sheen.value.copy(material2.sheen);
        if (material2.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material2.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material2.clearcoatNormalMap;
          if (material2.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
        uniforms.transparency.value = material2.transparency;
      }
      function refreshUniformsMatcap(uniforms, material2) {
        if (material2.matcap) {
          uniforms.matcap.value = material2.matcap;
        }
        if (material2.bumpMap) {
          uniforms.bumpMap.value = material2.bumpMap;
          uniforms.bumpScale.value = material2.bumpScale;
          if (material2.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material2.normalMap) {
          uniforms.normalMap.value = material2.normalMap;
          uniforms.normalScale.value.copy(material2.normalScale);
          if (material2.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
      }
      function refreshUniformsDepth(uniforms, material2) {
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
      }
      function refreshUniformsDistance(uniforms, material2) {
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
        uniforms.referencePosition.value.copy(material2.referencePosition);
        uniforms.nearDistance.value = material2.nearDistance;
        uniforms.farDistance.value = material2.farDistance;
      }
      function refreshUniformsNormal(uniforms, material2) {
        if (material2.bumpMap) {
          uniforms.bumpMap.value = material2.bumpMap;
          uniforms.bumpScale.value = material2.bumpScale;
          if (material2.side === BackSide)
            uniforms.bumpScale.value *= -1;
        }
        if (material2.normalMap) {
          uniforms.normalMap.value = material2.normalMap;
          uniforms.normalScale.value.copy(material2.normalScale);
          if (material2.side === BackSide)
            uniforms.normalScale.value.negate();
        }
        if (material2.displacementMap) {
          uniforms.displacementMap.value = material2.displacementMap;
          uniforms.displacementScale.value = material2.displacementScale;
          uniforms.displacementBias.value = material2.displacementBias;
        }
      }
      function markUniformsLightsNeedsUpdate(uniforms, value2) {
        uniforms.ambientLightColor.needsUpdate = value2;
        uniforms.lightProbe.needsUpdate = value2;
        uniforms.directionalLights.needsUpdate = value2;
        uniforms.pointLights.needsUpdate = value2;
        uniforms.spotLights.needsUpdate = value2;
        uniforms.rectAreaLights.needsUpdate = value2;
        uniforms.hemisphereLights.needsUpdate = value2;
      }
      function materialNeedsLights(material2) {
        return material2.isMeshLambertMaterial || material2.isMeshToonMaterial || material2.isMeshPhongMaterial || material2.isMeshStandardMaterial || material2.isShadowMaterial || material2.isShaderMaterial && material2.lights === true;
      }
      this.setFramebuffer = function(value2) {
        if (_framebuffer !== value2 && _currentRenderTarget === null)
          _gl.bindFramebuffer(36160, value2);
        _framebuffer = value2;
      };
      this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
      };
      this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
      };
      this.getRenderTarget = function() {
        return _currentRenderTarget;
      };
      this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        }
        var framebuffer = _framebuffer;
        var isCube = false;
        if (renderTarget) {
          var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLRenderTargetCube) {
            framebuffer = __webglFramebuffer[activeCubeFace || 0];
            isCube = true;
          } else if (renderTarget.isWebGLMultisampleRenderTarget) {
            framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
          } else {
            framebuffer = __webglFramebuffer;
          }
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
        } else {
          _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
          _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
          _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
          _gl.bindFramebuffer(36160, framebuffer);
          _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
          var textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
        }
      };
      this.readRenderTargetPixels = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          var restore = false;
          if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(36160, framebuffer);
            restore = true;
          }
          try {
            var texture = renderTarget.texture;
            var textureFormat = texture.format;
            var textureType = texture.type;
            if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            if (_gl.checkFramebufferStatus(36160) === 36053) {
              if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
                _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
              }
            } else {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            }
          } finally {
            if (restore) {
              _gl.bindFramebuffer(36160, _currentFramebuffer);
            }
          }
        }
      };
      this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === void 0)
          level = 0;
        var levelScale = Math.pow(2, -level);
        var width = Math.floor(texture.image.width * levelScale);
        var height = Math.floor(texture.image.height * levelScale);
        var glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
      };
      this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        var width = srcTexture.image.width;
        var height = srcTexture.image.height;
        var glFormat = utils.convert(dstTexture.format);
        var glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        if (srcTexture.isDataTexture) {
          _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        } else {
          _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
        }
        state.unbindTexture();
      };
      this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
    }
    function FogExp2(color, density) {
      this.name = "";
      this.color = new Color(color);
      this.density = density !== void 0 ? density : 0.00025;
    }
    Object.assign(FogExp2.prototype, {
      isFogExp2: true,
      clone: function() {
        return new FogExp2(this.color, this.density);
      },
      toJSON: function() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      }
    });
    function Fog(color, near, far) {
      this.name = "";
      this.color = new Color(color);
      this.near = near !== void 0 ? near : 1;
      this.far = far !== void 0 ? far : 1000;
    }
    Object.assign(Fog.prototype, {
      isFog: true,
      clone: function() {
        return new Fog(this.color, this.near, this.far);
      },
      toJSON: function() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    });
    function InterleavedBuffer(array, stride) {
      this.array = array;
      this.stride = stride;
      this.count = array !== void 0 ? array.length / stride : 0;
      this.usage = StaticDrawUsage;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    }
    Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
      set: function(value2) {
        if (value2 === true)
          this.version++;
      }
    });
    Object.assign(InterleavedBuffer.prototype, {
      isInterleavedBuffer: true,
      onUploadCallback: function() {
      },
      setUsage: function(value2) {
        this.usage = value2;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i3 = 0, l = this.stride; i3 < l; i3++) {
          this.array[index1 + i3] = attribute.array[index2 + i3];
        }
        return this;
      },
      set: function(value2, offset) {
        if (offset === void 0)
          offset = 0;
        this.array.set(value2, offset);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
      }
    });
    var _vector$7 = new Vector3();
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.normalized = normalized === true;
    }
    Object.defineProperties(InterleavedBufferAttribute.prototype, {
      count: {
        get: function() {
          return this.data.count;
        }
      },
      array: {
        get: function() {
          return this.data.array;
        }
      }
    });
    Object.assign(InterleavedBufferAttribute.prototype, {
      isInterleavedBufferAttribute: true,
      applyMatrix4: function(m2) {
        for (var i3 = 0, l = this.data.count; i3 < l; i3++) {
          _vector$7.x = this.getX(i3);
          _vector$7.y = this.getY(i3);
          _vector$7.z = this.getZ(i3);
          _vector$7.applyMatrix4(m2);
          this.setXYZ(i3, _vector$7.x, _vector$7.y, _vector$7.z);
        }
        return this;
      },
      setX: function(index2, x) {
        this.data.array[index2 * this.data.stride + this.offset] = x;
        return this;
      },
      setY: function(index2, y2) {
        this.data.array[index2 * this.data.stride + this.offset + 1] = y2;
        return this;
      },
      setZ: function(index2, z) {
        this.data.array[index2 * this.data.stride + this.offset + 2] = z;
        return this;
      },
      setW: function(index2, w2) {
        this.data.array[index2 * this.data.stride + this.offset + 3] = w2;
        return this;
      },
      getX: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset];
      },
      getY: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 1];
      },
      getZ: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 2];
      },
      getW: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 3];
      },
      setXY: function(index2, x, y2) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y2;
        return this;
      },
      setXYZ: function(index2, x, y2, z) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y2;
        this.data.array[index2 + 2] = z;
        return this;
      },
      setXYZW: function(index2, x, y2, z, w2) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x;
        this.data.array[index2 + 1] = y2;
        this.data.array[index2 + 2] = z;
        this.data.array[index2 + 3] = w2;
        return this;
      }
    });
    function SpriteMaterial(parameters) {
      Material.call(this);
      this.type = "SpriteMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.rotation = 0;
      this.sizeAttenuation = true;
      this.transparent = true;
      this.setValues(parameters);
    }
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    SpriteMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    };
    var _geometry;
    var _intersectPoint = new Vector3();
    var _worldScale = new Vector3();
    var _mvPosition = new Vector3();
    var _alignedPosition = new Vector2();
    var _rotatedPosition = new Vector2();
    var _viewWorldMatrix = new Matrix4();
    var _vA$1 = new Vector3();
    var _vB$1 = new Vector3();
    var _vC$1 = new Vector3();
    var _uvA$1 = new Vector2();
    var _uvB$1 = new Vector2();
    var _uvC$1 = new Vector2();
    function Sprite(material2) {
      Object3D.call(this);
      this.type = "Sprite";
      if (_geometry === void 0) {
        _geometry = new BufferGeometry();
        var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
        var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([0, 1, 2, 0, 2, 3]);
        _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
      }
      this.geometry = _geometry;
      this.material = material2 !== void 0 ? material2 : new SpriteMaterial();
      this.center = new Vector2(0.5, 0.5);
    }
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Sprite,
      isSprite: true,
      raycast: function(raycaster, intersects2) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        var rotation = this.material.rotation;
        var sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        var center = this.center;
        transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA$1.set(0, 0);
        _uvB$1.set(1, 0);
        _uvC$1.set(1, 1);
        var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
        if (intersect === null) {
          transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB$1.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
          face: null,
          object: this
        });
      },
      clone: function() {
        return new this.constructor(this.material).copy(this);
      },
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== void 0)
          this.center.copy(source.center);
        return this;
      }
    });
    function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
      _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
      if (sin !== void 0) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
      } else {
        _rotatedPosition.copy(_alignedPosition);
      }
      vertexPosition.copy(mvPosition);
      vertexPosition.x += _rotatedPosition.x;
      vertexPosition.y += _rotatedPosition.y;
      vertexPosition.applyMatrix4(_viewWorldMatrix);
    }
    var _v1$4 = new Vector3();
    var _v2$2 = new Vector3();
    function LOD() {
      Object3D.call(this);
      this.type = "LOD";
      Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        }
      });
      this.autoUpdate = true;
    }
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: LOD,
      isLOD: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        var levels = source.levels;
        for (var i3 = 0, l = levels.length; i3 < l; i3++) {
          var level = levels[i3];
          this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      },
      addLevel: function(object, distance) {
        if (distance === void 0)
          distance = 0;
        distance = Math.abs(distance);
        var levels = this.levels;
        for (var l = 0; l < levels.length; l++) {
          if (distance < levels[l].distance) {
            break;
          }
        }
        levels.splice(l, 0, {
          distance,
          object
        });
        this.add(object);
        return this;
      },
      getObjectForDistance: function(distance) {
        var levels = this.levels;
        if (levels.length > 0) {
          for (var i3 = 1, l = levels.length; i3 < l; i3++) {
            if (distance < levels[i3].distance) {
              break;
            }
          }
          return levels[i3 - 1].object;
        }
        return null;
      },
      raycast: function(raycaster, intersects2) {
        var levels = this.levels;
        if (levels.length > 0) {
          _v1$4.setFromMatrixPosition(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(_v1$4);
          this.getObjectForDistance(distance).raycast(raycaster, intersects2);
        }
      },
      update: function(camera) {
        var levels = this.levels;
        if (levels.length > 1) {
          _v1$4.setFromMatrixPosition(camera.matrixWorld);
          _v2$2.setFromMatrixPosition(this.matrixWorld);
          var distance = _v1$4.distanceTo(_v2$2);
          levels[0].object.visible = true;
          for (var i3 = 1, l = levels.length; i3 < l; i3++) {
            if (distance >= levels[i3].distance) {
              levels[i3 - 1].object.visible = false;
              levels[i3].object.visible = true;
            } else {
              break;
            }
          }
          for (; i3 < l; i3++) {
            levels[i3].object.visible = false;
          }
        }
      },
      toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false)
          data.object.autoUpdate = false;
        data.object.levels = [];
        var levels = this.levels;
        for (var i3 = 0, l = levels.length; i3 < l; i3++) {
          var level = levels[i3];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance
          });
        }
        return data;
      }
    });
    function SkinnedMesh(geometry, material2) {
      if (geometry && geometry.isGeometry) {
        console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      Mesh.call(this, geometry, material2);
      this.type = "SkinnedMesh";
      this.bindMode = "attached";
      this.bindMatrix = new Matrix4();
      this.bindMatrixInverse = new Matrix4();
    }
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
      constructor: SkinnedMesh,
      isSkinnedMesh: true,
      bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
      },
      pose: function() {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function() {
        var vector = new Vector4();
        var skinWeight = this.geometry.attributes.skinWeight;
        for (var i3 = 0, l = skinWeight.count; i3 < l; i3++) {
          vector.x = skinWeight.getX(i3);
          vector.y = skinWeight.getY(i3);
          vector.z = skinWeight.getZ(i3);
          vector.w = skinWeight.getW(i3);
          var scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i3, vector.x, vector.y, vector.z, vector.w);
        }
      },
      updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === "attached") {
          this.bindMatrixInverse.getInverse(this.matrixWorld);
        } else if (this.bindMode === "detached") {
          this.bindMatrixInverse.getInverse(this.bindMatrix);
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      },
      clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    var _offsetMatrix = new Matrix4();
    var _identityMatrix = new Matrix4();
    function Skeleton(bones, boneInverses) {
      bones = bones || [];
      this.bones = bones.slice(0);
      this.boneMatrices = new Float32Array(this.bones.length * 16);
      this.frame = -1;
      if (boneInverses === void 0) {
        this.calculateInverses();
      } else {
        if (this.bones.length === boneInverses.length) {
          this.boneInverses = boneInverses.slice(0);
        } else {
          console.warn("THREE.Skeleton boneInverses is the wrong length.");
          this.boneInverses = [];
          for (var i3 = 0, il = this.bones.length; i3 < il; i3++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
    Object.assign(Skeleton.prototype, {
      calculateInverses: function() {
        this.boneInverses = [];
        for (var i3 = 0, il = this.bones.length; i3 < il; i3++) {
          var inverse = new Matrix4();
          if (this.bones[i3]) {
            inverse.getInverse(this.bones[i3].matrixWorld);
          }
          this.boneInverses.push(inverse);
        }
      },
      pose: function() {
        var bone, i3, il;
        for (i3 = 0, il = this.bones.length; i3 < il; i3++) {
          bone = this.bones[i3];
          if (bone) {
            bone.matrixWorld.getInverse(this.boneInverses[i3]);
          }
        }
        for (i3 = 0, il = this.bones.length; i3 < il; i3++) {
          bone = this.bones[i3];
          if (bone) {
            if (bone.parent && bone.parent.isBone) {
              bone.matrix.getInverse(bone.parent.matrixWorld);
              bone.matrix.multiply(bone.matrixWorld);
            } else {
              bone.matrix.copy(bone.matrixWorld);
            }
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          }
        }
      },
      update: function() {
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        var boneMatrices = this.boneMatrices;
        var boneTexture = this.boneTexture;
        for (var i3 = 0, il = bones.length; i3 < il; i3++) {
          var matrix = bones[i3] ? bones[i3].matrixWorld : _identityMatrix;
          _offsetMatrix.multiplyMatrices(matrix, boneInverses[i3]);
          _offsetMatrix.toArray(boneMatrices, i3 * 16);
        }
        if (boneTexture !== void 0) {
          boneTexture.needsUpdate = true;
        }
      },
      clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
      },
      getBoneByName: function(name) {
        for (var i3 = 0, il = this.bones.length; i3 < il; i3++) {
          var bone = this.bones[i3];
          if (bone.name === name) {
            return bone;
          }
        }
        return void 0;
      }
    });
    function Bone() {
      Object3D.call(this);
      this.type = "Bone";
    }
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Bone,
      isBone: true
    });
    var _instanceLocalMatrix = new Matrix4();
    var _instanceWorldMatrix = new Matrix4();
    var _instanceIntersects = [];
    var _mesh = new Mesh();
    function InstancedMesh(geometry, material2, count) {
      Mesh.call(this, geometry, material2);
      this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
      this.count = count;
    }
    InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
      constructor: InstancedMesh,
      isInstancedMesh: true,
      getMatrixAt: function(index2, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index2 * 16);
      },
      raycast: function(raycaster, intersects2) {
        var matrixWorld = this.matrixWorld;
        var raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === void 0)
          return;
        for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
          _mesh.matrixWorld = _instanceWorldMatrix;
          _mesh.raycast(raycaster, _instanceIntersects);
          if (_instanceIntersects.length > 0) {
            _instanceIntersects[0].instanceId = instanceId;
            _instanceIntersects[0].object = this;
            intersects2.push(_instanceIntersects[0]);
            _instanceIntersects.length = 0;
          }
        }
      },
      setMatrixAt: function(index2, matrix) {
        matrix.toArray(this.instanceMatrix.array, index2 * 16);
      },
      updateMorphTargets: function() {
      }
    });
    function LineBasicMaterial(parameters) {
      Material.call(this);
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.setValues(parameters);
    }
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      return this;
    };
    var _start = new Vector3();
    var _end = new Vector3();
    var _inverseMatrix$1 = new Matrix4();
    var _ray$1 = new Ray();
    var _sphere$2 = new Sphere();
    function Line(geometry, material2, mode) {
      if (mode === 1) {
        console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
      }
      Object3D.call(this);
      this.type = "Line";
      this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
      this.material = material2 !== void 0 ? material2 : new LineBasicMaterial({
        color: Math.random() * 16777215
      });
    }
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Line,
      isLine: true,
      computeLineDistances: function() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            var positionAttribute = geometry.attributes.position;
            var lineDistances = [0];
            for (var i3 = 1, l = positionAttribute.count; i3 < l; i3++) {
              _start.fromBufferAttribute(positionAttribute, i3 - 1);
              _end.fromBufferAttribute(positionAttribute, i3);
              lineDistances[i3] = lineDistances[i3 - 1];
              lineDistances[i3] += _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          var vertices = geometry.vertices;
          var lineDistances = geometry.lineDistances;
          lineDistances[0] = 0;
          for (var i3 = 1, l = vertices.length; i3 < l; i3++) {
            lineDistances[i3] = lineDistances[i3 - 1];
            lineDistances[i3] += vertices[i3 - 1].distanceTo(vertices[i3]);
          }
        }
        return this;
      },
      raycast: function(raycaster, intersects2) {
        var precision = raycaster.linePrecision;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere);
        _sphere$2.applyMatrix4(matrixWorld);
        _sphere$2.radius += precision;
        if (raycaster.ray.intersectsSphere(_sphere$2) === false)
          return;
        _inverseMatrix$1.getInverse(matrixWorld);
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localPrecisionSq = localPrecision * localPrecision;
        var vStart = new Vector3();
        var vEnd = new Vector3();
        var interSegment = new Vector3();
        var interRay = new Vector3();
        var step = this && this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
          var index2 = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (index2 !== null) {
            var indices = index2.array;
            for (var i3 = 0, l = indices.length - 1; i3 < l; i3 += step) {
              var a = indices[i3];
              var b = indices[i3 + 1];
              vStart.fromArray(positions, a * 3);
              vEnd.fromArray(positions, b * 3);
              var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localPrecisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i3,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            for (var i3 = 0, l = positions.length / 3 - 1; i3 < l; i3 += step) {
              vStart.fromArray(positions, 3 * i3);
              vEnd.fromArray(positions, 3 * i3 + 3);
              var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localPrecisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i3,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry.isGeometry) {
          var vertices = geometry.vertices;
          var nbVertices = vertices.length;
          for (var i3 = 0; i3 < nbVertices - 1; i3 += step) {
            var distSq = _ray$1.distanceSqToSegment(vertices[i3], vertices[i3 + 1], interRay, interSegment);
            if (distSq > localPrecisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i3,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      },
      clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    var _start$1 = new Vector3();
    var _end$1 = new Vector3();
    function LineSegments(geometry, material2) {
      Line.call(this, geometry, material2);
      this.type = "LineSegments";
    }
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
      constructor: LineSegments,
      isLineSegments: true,
      computeLineDistances: function() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            var positionAttribute = geometry.attributes.position;
            var lineDistances = [];
            for (var i3 = 0, l = positionAttribute.count; i3 < l; i3 += 2) {
              _start$1.fromBufferAttribute(positionAttribute, i3);
              _end$1.fromBufferAttribute(positionAttribute, i3 + 1);
              lineDistances[i3] = i3 === 0 ? 0 : lineDistances[i3 - 1];
              lineDistances[i3 + 1] = lineDistances[i3] + _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          var vertices = geometry.vertices;
          var lineDistances = geometry.lineDistances;
          for (var i3 = 0, l = vertices.length; i3 < l; i3 += 2) {
            _start$1.copy(vertices[i3]);
            _end$1.copy(vertices[i3 + 1]);
            lineDistances[i3] = i3 === 0 ? 0 : lineDistances[i3 - 1];
            lineDistances[i3 + 1] = lineDistances[i3] + _start$1.distanceTo(_end$1);
          }
        }
        return this;
      }
    });
    function LineLoop(geometry, material2) {
      Line.call(this, geometry, material2);
      this.type = "LineLoop";
    }
    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
      constructor: LineLoop,
      isLineLoop: true
    });
    function PointsMaterial(parameters) {
      Material.call(this);
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.morphTargets = false;
      this.setValues(parameters);
    }
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.morphTargets = source.morphTargets;
      return this;
    };
    var _inverseMatrix$2 = new Matrix4();
    var _ray$2 = new Ray();
    var _sphere$3 = new Sphere();
    var _position$1 = new Vector3();
    function Points(geometry, material2) {
      Object3D.call(this);
      this.type = "Points";
      this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
      this.material = material2 !== void 0 ? material2 : new PointsMaterial({
        color: Math.random() * 16777215
      });
      this.updateMorphTargets();
    }
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Points,
      isPoints: true,
      raycast: function(raycaster, intersects2) {
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        _sphere$3.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
          return;
        _inverseMatrix$2.getInverse(matrixWorld);
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
          var index2 = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (index2 !== null) {
            var indices = index2.array;
            for (var i3 = 0, il = indices.length; i3 < il; i3++) {
              var a = indices[i3];
              _position$1.fromArray(positions, a * 3);
              testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          } else {
            for (var i3 = 0, l = positions.length / 3; i3 < l; i3++) {
              _position$1.fromArray(positions, i3 * 3);
              testPoint(_position$1, i3, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          }
        } else {
          var vertices = geometry.vertices;
          for (var i3 = 0, l = vertices.length; i3 < l; i3++) {
            testPoint(vertices[i3], i3, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      },
      updateMorphTargets: function() {
        var geometry = this.geometry;
        var m2, ml, name;
        if (geometry.isBufferGeometry) {
          var morphAttributes = geometry.morphAttributes;
          var keys2 = Object.keys(morphAttributes);
          if (keys2.length > 0) {
            var morphAttribute = morphAttributes[keys2[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                name = morphAttribute[m2].name || String(m2);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m2;
              }
            }
          }
        } else {
          var morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      },
      clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    function testPoint(point, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
      var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
      if (rayPointDistanceSq < localThresholdSq) {
        var intersectPoint = new Vector3();
        _ray$2.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          distanceToRay: Math.sqrt(rayPointDistanceSq),
          point: intersectPoint,
          index: index2,
          face: null,
          object
        });
      }
    }
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.format = format !== void 0 ? format : RGBFormat;
      this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
      this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
      this.generateMipmaps = false;
    }
    VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
      constructor: VideoTexture,
      isVideoTexture: true,
      update: function() {
        var video = this.image;
        if (video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    });
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = {
        width,
        height
      };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    }
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    }
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    CanvasTexture.prototype.isCanvasTexture = true;
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
      format = format !== void 0 ? format : DepthFormat;
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedShortType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        width,
        height
      };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    }
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    function WireframeGeometry(geometry) {
      BufferGeometry.call(this);
      this.type = "WireframeGeometry";
      var vertices = [];
      var i3, j, l, o, ol;
      var edge = [0, 0], edges = {}, e, edge1, edge2;
      var key, keys2 = ["a", "b", "c"];
      var vertex;
      if (geometry && geometry.isGeometry) {
        var faces = geometry.faces;
        for (i3 = 0, l = faces.length; i3 < l; i3++) {
          var face = faces[i3];
          for (j = 0; j < 3; j++) {
            edge1 = face[keys2[j]];
            edge2 = face[keys2[(j + 1) % 3]];
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
        for (key in edges) {
          e = edges[key];
          vertex = geometry.vertices[e.index1];
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex = geometry.vertices[e.index2];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      } else if (geometry && geometry.isBufferGeometry) {
        var position, indices, groups;
        var group, start, count;
        var index1, index2;
        vertex = new Vector3();
        if (geometry.index !== null) {
          position = geometry.attributes.position;
          indices = geometry.index;
          groups = geometry.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.count,
              materialIndex: 0
            }];
          }
          for (o = 0, ol = groups.length; o < ol; ++o) {
            group = groups[o];
            start = group.start;
            count = group.count;
            for (i3 = start, l = start + count; i3 < l; i3 += 3) {
              for (j = 0; j < 3; j++) {
                edge1 = indices.getX(i3 + j);
                edge2 = indices.getX(i3 + (j + 1) % 3);
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);
                key = edge[0] + "," + edge[1];
                if (edges[key] === void 0) {
                  edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                  };
                }
              }
            }
          }
          for (key in edges) {
            e = edges[key];
            vertex.fromBufferAttribute(position, e.index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex.fromBufferAttribute(position, e.index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        } else {
          position = geometry.attributes.position;
          for (i3 = 0, l = position.count / 3; i3 < l; i3++) {
            for (j = 0; j < 3; j++) {
              index1 = 3 * i3 + j;
              vertex.fromBufferAttribute(position, index1);
              vertices.push(vertex.x, vertex.y, vertex.z);
              index2 = 3 * i3 + (j + 1) % 3;
              vertex.fromBufferAttribute(position, index2);
              vertices.push(vertex.x, vertex.y, vertex.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;
    function ParametricGeometry(func, slices, stacks) {
      Geometry.call(this);
      this.type = "ParametricGeometry";
      this.parameters = {
        func,
        slices,
        stacks
      };
      this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
      this.mergeVertices();
    }
    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    function ParametricBufferGeometry(func, slices, stacks) {
      BufferGeometry.call(this);
      this.type = "ParametricBufferGeometry";
      this.parameters = {
        func,
        slices,
        stacks
      };
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var EPS = 1e-05;
      var normal = new Vector3();
      var p0 = new Vector3(), p1 = new Vector3();
      var pu = new Vector3(), pv = new Vector3();
      var i3, j;
      if (func.length < 3) {
        console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
      }
      var sliceCount = slices + 1;
      for (i3 = 0; i3 <= stacks; i3++) {
        var v = i3 / stacks;
        for (j = 0; j <= slices; j++) {
          var u = j / slices;
          func(u, v, p0);
          vertices.push(p0.x, p0.y, p0.z);
          if (u - EPS >= 0) {
            func(u - EPS, v, p1);
            pu.subVectors(p0, p1);
          } else {
            func(u + EPS, v, p1);
            pu.subVectors(p1, p0);
          }
          if (v - EPS >= 0) {
            func(u, v - EPS, p1);
            pv.subVectors(p0, p1);
          } else {
            func(u, v + EPS, p1);
            pv.subVectors(p1, p0);
          }
          normal.crossVectors(pu, pv).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, v);
        }
      }
      for (i3 = 0; i3 < stacks; i3++) {
        for (j = 0; j < slices; j++) {
          var a = i3 * sliceCount + j;
          var b = i3 * sliceCount + j + 1;
          var c = (i3 + 1) * sliceCount + j + 1;
          var d2 = (i3 + 1) * sliceCount + j;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
    function PolyhedronGeometry(vertices, indices, radius, detail) {
      Geometry.call(this);
      this.type = "PolyhedronGeometry";
      this.parameters = {
        vertices,
        indices,
        radius,
        detail
      };
      this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
      this.mergeVertices();
    }
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
      BufferGeometry.call(this);
      this.type = "PolyhedronBufferGeometry";
      this.parameters = {
        vertices,
        indices,
        radius,
        detail
      };
      radius = radius || 1;
      detail = detail || 0;
      var vertexBuffer = [];
      var uvBuffer = [];
      subdivide(detail);
      applyRadius(radius);
      generateUVs();
      this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
      this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
      if (detail === 0) {
        this.computeVertexNormals();
      } else {
        this.normalizeNormals();
      }
      function subdivide(detail2) {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();
        for (var i3 = 0; i3 < indices.length; i3 += 3) {
          getVertexByIndex(indices[i3 + 0], a);
          getVertexByIndex(indices[i3 + 1], b);
          getVertexByIndex(indices[i3 + 2], c);
          subdivideFace(a, b, c, detail2);
        }
      }
      function subdivideFace(a, b, c, detail2) {
        var cols = Math.pow(2, detail2);
        var v = [];
        var i3, j;
        for (i3 = 0; i3 <= cols; i3++) {
          v[i3] = [];
          var aj = a.clone().lerp(c, i3 / cols);
          var bj = b.clone().lerp(c, i3 / cols);
          var rows = cols - i3;
          for (j = 0; j <= rows; j++) {
            if (j === 0 && i3 === cols) {
              v[i3][j] = aj;
            } else {
              v[i3][j] = aj.clone().lerp(bj, j / rows);
            }
          }
        }
        for (i3 = 0; i3 < cols; i3++) {
          for (j = 0; j < 2 * (cols - i3) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 === 0) {
              pushVertex(v[i3][k + 1]);
              pushVertex(v[i3 + 1][k]);
              pushVertex(v[i3][k]);
            } else {
              pushVertex(v[i3][k + 1]);
              pushVertex(v[i3 + 1][k + 1]);
              pushVertex(v[i3 + 1][k]);
            }
          }
        }
      }
      function applyRadius(radius2) {
        var vertex = new Vector3();
        for (var i3 = 0; i3 < vertexBuffer.length; i3 += 3) {
          vertex.x = vertexBuffer[i3 + 0];
          vertex.y = vertexBuffer[i3 + 1];
          vertex.z = vertexBuffer[i3 + 2];
          vertex.normalize().multiplyScalar(radius2);
          vertexBuffer[i3 + 0] = vertex.x;
          vertexBuffer[i3 + 1] = vertex.y;
          vertexBuffer[i3 + 2] = vertex.z;
        }
      }
      function generateUVs() {
        var vertex = new Vector3();
        for (var i3 = 0; i3 < vertexBuffer.length; i3 += 3) {
          vertex.x = vertexBuffer[i3 + 0];
          vertex.y = vertexBuffer[i3 + 1];
          vertex.z = vertexBuffer[i3 + 2];
          var u = azimuth(vertex) / 2 / Math.PI + 0.5;
          var v = inclination(vertex) / Math.PI + 0.5;
          uvBuffer.push(u, 1 - v);
        }
        correctUVs();
        correctSeam();
      }
      function correctSeam() {
        for (var i3 = 0; i3 < uvBuffer.length; i3 += 6) {
          var x0 = uvBuffer[i3 + 0];
          var x1 = uvBuffer[i3 + 2];
          var x2 = uvBuffer[i3 + 4];
          var max = Math.max(x0, x1, x2);
          var min = Math.min(x0, x1, x2);
          if (max > 0.9 && min < 0.1) {
            if (x0 < 0.2)
              uvBuffer[i3 + 0] += 1;
            if (x1 < 0.2)
              uvBuffer[i3 + 2] += 1;
            if (x2 < 0.2)
              uvBuffer[i3 + 4] += 1;
          }
        }
      }
      function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
      }
      function getVertexByIndex(index2, vertex) {
        var stride = index2 * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
      }
      function correctUVs() {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();
        var centroid = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        for (var i3 = 0, j = 0; i3 < vertexBuffer.length; i3 += 9, j += 6) {
          a.set(vertexBuffer[i3 + 0], vertexBuffer[i3 + 1], vertexBuffer[i3 + 2]);
          b.set(vertexBuffer[i3 + 3], vertexBuffer[i3 + 4], vertexBuffer[i3 + 5]);
          c.set(vertexBuffer[i3 + 6], vertexBuffer[i3 + 7], vertexBuffer[i3 + 8]);
          uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
          uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
          uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
          centroid.copy(a).add(b).add(c).divideScalar(3);
          var azi = azimuth(centroid);
          correctUV(uvA, j + 0, a, azi);
          correctUV(uvB, j + 2, b, azi);
          correctUV(uvC, j + 4, c, azi);
        }
      }
      function correctUV(uv, stride, vector, azimuth2) {
        if (azimuth2 < 0 && uv.x === 1) {
          uvBuffer[stride] = uv.x - 1;
        }
        if (vector.x === 0 && vector.z === 0) {
          uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
      }
    }
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
    function TetrahedronGeometry(radius, detail) {
      Geometry.call(this);
      this.type = "TetrahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
      this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
      this.mergeVertices();
    }
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
    function TetrahedronBufferGeometry(radius, detail) {
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
      this.type = "TetrahedronBufferGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
    function OctahedronGeometry(radius, detail) {
      Geometry.call(this);
      this.type = "OctahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
      this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
      this.mergeVertices();
    }
    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;
    function OctahedronBufferGeometry(radius, detail) {
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
      this.type = "OctahedronBufferGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
    function IcosahedronGeometry(radius, detail) {
      Geometry.call(this);
      this.type = "IcosahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
      this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
      this.mergeVertices();
    }
    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
    function IcosahedronBufferGeometry(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
      this.type = "IcosahedronBufferGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
    function DodecahedronGeometry(radius, detail) {
      Geometry.call(this);
      this.type = "DodecahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
      this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
      this.mergeVertices();
    }
    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
    function DodecahedronBufferGeometry(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
      this.type = "DodecahedronBufferGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
      Geometry.call(this);
      this.type = "TubeGeometry";
      this.parameters = {
        path,
        tubularSegments,
        radius,
        radialSegments,
        closed
      };
      if (taper !== void 0)
        console.warn("THREE.TubeGeometry: taper has been removed.");
      var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
      this.tangents = bufferGeometry.tangents;
      this.normals = bufferGeometry.normals;
      this.binormals = bufferGeometry.binormals;
      this.fromBufferGeometry(bufferGeometry);
      this.mergeVertices();
    }
    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
      BufferGeometry.call(this);
      this.type = "TubeBufferGeometry";
      this.parameters = {
        path,
        tubularSegments,
        radius,
        radialSegments,
        closed
      };
      tubularSegments = tubularSegments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;
      var frames = path.computeFrenetFrames(tubularSegments, closed);
      this.tangents = frames.tangents;
      this.normals = frames.normals;
      this.binormals = frames.binormals;
      var vertex = new Vector3();
      var normal = new Vector3();
      var uv = new Vector2();
      var P = new Vector3();
      var i3, j;
      var vertices = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      generateBufferData();
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function generateBufferData() {
        for (i3 = 0; i3 < tubularSegments; i3++) {
          generateSegment(i3);
        }
        generateSegment(closed === false ? tubularSegments : 0);
        generateUVs();
        generateIndices();
      }
      function generateSegment(i4) {
        P = path.getPointAt(i4 / tubularSegments, P);
        var N = frames.normals[i4];
        var B = frames.binormals[i4];
        for (j = 0; j <= radialSegments; j++) {
          var v = j / radialSegments * Math.PI * 2;
          var sin = Math.sin(v);
          var cos = -Math.cos(v);
          normal.x = cos * N.x + sin * B.x;
          normal.y = cos * N.y + sin * B.y;
          normal.z = cos * N.z + sin * B.z;
          normal.normalize();
          normals.push(normal.x, normal.y, normal.z);
          vertex.x = P.x + radius * normal.x;
          vertex.y = P.y + radius * normal.y;
          vertex.z = P.z + radius * normal.z;
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
      function generateIndices() {
        for (j = 1; j <= tubularSegments; j++) {
          for (i3 = 1; i3 <= radialSegments; i3++) {
            var a = (radialSegments + 1) * (j - 1) + (i3 - 1);
            var b = (radialSegments + 1) * j + (i3 - 1);
            var c = (radialSegments + 1) * j + i3;
            var d2 = (radialSegments + 1) * (j - 1) + i3;
            indices.push(a, b, d2);
            indices.push(b, c, d2);
          }
        }
      }
      function generateUVs() {
        for (i3 = 0; i3 <= tubularSegments; i3++) {
          for (j = 0; j <= radialSegments; j++) {
            uv.x = i3 / tubularSegments;
            uv.y = j / radialSegments;
            uvs.push(uv.x, uv.y);
          }
        }
      }
    }
    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
    TubeBufferGeometry.prototype.toJSON = function() {
      var data = BufferGeometry.prototype.toJSON.call(this);
      data.path = this.parameters.path.toJSON();
      return data;
    };
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
      Geometry.call(this);
      this.type = "TorusKnotGeometry";
      this.parameters = {
        radius,
        tube,
        tubularSegments,
        radialSegments,
        p,
        q
      };
      if (heightScale !== void 0)
        console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
      this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
      this.mergeVertices();
    }
    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
      BufferGeometry.call(this);
      this.type = "TorusKnotBufferGeometry";
      this.parameters = {
        radius,
        tube,
        tubularSegments,
        radialSegments,
        p,
        q
      };
      radius = radius || 1;
      tube = tube || 0.4;
      tubularSegments = Math.floor(tubularSegments) || 64;
      radialSegments = Math.floor(radialSegments) || 8;
      p = p || 2;
      q = q || 3;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var i3, j;
      var vertex = new Vector3();
      var normal = new Vector3();
      var P1 = new Vector3();
      var P2 = new Vector3();
      var B = new Vector3();
      var T = new Vector3();
      var N = new Vector3();
      for (i3 = 0; i3 <= tubularSegments; ++i3) {
        var u = i3 / tubularSegments * p * Math.PI * 2;
        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        B.normalize();
        N.normalize();
        for (j = 0; j <= radialSegments; ++j) {
          var v = j / radialSegments * Math.PI * 2;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);
          vertex.x = P1.x + (cx * N.x + cy * B.x);
          vertex.y = P1.y + (cx * N.y + cy * B.y);
          vertex.z = P1.z + (cx * N.z + cy * B.z);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.subVectors(vertex, P1).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(i3 / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }
      for (j = 1; j <= tubularSegments; j++) {
        for (i3 = 1; i3 <= radialSegments; i3++) {
          var a = (radialSegments + 1) * (j - 1) + (i3 - 1);
          var b = (radialSegments + 1) * j + (i3 - 1);
          var c = (radialSegments + 1) * j + i3;
          var d2 = (radialSegments + 1) * (j - 1) + i3;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function calculatePositionOnCurve(u2, p2, q2, radius2, position) {
        var cu = Math.cos(u2);
        var su = Math.sin(u2);
        var quOverP = q2 / p2 * u2;
        var cs = Math.cos(quOverP);
        position.x = radius2 * (2 + cs) * 0.5 * cu;
        position.y = radius2 * (2 + cs) * su * 0.5;
        position.z = radius2 * Math.sin(quOverP) * 0.5;
      }
    }
    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
      Geometry.call(this);
      this.type = "TorusGeometry";
      this.parameters = {
        radius,
        tube,
        radialSegments,
        tubularSegments,
        arc
      };
      this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
      this.mergeVertices();
    }
    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
      BufferGeometry.call(this);
      this.type = "TorusBufferGeometry";
      this.parameters = {
        radius,
        tube,
        radialSegments,
        tubularSegments,
        arc
      };
      radius = radius || 1;
      tube = tube || 0.4;
      radialSegments = Math.floor(radialSegments) || 8;
      tubularSegments = Math.floor(tubularSegments) || 6;
      arc = arc || Math.PI * 2;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var center = new Vector3();
      var vertex = new Vector3();
      var normal = new Vector3();
      var j, i3;
      for (j = 0; j <= radialSegments; j++) {
        for (i3 = 0; i3 <= tubularSegments; i3++) {
          var u = i3 / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          vertices.push(vertex.x, vertex.y, vertex.z);
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          normal.subVectors(vertex, center).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(i3 / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }
      for (j = 1; j <= radialSegments; j++) {
        for (i3 = 1; i3 <= tubularSegments; i3++) {
          var a = (tubularSegments + 1) * j + i3 - 1;
          var b = (tubularSegments + 1) * (j - 1) + i3 - 1;
          var c = (tubularSegments + 1) * (j - 1) + i3;
          var d2 = (tubularSegments + 1) * j + i3;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    var Earcut = {
      triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i3 = dim; i3 < outerLen; i3 += dim) {
            x = data[i3];
            y2 = data[i3 + 1];
            if (x < minX)
              minX = x;
            if (y2 < minY)
              minY = y2;
            if (x > maxX)
              maxX = x;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
    };
    function linkedList(data, start, end, dim, clockwise) {
      var i3, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i3 = start; i3 < end; i3 += dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      } else {
        for (i3 = end - dim; i3 >= start; i3 -= dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev2, next;
      while (ear.prev !== ear.next) {
        prev2 = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev2.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(ear, triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize);
            earcutLinked(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i3, len, start, end, list;
      for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
        start = holeIndices[i3] * dim;
        end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i3 = 0; i3 < queue.length; i3++) {
        eliminateHole(queue[i3], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y)
                return p;
              if (hy === p.next.y)
                return p.next;
            }
            m2 = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m2)
        return null;
      if (hx === qx)
        return m2.prev;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p = m2.next;
      while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if ((tan < tanMin || tan === tanMin && p.x > m2.x) && locallyInside(p, hole)) {
            m2 = p;
            tanMin = tan;
          }
        }
        p = p.next;
      }
      return m2;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === null)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i3, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i3 = 0; i3 < inSize; i3++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y2, minX, minY, invSize) {
      x = 32767 * (x - minX) * invSize;
      y2 = 32767 * (y2 - minY) * invSize;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x | y2 << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
      return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      if (equals(p1, p2) && equals(q1, q2) || equals(p1, q2) && equals(p2, q1))
        return true;
      return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
      do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i3, x, y2, last) {
      var p = new Node(i3, x, y2);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i3, x, y2) {
      this.i = i3;
      this.x = x;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i3 = start, j = end - dim; i3 < end; i3 += dim) {
        sum += (data[j] - data[i3]) * (data[i3 + 1] + data[j + 1]);
        j = i3;
      }
      return sum;
    }
    var ShapeUtils = {
      area: function(contour) {
        var n = contour.length;
        var a = 0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      },
      isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
      },
      triangulateShape: function(contour, holes) {
        var vertices = [];
        var holeIndices = [];
        var faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        var holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (var i3 = 0; i3 < holes.length; i3++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i3].length;
          addContour(vertices, holes[i3]);
        }
        var triangles = Earcut.triangulate(vertices, holeIndices);
        for (var i3 = 0; i3 < triangles.length; i3 += 3) {
          faces.push(triangles.slice(i3, i3 + 3));
        }
        return faces;
      }
    };
    function removeDupEndPts(points) {
      var l = points.length;
      if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
      }
    }
    function addContour(vertices, contour) {
      for (var i3 = 0; i3 < contour.length; i3++) {
        vertices.push(contour[i3].x);
        vertices.push(contour[i3].y);
      }
    }
    function ExtrudeGeometry(shapes, options) {
      Geometry.call(this);
      this.type = "ExtrudeGeometry";
      this.parameters = {
        shapes,
        options
      };
      this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
      this.mergeVertices();
    }
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
    ExtrudeGeometry.prototype.toJSON = function() {
      var data = Geometry.prototype.toJSON.call(this);
      var shapes = this.parameters.shapes;
      var options = this.parameters.options;
      return toJSON(shapes, options, data);
    };
    function ExtrudeBufferGeometry(shapes, options) {
      BufferGeometry.call(this);
      this.type = "ExtrudeBufferGeometry";
      this.parameters = {
        shapes,
        options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      var scope = this;
      var verticesArray = [];
      var uvArray = [];
      for (var i3 = 0, l = shapes.length; i3 < l; i3++) {
        var shape = shapes[i3];
        addShape(shape);
      }
      this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
      this.computeVertexNormals();
      function addShape(shape2) {
        var placeholder = [];
        var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
        var steps = options.steps !== void 0 ? options.steps : 1;
        var depth = options.depth !== void 0 ? options.depth : 100;
        var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
        var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
        var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
        var bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
        var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
        var extrudePath = options.extrudePath;
        var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
        if (options.amount !== void 0) {
          console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
          depth = options.amount;
        }
        var extrudePts, extrudeByPath = false;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false;
          splineTube = extrudePath.computeFrenetFrames(steps, false);
          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }
        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }
        var ahole, h2, hl;
        var shapePoints = shape2.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();
          for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
            ahole = holes[h2];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h2] = ahole.reverse();
            }
          }
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        var contour = vertices;
        for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
          ahole = holes[h2];
          vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
          if (!vec)
            console.error("THREE.ExtrudeGeometry: vec does not exist");
          return vec.clone().multiplyScalar(size).add(pt);
        }
        var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
          var v_trans_x, v_trans_y, shrink_by;
          var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
          var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
          var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
          var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            var v_prev_len = Math.sqrt(v_prev_lensq);
            var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            var ptNextShift_x = inNext.x - v_next_y / v_next_len;
            var ptNextShift_y = inNext.y + v_next_x / v_next_len;
            var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            var direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for (var i4 = 0, il = contour.length, j = il - 1, k = i4 + 1; i4 < il; i4++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          contourMovements[i4] = getBevelVec(contour[i4], contour[j], contour[k]);
        }
        var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
        for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
          ahole = holes[h2];
          oneHoleMovements = [];
          for (i4 = 0, il = ahole.length, j = il - 1, k = i4 + 1; i4 < il; i4++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            oneHoleMovements[i4] = getBevelVec(ahole[i4], ahole[j], ahole[k]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; b < bevelSegments; b++) {
          t = b / bevelSegments;
          z = bevelThickness * Math.cos(t * Math.PI / 2);
          bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (i4 = 0, il = contour.length; i4 < il; i4++) {
            vert = scalePt2(contour[i4], contourMovements[i4], bs);
            v(vert.x, vert.y, -z);
          }
          for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
            ahole = holes[h2];
            oneHoleMovements = holesMovements[h2];
            for (i4 = 0, il = ahole.length; i4 < il; i4++) {
              vert = scalePt2(ahole[i4], oneHoleMovements[i4], bs);
              v(vert.x, vert.y, -z);
            }
          }
        }
        bs = bevelSize + bevelOffset;
        for (i4 = 0; i4 < vlen; i4++) {
          vert = bevelEnabled ? scalePt2(vertices[i4], verticesMovements[i4], bs) : vertices[i4];
          if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
          } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
        var s2;
        for (s2 = 1; s2 <= steps; s2++) {
          for (i4 = 0; i4 < vlen; i4++) {
            vert = bevelEnabled ? scalePt2(vertices[i4], verticesMovements[i4], bs) : vertices[i4];
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth / steps * s2);
            } else {
              normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
              position2.copy(extrudePts[s2]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
        }
        for (b = bevelSegments - 1; b >= 0; b--) {
          t = b / bevelSegments;
          z = bevelThickness * Math.cos(t * Math.PI / 2);
          bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (i4 = 0, il = contour.length; i4 < il; i4++) {
            vert = scalePt2(contour[i4], contourMovements[i4], bs);
            v(vert.x, vert.y, depth + z);
          }
          for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
            ahole = holes[h2];
            oneHoleMovements = holesMovements[h2];
            for (i4 = 0, il = ahole.length; i4 < il; i4++) {
              vert = scalePt2(ahole[i4], oneHoleMovements[i4], bs);
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth + z);
              } else {
                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
              }
            }
          }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
          var start = verticesArray.length / 3;
          if (bevelEnabled) {
            var layer = 0;
            var offset = vlen * layer;
            for (i4 = 0; i4 < flen; i4++) {
              face = faces[i4];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (i4 = 0; i4 < flen; i4++) {
              face = faces[i4];
              f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
          } else {
            for (i4 = 0; i4 < flen; i4++) {
              face = faces[i4];
              f3(face[2], face[1], face[0]);
            }
            for (i4 = 0; i4 < flen; i4++) {
              face = faces[i4];
              f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        function buildSideFaces() {
          var start = verticesArray.length / 3;
          var layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (h2 = 0, hl = holes.length; h2 < hl; h2++) {
            ahole = holes[h2];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour2, layeroffset) {
          var j2, k2;
          i4 = contour2.length;
          while (--i4 >= 0) {
            j2 = i4;
            k2 = i4 - 1;
            if (k2 < 0)
              k2 = contour2.length - 1;
            var s3 = 0, sl = steps + bevelSegments * 2;
            for (s3 = 0; s3 < sl; s3++) {
              var slen1 = vlen * s3;
              var slen2 = vlen * (s3 + 1);
              var a = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
              f4(a, b2, c, d2);
            }
          }
        }
        function v(x, y2, z2) {
          placeholder.push(x);
          placeholder.push(y2);
          placeholder.push(z2);
        }
        function f3(a, b2, c) {
          addVertex(a);
          addVertex(b2);
          addVertex(c);
          var nextIndex = verticesArray.length / 3;
          var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a, b2, c, d2) {
          addVertex(a);
          addVertex(b2);
          addVertex(d2);
          addVertex(b2);
          addVertex(c);
          addVertex(d2);
          var nextIndex = verticesArray.length / 3;
          var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index2) {
          verticesArray.push(placeholder[index2 * 3 + 0]);
          verticesArray.push(placeholder[index2 * 3 + 1]);
          verticesArray.push(placeholder[index2 * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
    }
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
    ExtrudeBufferGeometry.prototype.toJSON = function() {
      var data = BufferGeometry.prototype.toJSON.call(this);
      var shapes = this.parameters.shapes;
      var options = this.parameters.options;
      return toJSON(shapes, options, data);
    };
    var WorldUVGenerator = {
      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
      },
      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var a_z = vertices[indexA * 3 + 2];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var b_z = vertices[indexB * 3 + 2];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        var c_z = vertices[indexC * 3 + 2];
        var d_x = vertices[indexD * 3];
        var d_y = vertices[indexD * 3 + 1];
        var d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) {
          return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
        } else {
          return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
        }
      }
    };
    function toJSON(shapes, options, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (var i3 = 0, l = shapes.length; i3 < l; i3++) {
          var shape = shapes[i3];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      if (options.extrudePath !== void 0)
        data.options.extrudePath = options.extrudePath.toJSON();
      return data;
    }
    function TextGeometry(text2, parameters) {
      Geometry.call(this);
      this.type = "TextGeometry";
      this.parameters = {
        text: text2,
        parameters
      };
      this.fromBufferGeometry(new TextBufferGeometry(text2, parameters));
      this.mergeVertices();
    }
    TextGeometry.prototype = Object.create(Geometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;
    function TextBufferGeometry(text2, parameters) {
      parameters = parameters || {};
      var font = parameters.font;
      if (!(font && font.isFont)) {
        console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
        return new Geometry();
      }
      var shapes = font.generateShapes(text2, parameters.size);
      parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0)
        parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0)
        parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0)
        parameters.bevelEnabled = false;
      ExtrudeBufferGeometry.call(this, shapes, parameters);
      this.type = "TextBufferGeometry";
    }
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      Geometry.call(this);
      this.type = "SphereGeometry";
      this.parameters = {
        radius,
        widthSegments,
        heightSegments,
        phiStart,
        phiLength,
        thetaStart,
        thetaLength
      };
      this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
      this.mergeVertices();
    }
    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      BufferGeometry.call(this);
      this.type = "SphereBufferGeometry";
      this.parameters = {
        radius,
        widthSegments,
        heightSegments,
        phiStart,
        phiLength,
        thetaStart,
        thetaLength
      };
      radius = radius || 1;
      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
      phiStart = phiStart !== void 0 ? phiStart : 0;
      phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
      thetaStart = thetaStart !== void 0 ? thetaStart : 0;
      thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
      var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
      var ix, iy;
      var index2 = 0;
      var grid = [];
      var vertex = new Vector3();
      var normal = new Vector3();
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      for (iy = 0; iy <= heightSegments; iy++) {
        var verticesRow = [];
        var v = iy / heightSegments;
        var uOffset = 0;
        if (iy == 0 && thetaStart == 0) {
          uOffset = 0.5 / widthSegments;
        } else if (iy == heightSegments && thetaEnd == Math.PI) {
          uOffset = -0.5 / widthSegments;
        }
        for (ix = 0; ix <= widthSegments; ix++) {
          var u = ix / widthSegments;
          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.copy(vertex).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u + uOffset, 1 - v);
          verticesRow.push(index2++);
        }
        grid.push(verticesRow);
      }
      for (iy = 0; iy < heightSegments; iy++) {
        for (ix = 0; ix < widthSegments; ix++) {
          var a = grid[iy][ix + 1];
          var b = grid[iy][ix];
          var c = grid[iy + 1][ix];
          var d2 = grid[iy + 1][ix + 1];
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b, d2);
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      Geometry.call(this);
      this.type = "RingGeometry";
      this.parameters = {
        innerRadius,
        outerRadius,
        thetaSegments,
        phiSegments,
        thetaStart,
        thetaLength
      };
      this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
      this.mergeVertices();
    }
    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      BufferGeometry.call(this);
      this.type = "RingBufferGeometry";
      this.parameters = {
        innerRadius,
        outerRadius,
        thetaSegments,
        phiSegments,
        thetaStart,
        thetaLength
      };
      innerRadius = innerRadius || 0.5;
      outerRadius = outerRadius || 1;
      thetaStart = thetaStart !== void 0 ? thetaStart : 0;
      thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
      thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var segment;
      var radius = innerRadius;
      var radiusStep = (outerRadius - innerRadius) / phiSegments;
      var vertex = new Vector3();
      var uv = new Vector2();
      var j, i3;
      for (j = 0; j <= phiSegments; j++) {
        for (i3 = 0; i3 <= thetaSegments; i3++) {
          segment = thetaStart + i3 / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, 0, 1);
          uv.x = (vertex.x / outerRadius + 1) / 2;
          uv.y = (vertex.y / outerRadius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        radius += radiusStep;
      }
      for (j = 0; j < phiSegments; j++) {
        var thetaSegmentLevel = j * (thetaSegments + 1);
        for (i3 = 0; i3 < thetaSegments; i3++) {
          segment = i3 + thetaSegmentLevel;
          var a = segment;
          var b = segment + thetaSegments + 1;
          var c = segment + thetaSegments + 2;
          var d2 = segment + 1;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;
    function LatheGeometry(points, segments, phiStart, phiLength) {
      Geometry.call(this);
      this.type = "LatheGeometry";
      this.parameters = {
        points,
        segments,
        phiStart,
        phiLength
      };
      this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
      this.mergeVertices();
    }
    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
      BufferGeometry.call(this);
      this.type = "LatheBufferGeometry";
      this.parameters = {
        points,
        segments,
        phiStart,
        phiLength
      };
      segments = Math.floor(segments) || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || Math.PI * 2;
      phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
      var indices = [];
      var vertices = [];
      var uvs = [];
      var base;
      var inverseSegments = 1 / segments;
      var vertex = new Vector3();
      var uv = new Vector2();
      var i3, j;
      for (i3 = 0; i3 <= segments; i3++) {
        var phi = phiStart + i3 * inverseSegments * phiLength;
        var sin = Math.sin(phi);
        var cos = Math.cos(phi);
        for (j = 0; j <= points.length - 1; j++) {
          vertex.x = points[j].x * sin;
          vertex.y = points[j].y;
          vertex.z = points[j].x * cos;
          vertices.push(vertex.x, vertex.y, vertex.z);
          uv.x = i3 / segments;
          uv.y = j / (points.length - 1);
          uvs.push(uv.x, uv.y);
        }
      }
      for (i3 = 0; i3 < segments; i3++) {
        for (j = 0; j < points.length - 1; j++) {
          base = j + i3 * points.length;
          var a = base;
          var b = base + points.length;
          var c = base + points.length + 1;
          var d2 = base + 1;
          indices.push(a, b, d2);
          indices.push(b, c, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      this.computeVertexNormals();
      if (phiLength === Math.PI * 2) {
        var normals = this.attributes.normal.array;
        var n1 = new Vector3();
        var n2 = new Vector3();
        var n = new Vector3();
        base = segments * points.length * 3;
        for (i3 = 0, j = 0; i3 < points.length; i3++, j += 3) {
          n1.x = normals[j + 0];
          n1.y = normals[j + 1];
          n1.z = normals[j + 2];
          n2.x = normals[base + j + 0];
          n2.y = normals[base + j + 1];
          n2.z = normals[base + j + 2];
          n.addVectors(n1, n2).normalize();
          normals[j + 0] = normals[base + j + 0] = n.x;
          normals[j + 1] = normals[base + j + 1] = n.y;
          normals[j + 2] = normals[base + j + 2] = n.z;
        }
      }
    }
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
    function ShapeGeometry(shapes, curveSegments) {
      Geometry.call(this);
      this.type = "ShapeGeometry";
      if (typeof curveSegments === "object") {
        console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
        curveSegments = curveSegments.curveSegments;
      }
      this.parameters = {
        shapes,
        curveSegments
      };
      this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
      this.mergeVertices();
    }
    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    ShapeGeometry.prototype.toJSON = function() {
      var data = Geometry.prototype.toJSON.call(this);
      var shapes = this.parameters.shapes;
      return toJSON$1(shapes, data);
    };
    function ShapeBufferGeometry(shapes, curveSegments) {
      BufferGeometry.call(this);
      this.type = "ShapeBufferGeometry";
      this.parameters = {
        shapes,
        curveSegments
      };
      curveSegments = curveSegments || 12;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var groupStart = 0;
      var groupCount = 0;
      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (var i3 = 0; i3 < shapes.length; i3++) {
          addShape(shapes[i3]);
          this.addGroup(groupStart, groupCount, i3);
          groupStart += groupCount;
          groupCount = 0;
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function addShape(shape) {
        var i4, l, shapeHole;
        var indexOffset = vertices.length / 3;
        var points = shape.extractPoints(curveSegments);
        var shapeVertices = points.shape;
        var shapeHoles = points.holes;
        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (i4 = 0, l = shapeHoles.length; i4 < l; i4++) {
          shapeHole = shapeHoles[i4];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[i4] = shapeHole.reverse();
          }
        }
        var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        for (i4 = 0, l = shapeHoles.length; i4 < l; i4++) {
          shapeHole = shapeHoles[i4];
          shapeVertices = shapeVertices.concat(shapeHole);
        }
        for (i4 = 0, l = shapeVertices.length; i4 < l; i4++) {
          var vertex = shapeVertices[i4];
          vertices.push(vertex.x, vertex.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex.x, vertex.y);
        }
        for (i4 = 0, l = faces.length; i4 < l; i4++) {
          var face = faces[i4];
          var a = face[0] + indexOffset;
          var b = face[1] + indexOffset;
          var c = face[2] + indexOffset;
          indices.push(a, b, c);
          groupCount += 3;
        }
      }
    }
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    ShapeBufferGeometry.prototype.toJSON = function() {
      var data = BufferGeometry.prototype.toJSON.call(this);
      var shapes = this.parameters.shapes;
      return toJSON$1(shapes, data);
    };
    function toJSON$1(shapes, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (var i3 = 0, l = shapes.length; i3 < l; i3++) {
          var shape = shapes[i3];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      return data;
    }
    function EdgesGeometry(geometry, thresholdAngle) {
      BufferGeometry.call(this);
      this.type = "EdgesGeometry";
      this.parameters = {
        thresholdAngle
      };
      thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
      var vertices = [];
      var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
      var edge = [0, 0], edges = {}, edge1, edge2;
      var key, keys2 = ["a", "b", "c"];
      var geometry2;
      if (geometry.isBufferGeometry) {
        geometry2 = new Geometry();
        geometry2.fromBufferGeometry(geometry);
      } else {
        geometry2 = geometry.clone();
      }
      geometry2.mergeVertices();
      geometry2.computeFaceNormals();
      var sourceVertices = geometry2.vertices;
      var faces = geometry2.faces;
      for (var i3 = 0, l = faces.length; i3 < l; i3++) {
        var face = faces[i3];
        for (var j = 0; j < 3; j++) {
          edge1 = face[keys2[j]];
          edge2 = face[keys2[(j + 1) % 3]];
          edge[0] = Math.min(edge1, edge2);
          edge[1] = Math.max(edge1, edge2);
          key = edge[0] + "," + edge[1];
          if (edges[key] === void 0) {
            edges[key] = {
              index1: edge[0],
              index2: edge[1],
              face1: i3,
              face2: void 0
            };
          } else {
            edges[key].face2 = i3;
          }
        }
      }
      for (key in edges) {
        var e = edges[key];
        if (e.face2 === void 0 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
          var vertex = sourceVertices[e.index1];
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex = sourceVertices[e.index2];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      Geometry.call(this);
      this.type = "CylinderGeometry";
      this.parameters = {
        radiusTop,
        radiusBottom,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
      this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
      this.mergeVertices();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      BufferGeometry.call(this);
      this.type = "CylinderBufferGeometry";
      this.parameters = {
        radiusTop,
        radiusBottom,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
      var scope = this;
      radiusTop = radiusTop !== void 0 ? radiusTop : 1;
      radiusBottom = radiusBottom !== void 0 ? radiusBottom : 1;
      height = height || 1;
      radialSegments = Math.floor(radialSegments) || 8;
      heightSegments = Math.floor(heightSegments) || 1;
      openEnded = openEnded !== void 0 ? openEnded : false;
      thetaStart = thetaStart !== void 0 ? thetaStart : 0;
      thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var index2 = 0;
      var indexArray = [];
      var halfHeight = height / 2;
      var groupStart = 0;
      generateTorso();
      if (openEnded === false) {
        if (radiusTop > 0)
          generateCap(true);
        if (radiusBottom > 0)
          generateCap(false);
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function generateTorso() {
        var x, y2;
        var normal = new Vector3();
        var vertex = new Vector3();
        var groupCount = 0;
        var slope = (radiusBottom - radiusTop) / height;
        for (y2 = 0; y2 <= heightSegments; y2++) {
          var indexRow = [];
          var v = y2 / heightSegments;
          var radius = v * (radiusBottom - radiusTop) + radiusTop;
          for (x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            var theta = u * thetaLength + thetaStart;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            vertex.x = radius * sinTheta;
            vertex.y = -v * height + halfHeight;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            normal.set(sinTheta, slope, cosTheta).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(u, 1 - v);
            indexRow.push(index2++);
          }
          indexArray.push(indexRow);
        }
        for (x = 0; x < radialSegments; x++) {
          for (y2 = 0; y2 < heightSegments; y2++) {
            var a = indexArray[y2][x];
            var b = indexArray[y2 + 1][x];
            var c = indexArray[y2 + 1][x + 1];
            var d2 = indexArray[y2][x + 1];
            indices.push(a, b, d2);
            indices.push(b, c, d2);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, 0);
        groupStart += groupCount;
      }
      function generateCap(top) {
        var x, centerIndexStart, centerIndexEnd;
        var uv = new Vector2();
        var vertex = new Vector3();
        var groupCount = 0;
        var radius = top === true ? radiusTop : radiusBottom;
        var sign = top === true ? 1 : -1;
        centerIndexStart = index2;
        for (x = 1; x <= radialSegments; x++) {
          vertices.push(0, halfHeight * sign, 0);
          normals.push(0, sign, 0);
          uvs.push(0.5, 0.5);
          index2++;
        }
        centerIndexEnd = index2;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var cosTheta = Math.cos(theta);
          var sinTheta = Math.sin(theta);
          vertex.x = radius * sinTheta;
          vertex.y = halfHeight * sign;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, sign, 0);
          uv.x = cosTheta * 0.5 + 0.5;
          uv.y = sinTheta * 0.5 * sign + 0.5;
          uvs.push(uv.x, uv.y);
          index2++;
        }
        for (x = 0; x < radialSegments; x++) {
          var c = centerIndexStart + x;
          var i3 = centerIndexEnd + x;
          if (top === true) {
            indices.push(i3, i3 + 1, c);
          } else {
            indices.push(i3 + 1, i3, c);
          }
          groupCount += 3;
        }
        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
        groupStart += groupCount;
      }
    }
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
      this.type = "ConeGeometry";
      this.parameters = {
        radius,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
    }
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
      this.type = "ConeBufferGeometry";
      this.parameters = {
        radius,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
    }
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
      Geometry.call(this);
      this.type = "CircleGeometry";
      this.parameters = {
        radius,
        segments,
        thetaStart,
        thetaLength
      };
      this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
      this.mergeVertices();
    }
    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
      BufferGeometry.call(this);
      this.type = "CircleBufferGeometry";
      this.parameters = {
        radius,
        segments,
        thetaStart,
        thetaLength
      };
      radius = radius || 1;
      segments = segments !== void 0 ? Math.max(3, segments) : 8;
      thetaStart = thetaStart !== void 0 ? thetaStart : 0;
      thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var i3, s2;
      var vertex = new Vector3();
      var uv = new Vector2();
      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);
      for (s2 = 0, i3 = 3; s2 <= segments; s2++, i3 += 3) {
        var segment = thetaStart + s2 / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertices[i3] / radius + 1) / 2;
        uv.y = (vertices[i3 + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      for (i3 = 1; i3 <= segments; i3++) {
        indices.push(i3, i3 + 1, 0);
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    var Geometries = Object.freeze({
      __proto__: null,
      WireframeGeometry,
      ParametricGeometry,
      ParametricBufferGeometry,
      TetrahedronGeometry,
      TetrahedronBufferGeometry,
      OctahedronGeometry,
      OctahedronBufferGeometry,
      IcosahedronGeometry,
      IcosahedronBufferGeometry,
      DodecahedronGeometry,
      DodecahedronBufferGeometry,
      PolyhedronGeometry,
      PolyhedronBufferGeometry,
      TubeGeometry,
      TubeBufferGeometry,
      TorusKnotGeometry,
      TorusKnotBufferGeometry,
      TorusGeometry,
      TorusBufferGeometry,
      TextGeometry,
      TextBufferGeometry,
      SphereGeometry,
      SphereBufferGeometry,
      RingGeometry,
      RingBufferGeometry,
      PlaneGeometry,
      PlaneBufferGeometry,
      LatheGeometry,
      LatheBufferGeometry,
      ShapeGeometry,
      ShapeBufferGeometry,
      ExtrudeGeometry,
      ExtrudeBufferGeometry,
      EdgesGeometry,
      ConeGeometry,
      ConeBufferGeometry,
      CylinderGeometry,
      CylinderBufferGeometry,
      CircleGeometry,
      CircleBufferGeometry,
      BoxGeometry,
      BoxBufferGeometry
    });
    function ShadowMaterial(parameters) {
      Material.call(this);
      this.type = "ShadowMaterial";
      this.color = new Color(0);
      this.transparent = true;
      this.setValues(parameters);
    }
    ShadowMaterial.prototype = Object.create(Material.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;
    ShadowMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      return this;
    };
    function RawShaderMaterial(parameters) {
      ShaderMaterial.call(this, parameters);
      this.type = "RawShaderMaterial";
    }
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    function MeshStandardMaterial(parameters) {
      Material.call(this);
      this.defines = {
        STANDARD: ""
      };
      this.type = "MeshStandardMaterial";
      this.color = new Color(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapIntensity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.defines = {
        STANDARD: ""
      };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function MeshPhysicalMaterial(parameters) {
      MeshStandardMaterial.call(this);
      this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      };
      this.type = "MeshPhysicalMaterial";
      this.reflectivity = 0.5;
      this.clearcoat = 0;
      this.clearcoatRoughness = 0;
      this.sheen = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;
      this.transparency = 0;
      this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function(source) {
      MeshStandardMaterial.prototype.copy.call(this, source);
      this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      };
      this.reflectivity = source.reflectivity;
      this.clearcoat = source.clearcoat;
      this.clearcoatRoughness = source.clearcoatRoughness;
      if (source.sheen)
        this.sheen = (this.sheen || new Color()).copy(source.sheen);
      else
        this.sheen = null;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.transparency = source.transparency;
      return this;
    };
    function MeshPhongMaterial(parameters) {
      Material.call(this);
      this.type = "MeshPhongMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function MeshToonMaterial(parameters) {
      Material.call(this);
      this.defines = {
        TOON: ""
      };
      this.type = "MeshToonMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.gradientMap = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshToonMaterial.prototype = Object.create(Material.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function MeshNormalMaterial(parameters) {
      Material.call(this);
      this.type = "MeshNormalMaterial";
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function MeshLambertMaterial(parameters) {
      Material.call(this);
      this.type = "MeshLambertMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function MeshMatcapMaterial(parameters) {
      Material.call(this);
      this.defines = {
        MATCAP: ""
      };
      this.type = "MeshMatcapMaterial";
      this.color = new Color(16777215);
      this.matcap = null;
      this.map = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    MeshMatcapMaterial.prototype = Object.create(Material.prototype);
    MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    MeshMatcapMaterial.prototype.copy = function(source) {
      Material.prototype.copy.call(this, source);
      this.defines = {
        MATCAP: ""
      };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    function LineDashedMaterial(parameters) {
      LineBasicMaterial.call(this);
      this.type = "LineDashedMaterial";
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.setValues(parameters);
    }
    LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function(source) {
      LineBasicMaterial.prototype.copy.call(this, source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    };
    var Materials = Object.freeze({
      __proto__: null,
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    });
    var AnimationUtils = {
      arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) {
          return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
        }
        return array.slice(from, to);
      },
      convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
          return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array);
        }
        return Array.prototype.slice.call(array);
      },
      isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function(times) {
        function compareTime(i4, j) {
          return times[i4] - times[j];
        }
        var n = times.length;
        var result = new Array(n);
        for (var i3 = 0; i3 !== n; ++i3)
          result[i3] = i3;
        result.sort(compareTime);
        return result;
      },
      sortedArray: function(values, stride, order) {
        var nValues = values.length;
        var result = new values.constructor(nValues);
        for (var i3 = 0, dstOffset = 0; dstOffset !== nValues; ++i3) {
          var srcOffset = order[i3] * stride;
          for (var j = 0; j !== stride; ++j) {
            result[dstOffset++] = values[srcOffset + j];
          }
        }
        return result;
      },
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        var i3 = 1, key = jsonKeys[0];
        while (key !== void 0 && key[valuePropertyName] === void 0) {
          key = jsonKeys[i3++];
        }
        if (key === void 0)
          return;
        var value2 = key[valuePropertyName];
        if (value2 === void 0)
          return;
        if (Array.isArray(value2)) {
          do {
            value2 = key[valuePropertyName];
            if (value2 !== void 0) {
              times.push(key.time);
              values.push.apply(values, value2);
            }
            key = jsonKeys[i3++];
          } while (key !== void 0);
        } else if (value2.toArray !== void 0) {
          do {
            value2 = key[valuePropertyName];
            if (value2 !== void 0) {
              times.push(key.time);
              value2.toArray(values, values.length);
            }
            key = jsonKeys[i3++];
          } while (key !== void 0);
        } else {
          do {
            value2 = key[valuePropertyName];
            if (value2 !== void 0) {
              times.push(key.time);
              values.push(value2);
            }
            key = jsonKeys[i3++];
          } while (key !== void 0);
        }
      },
      subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        var clip = sourceClip.clone();
        clip.name = name;
        var tracks = [];
        for (var i3 = 0; i3 < clip.tracks.length; ++i3) {
          var track = clip.tracks[i3];
          var valueSize = track.getValueSize();
          var times = [];
          var values = [];
          for (var j = 0; j < track.times.length; ++j) {
            var frame = track.times[j] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j]);
            for (var k = 0; k < valueSize; ++k) {
              values.push(track.values[j * valueSize + k]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils.convertArray(times, track.times.constructor);
          track.values = AnimationUtils.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        var minStartTime = Infinity;
        for (var i3 = 0; i3 < clip.tracks.length; ++i3) {
          if (minStartTime > clip.tracks[i3].times[0]) {
            minStartTime = clip.tracks[i3].times[0];
          }
        }
        for (var i3 = 0; i3 < clip.tracks.length; ++i3) {
          clip.tracks[i3].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      }
    };
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
    }
    Object.assign(Interpolant.prototype, {
      evaluate: function(t) {
        var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            var right;
            linear_scan: {
              forward_scan:
                if (!(t < t1)) {
                  for (var giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.afterEnd_(i1 - 1, t, t0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t >= t0)) {
                var t1global = pp[1];
                if (t < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (var giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              var mid = i1 + right >>> 1;
              if (t < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.beforeStart_(0, t, t1);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.afterEnd_(i1 - 1, t0, t);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t, t1);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function() {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function(index2) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
        for (var i3 = 0; i3 !== stride; ++i3) {
          result[i3] = values[offset + i3];
        }
        return result;
      },
      interpolate_: function() {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function() {
      }
    });
    Object.assign(Interpolant.prototype, {
      beforeStart_: Interpolant.prototype.copySampleValue_,
      afterEnd_: Interpolant.prototype.copySampleValue_
    });
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
    }
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: CubicInterpolant,
      DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      },
      intervalChanged_: function(i1, t0, t1) {
        var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      },
      interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;
        for (var i3 = 0; i3 !== stride; ++i3) {
          result[i3] = sP * values[oP + i3] + s0 * values[o0 + i3] + s1 * values[o1 + i3] + sN * values[oN + i3];
        }
        return result;
      }
    });
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: LinearInterpolant,
      interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (var i3 = 0; i3 !== stride; ++i3) {
          result[i3] = values[offset0 + i3] * weight0 + values[offset1 + i3] * weight1;
        }
        return result;
      }
    });
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: DiscreteInterpolant,
      interpolate_: function(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    });
    function KeyframeTrack(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    Object.assign(KeyframeTrack, {
      toJSON: function(track) {
        var trackType = track.constructor;
        var json;
        if (trackType.toJSON !== void 0) {
          json = trackType.toJSON(track);
        } else {
          json = {
            name: track.name,
            times: AnimationUtils.convertArray(track.times, Array),
            values: AnimationUtils.convertArray(track.values, Array)
          };
          var interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
    });
    Object.assign(KeyframeTrack.prototype, {
      constructor: KeyframeTrack,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: InterpolateLinear,
      InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      setInterpolation: function(interpolation) {
        var factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      },
      getInterpolation: function() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      },
      getValueSize: function() {
        return this.values.length / this.times.length;
      },
      shift: function(timeOffset2) {
        if (timeOffset2 !== 0) {
          var times = this.times;
          for (var i3 = 0, n = times.length; i3 !== n; ++i3) {
            times[i3] += timeOffset2;
          }
        }
        return this;
      },
      scale: function(timeScale) {
        if (timeScale !== 1) {
          var times = this.times;
          for (var i3 = 0, n = times.length; i3 !== n; ++i3) {
            times[i3] *= timeScale;
          }
        }
        return this;
      },
      trim: function(startTime, endTime) {
        var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to)
            to = Math.max(to, 1), from = to - 1;
          var stride = this.getValueSize();
          this.times = AnimationUtils.arraySlice(times, from, to);
          this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
      },
      validate: function() {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        var times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        var prevTime = null;
        for (var i3 = 0; i3 !== nKeys; i3++) {
          var currTime = times[i3];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i3, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i3, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils.isTypedArray(values)) {
            for (var i3 = 0, n = values.length; i3 !== n; ++i3) {
              var value2 = values[i3];
              if (isNaN(value2)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i3, value2);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      },
      optimize: function() {
        var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
        for (var i3 = 1; i3 < lastIndex; ++i3) {
          var keep = false;
          var time2 = times[i3];
          var timeNext = times[i3 + 1];
          if (time2 !== timeNext && (i3 !== 1 || time2 !== time2[0])) {
            if (!smoothInterpolation) {
              var offset = i3 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (var j = 0; j !== stride; ++j) {
                var value2 = values[offset + j];
                if (value2 !== values[offsetP + j] || value2 !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i3 !== writeIndex) {
              times[writeIndex] = times[i3];
              var readOffset = i3 * stride, writeOffset = writeIndex * stride;
              for (var j = 0; j !== stride; ++j) {
                values[writeOffset + j] = values[readOffset + j];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        }
        return this;
      },
      clone: function() {
        var times = AnimationUtils.arraySlice(this.times, 0);
        var values = AnimationUtils.arraySlice(this.values, 0);
        var TypedKeyframeTrack = this.constructor;
        var track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    });
    function BooleanKeyframeTrack(name, times, values) {
      KeyframeTrack.call(this, name, times, values);
    }
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: BooleanKeyframeTrack,
      ValueTypeName: "bool",
      ValueBufferType: Array,
      DefaultInterpolation: InterpolateDiscrete,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    });
    function ColorKeyframeTrack(name, times, values, interpolation) {
      KeyframeTrack.call(this, name, times, values, interpolation);
    }
    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: ColorKeyframeTrack,
      ValueTypeName: "color"
    });
    function NumberKeyframeTrack(name, times, values, interpolation) {
      KeyframeTrack.call(this, name, times, values, interpolation);
    }
    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: NumberKeyframeTrack,
      ValueTypeName: "number"
    });
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
      constructor: QuaternionLinearInterpolant,
      interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
        for (var end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    });
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
      KeyframeTrack.call(this, name, times, values, interpolation);
    }
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: QuaternionKeyframeTrack,
      ValueTypeName: "quaternion",
      DefaultInterpolation: InterpolateLinear,
      InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      },
      InterpolantFactoryMethodSmooth: void 0
    });
    function StringKeyframeTrack(name, times, values, interpolation) {
      KeyframeTrack.call(this, name, times, values, interpolation);
    }
    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: StringKeyframeTrack,
      ValueTypeName: "string",
      ValueBufferType: Array,
      DefaultInterpolation: InterpolateDiscrete,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    });
    function VectorKeyframeTrack(name, times, values, interpolation) {
      KeyframeTrack.call(this, name, times, values, interpolation);
    }
    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
      constructor: VectorKeyframeTrack,
      ValueTypeName: "vector"
    });
    function AnimationClip(name, duration, tracks) {
      this.name = name;
      this.tracks = tracks;
      this.duration = duration !== void 0 ? duration : -1;
      this.uuid = _Math.generateUUID();
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    function getTrackTypeForValueTypeName(typeName) {
      switch (typeName.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return VectorKeyframeTrack;
        case "color":
          return ColorKeyframeTrack;
        case "quaternion":
          return QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
          return BooleanKeyframeTrack;
        case "string":
          return StringKeyframeTrack;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
    }
    function parseKeyframeTrack(json) {
      if (json.type === void 0) {
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      }
      var trackType = getTrackTypeForValueTypeName(json.type);
      if (json.times === void 0) {
        var times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
      }
      if (trackType.parse !== void 0) {
        return trackType.parse(json);
      } else {
        return new trackType(json.name, json.times, json.values, json.interpolation);
      }
    }
    Object.assign(AnimationClip, {
      parse: function(json) {
        var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (var i3 = 0, n = jsonTracks.length; i3 !== n; ++i3) {
          tracks.push(parseKeyframeTrack(jsonTracks[i3]).scale(frameTime));
        }
        return new AnimationClip(json.name, json.duration, tracks);
      },
      toJSON: function(clip) {
        var tracks = [], clipTracks = clip.tracks;
        var json = {
          name: clip.name,
          duration: clip.duration,
          tracks,
          uuid: clip.uuid
        };
        for (var i3 = 0, n = clipTracks.length; i3 !== n; ++i3) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i3]));
        }
        return json;
      },
      CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for (var i3 = 0; i3 < numMorphTargets; i3++) {
          var times = [];
          var values = [];
          times.push((i3 + numMorphTargets - 1) % numMorphTargets, i3, (i3 + 1) % numMorphTargets);
          values.push(0, 1, 0);
          var order = AnimationUtils.getKeyframeOrder(times);
          times = AnimationUtils.sortedArray(times, 1, order);
          values = AnimationUtils.sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i3].name + "]", times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
      },
      findByName: function(objectOrClipArray, name) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          var o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (var i3 = 0; i3 < clipArray.length; i3++) {
          if (clipArray[i3].name === name) {
            return clipArray[i3];
          }
        }
        return null;
      },
      CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};
        var pattern = /^([\w-]*?)([\d]+)$/;
        for (var i3 = 0, il = morphTargets.length; i3 < il; i3++) {
          var morphTarget = morphTargets[i3];
          var parts2 = morphTarget.name.match(pattern);
          if (parts2 && parts2.length > 1) {
            var name = parts2[1];
            var animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        var clips = [];
        for (var name in animationToMorphTargets) {
          clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
      },
      parseAnimation: function(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
          if (animationKeys2.length !== 0) {
            var times2 = [];
            var values2 = [];
            AnimationUtils.flattenJSON(animationKeys2, times2, values2, propertyName);
            if (times2.length !== 0) {
              destTracks.push(new trackType(trackName, times2, values2));
            }
          }
        };
        var tracks = [];
        var clipName = animation.name || "default";
        var duration = animation.length || -1;
        var fps = animation.fps || 30;
        var hierarchyTracks = animation.hierarchy || [];
        for (var h2 = 0; h2 < hierarchyTracks.length; h2++) {
          var animationKeys = hierarchyTracks[h2].keys;
          if (!animationKeys || animationKeys.length === 0)
            continue;
          if (animationKeys[0].morphTargets) {
            var morphTargetNames = {};
            for (var k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (var m2 = 0; m2 < animationKeys[k].morphTargets.length; m2++) {
                  morphTargetNames[animationKeys[k].morphTargets[m2]] = -1;
                }
              }
            }
            for (var morphTargetName in morphTargetNames) {
              var times = [];
              var values = [];
              for (var m2 = 0; m2 !== animationKeys[k].morphTargets.length; ++m2) {
                var animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * (fps || 1);
          } else {
            var boneName = ".bones[" + bones[h2].name + "]";
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
            addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        var clip = new AnimationClip(clipName, duration, tracks);
        return clip;
      }
    });
    Object.assign(AnimationClip.prototype, {
      resetDuration: function() {
        var tracks = this.tracks, duration = 0;
        for (var i3 = 0, n = tracks.length; i3 !== n; ++i3) {
          var track = this.tracks[i3];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      },
      trim: function() {
        for (var i3 = 0; i3 < this.tracks.length; i3++) {
          this.tracks[i3].trim(0, this.duration);
        }
        return this;
      },
      validate: function() {
        var valid = true;
        for (var i3 = 0; i3 < this.tracks.length; i3++) {
          valid = valid && this.tracks[i3].validate();
        }
        return valid;
      },
      optimize: function() {
        for (var i3 = 0; i3 < this.tracks.length; i3++) {
          this.tracks[i3].optimize();
        }
        return this;
      },
      clone: function() {
        var tracks = [];
        for (var i3 = 0; i3 < this.tracks.length; i3++) {
          tracks.push(this.tracks[i3].clone());
        }
        return new AnimationClip(this.name, this.duration, tracks);
      }
    });
    var Cache = {
      enabled: false,
      files: {},
      add: function(key, file2) {
        if (this.enabled === false)
          return;
        this.files[key] = file2;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    function LoadingManager(onLoad, onProgress, onError) {
      var scope = this;
      var isLoading = false;
      var itemsLoaded = 0;
      var itemsTotal = 0;
      var urlModifier = void 0;
      var handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url2) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url2, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url2) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url2, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url2) {
        if (scope.onError !== void 0) {
          scope.onError(url2);
        }
      };
      this.resolveURL = function(url2) {
        if (urlModifier) {
          return urlModifier(url2);
        }
        return url2;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        var index2 = handlers.indexOf(regex);
        if (index2 !== -1) {
          handlers.splice(index2, 2);
        }
        return this;
      };
      this.getHandler = function(file2) {
        for (var i3 = 0, l = handlers.length; i3 < l; i3 += 2) {
          var regex = handlers[i3];
          var loader = handlers[i3 + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file2)) {
            return loader;
          }
        }
        return null;
      };
    }
    var DefaultLoadingManager = new LoadingManager();
    function Loader(manager2) {
      this.manager = manager2 !== void 0 ? manager2 : DefaultLoadingManager;
      this.crossOrigin = "anonymous";
      this.path = "";
      this.resourcePath = "";
    }
    Object.assign(Loader.prototype, {
      load: function() {
      },
      parse: function() {
      },
      setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      },
      setPath: function(path) {
        this.path = path;
        return this;
      },
      setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
    });
    var loading = {};
    function FileLoader(manager2) {
      Loader.call(this, manager2);
    }
    FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: FileLoader,
      load: function(url2, onLoad, onProgress, onError) {
        if (url2 === void 0)
          url2 = "";
        if (this.path !== void 0)
          url2 = this.path + url2;
        url2 = this.manager.resolveURL(url2);
        var scope = this;
        var cached = Cache.get(url2);
        if (cached !== void 0) {
          scope.manager.itemStart(url2);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url2);
          }, 0);
          return cached;
        }
        if (loading[url2] !== void 0) {
          loading[url2].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        var dataUriRegexResult = url2.match(dataUriRegex);
        if (dataUriRegexResult) {
          var mimeType = dataUriRegexResult[1];
          var isBase64 = !!dataUriRegexResult[2];
          var data = dataUriRegexResult[3];
          data = decodeURIComponent(data);
          if (isBase64)
            data = atob(data);
          try {
            var response;
            var responseType = (this.responseType || "").toLowerCase();
            switch (responseType) {
              case "arraybuffer":
              case "blob":
                var view = new Uint8Array(data.length);
                for (var i3 = 0; i3 < data.length; i3++) {
                  view[i3] = data.charCodeAt(i3);
                }
                if (responseType === "blob") {
                  response = new Blob([view.buffer], {
                    type: mimeType
                  });
                } else {
                  response = view.buffer;
                }
                break;
              case "document":
                var parser2 = new DOMParser();
                response = parser2.parseFromString(data, mimeType);
                break;
              case "json":
                response = JSON.parse(data);
                break;
              default:
                response = data;
                break;
            }
            setTimeout(function() {
              if (onLoad)
                onLoad(response);
              scope.manager.itemEnd(url2);
            }, 0);
          } catch (error) {
            setTimeout(function() {
              if (onError)
                onError(error);
              scope.manager.itemError(url2);
              scope.manager.itemEnd(url2);
            }, 0);
          }
        } else {
          loading[url2] = [];
          loading[url2].push({
            onLoad,
            onProgress,
            onError
          });
          var request = new XMLHttpRequest();
          request.open("GET", url2, true);
          request.addEventListener("load", function(event2) {
            var response2 = this.response;
            var callbacks2 = loading[url2];
            delete loading[url2];
            if (this.status === 200 || this.status === 0) {
              if (this.status === 0)
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              Cache.add(url2, response2);
              for (var i4 = 0, il = callbacks2.length; i4 < il; i4++) {
                var callback = callbacks2[i4];
                if (callback.onLoad)
                  callback.onLoad(response2);
              }
              scope.manager.itemEnd(url2);
            } else {
              for (var i4 = 0, il = callbacks2.length; i4 < il; i4++) {
                var callback = callbacks2[i4];
                if (callback.onError)
                  callback.onError(event2);
              }
              scope.manager.itemError(url2);
              scope.manager.itemEnd(url2);
            }
          }, false);
          request.addEventListener("progress", function(event2) {
            var callbacks2 = loading[url2];
            for (var i4 = 0, il = callbacks2.length; i4 < il; i4++) {
              var callback = callbacks2[i4];
              if (callback.onProgress)
                callback.onProgress(event2);
            }
          }, false);
          request.addEventListener("error", function(event2) {
            var callbacks2 = loading[url2];
            delete loading[url2];
            for (var i4 = 0, il = callbacks2.length; i4 < il; i4++) {
              var callback = callbacks2[i4];
              if (callback.onError)
                callback.onError(event2);
            }
            scope.manager.itemError(url2);
            scope.manager.itemEnd(url2);
          }, false);
          request.addEventListener("abort", function(event2) {
            var callbacks2 = loading[url2];
            delete loading[url2];
            for (var i4 = 0, il = callbacks2.length; i4 < il; i4++) {
              var callback = callbacks2[i4];
              if (callback.onError)
                callback.onError(event2);
            }
            scope.manager.itemError(url2);
            scope.manager.itemEnd(url2);
          }, false);
          if (this.responseType !== void 0)
            request.responseType = this.responseType;
          if (this.withCredentials !== void 0)
            request.withCredentials = this.withCredentials;
          if (request.overrideMimeType)
            request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
          for (var header in this.requestHeader) {
            request.setRequestHeader(header, this.requestHeader[header]);
          }
          request.send(null);
        }
        scope.manager.itemStart(url2);
        return request;
      },
      setResponseType: function(value2) {
        this.responseType = value2;
        return this;
      },
      setWithCredentials: function(value2) {
        this.withCredentials = value2;
        return this;
      },
      setMimeType: function(value2) {
        this.mimeType = value2;
        return this;
      },
      setRequestHeader: function(value2) {
        this.requestHeader = value2;
        return this;
      }
    });
    function AnimationLoader(manager2) {
      Loader.call(this, manager2);
    }
    AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: AnimationLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url2, function(text2) {
          onLoad(scope.parse(JSON.parse(text2)));
        }, onProgress, onError);
      },
      parse: function(json) {
        var animations = [];
        for (var i3 = 0; i3 < json.length; i3++) {
          var clip = AnimationClip.parse(json[i3]);
          animations.push(clip);
        }
        return animations;
      }
    });
    function CompressedTextureLoader(manager2) {
      Loader.call(this, manager2);
    }
    CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: CompressedTextureLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture();
        texture.image = images;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        function loadTexture(i4) {
          loader.load(url2[i4], function(buffer) {
            var texDatas = scope.parse(buffer, true);
            images[i4] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1)
                texture.minFilter = LinearFilter;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url2)) {
          var loaded = 0;
          for (var i3 = 0, il = url2.length; i3 < il; ++i3) {
            loadTexture(i3);
          }
        } else {
          loader.load(url2, function(buffer) {
            var texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {
                  mipmaps: []
                };
                for (var i4 = 0; i4 < texDatas.mipmapCount; i4++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i4]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    });
    function DataTextureLoader(manager2) {
      Loader.call(this, manager2);
    }
    DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: DataTextureLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture();
        var loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.load(url2, function(buffer) {
          var texData = scope.parse(buffer);
          if (!texData)
            return;
          if (texData.image !== void 0) {
            texture.image = texData.image;
          } else if (texData.data !== void 0) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
          texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
          texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
          texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
          texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
          if (texData.format !== void 0) {
            texture.format = texData.format;
          }
          if (texData.type !== void 0) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== void 0) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter;
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    });
    function ImageLoader(manager2) {
      Loader.call(this, manager2);
    }
    ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ImageLoader,
      load: function(url2, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url2 = this.path + url2;
        url2 = this.manager.resolveURL(url2);
        var scope = this;
        var cached = Cache.get(url2);
        if (cached !== void 0) {
          scope.manager.itemStart(url2);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url2);
          }, 0);
          return cached;
        }
        var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function onImageLoad() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          Cache.add(url2, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url2);
        }
        function onImageError(event2) {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          if (onError)
            onError(event2);
          scope.manager.itemError(url2);
          scope.manager.itemEnd(url2);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url2.substr(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url2);
        image.src = url2;
        return image;
      }
    });
    function CubeTextureLoader(manager2) {
      Loader.call(this, manager2);
    }
    CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: CubeTextureLoader,
      load: function(urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i4) {
          loader.load(urls[i4], function(image) {
            texture.images[i4] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, void 0, onError);
        }
        for (var i3 = 0; i3 < urls.length; ++i3) {
          loadTexture(i3);
        }
        return texture;
      }
    });
    function TextureLoader(manager2) {
      Loader.call(this, manager2);
    }
    TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: TextureLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var texture = new Texture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url2, function(image) {
          texture.image = image;
          var isJPEG = url2.search(/\.jpe?g($|\?)/i) > 0 || url2.search(/^data\:image\/jpeg/) === 0;
          texture.format = isJPEG ? RGBFormat : RGBAFormat;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    });
    function Curve() {
      this.type = "Curve";
      this.arcLengthDivisions = 200;
    }
    Object.assign(Curve.prototype, {
      getPoint: function() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      },
      getPointAt: function(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
      },
      getPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 5;
        var points = [];
        for (var d2 = 0; d2 <= divisions; d2++) {
          points.push(this.getPoint(d2 / divisions));
        }
        return points;
      },
      getSpacedPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 5;
        var points = [];
        for (var d2 = 0; d2 <= divisions; d2++) {
          points.push(this.getPointAt(d2 / divisions));
        }
        return points;
      },
      getLength: function() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function(divisions) {
        if (divisions === void 0)
          divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current, last = this.getPoint(0);
        var p, sum = 0;
        cache.push(0);
        for (p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
      },
      getUtoTmapping: function(u, distance) {
        var arcLengths = this.getLengths();
        var i3 = 0, il = arcLengths.length;
        var targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        var low = 0, high = il - 1, comparison;
        while (low <= high) {
          i3 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i3] - targetArcLength;
          if (comparison < 0) {
            low = i3 + 1;
          } else if (comparison > 0) {
            high = i3 - 1;
          } else {
            high = i3;
            break;
          }
        }
        i3 = high;
        if (arcLengths[i3] === targetArcLength) {
          return i3 / (il - 1);
        }
        var lengthBefore = arcLengths[i3];
        var lengthAfter = arcLengths[i3 + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        var t = (i3 + segmentFraction) / (il - 1);
        return t;
      },
      getTangent: function(t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0)
          t1 = 0;
        if (t2 > 1)
          t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
      },
      getTangentAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
      },
      computeFrenetFrames: function(segments, closed) {
        var normal = new Vector3();
        var tangents = [];
        var normals = [];
        var binormals = [];
        var vec = new Vector3();
        var mat = new Matrix4();
        var i3, u, theta;
        for (i3 = 0; i3 <= segments; i3++) {
          u = i3 / segments;
          tangents[i3] = this.getTangentAt(u);
          tangents[i3].normalize();
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        var min = Number.MAX_VALUE;
        var tx = Math.abs(tangents[0].x);
        var ty = Math.abs(tangents[0].y);
        var tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (i3 = 1; i3 <= segments; i3++) {
          normals[i3] = normals[i3 - 1].clone();
          binormals[i3] = binormals[i3 - 1].clone();
          vec.crossVectors(tangents[i3 - 1], tangents[i3]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            theta = Math.acos(_Math.clamp(tangents[i3 - 1].dot(tangents[i3]), -1, 1));
            normals[i3].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[i3].crossVectors(tangents[i3], normals[i3]);
        }
        if (closed === true) {
          theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
          theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            theta = -theta;
          }
          for (i3 = 1; i3 <= segments; i3++) {
            normals[i3].applyMatrix4(mat.makeRotationAxis(tangents[i3], theta * i3));
            binormals[i3].crossVectors(tangents[i3], normals[i3]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      },
      toJSON: function() {
        var data = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      },
      fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    });
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      Curve.call(this);
      this.type = "EllipseCurve";
      this.aX = aX || 0;
      this.aY = aY || 0;
      this.xRadius = xRadius || 1;
      this.yRadius = yRadius || 1;
      this.aStartAngle = aStartAngle || 0;
      this.aEndAngle = aEndAngle || 2 * Math.PI;
      this.aClockwise = aClockwise || false;
      this.aRotation = aRotation || 0;
    }
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      var twoPi = Math.PI * 2;
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0)
        deltaAngle += twoPi;
      while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      var angle = this.aStartAngle + t * deltaAngle;
      var x = this.aX + this.xRadius * Math.cos(angle);
      var y2 = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x - this.aX;
        var ty = y2 - this.aY;
        x = tx * cos - ty * sin + this.aX;
        y2 = tx * sin + ty * cos + this.aY;
      }
      return point.set(x, y2);
    };
    EllipseCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    };
    EllipseCurve.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    };
    EllipseCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    };
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      this.type = "ArcCurve";
    }
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    ArcCurve.prototype.isArcCurve = true;
    function CubicPoly() {
      var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
      function init3(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
      }
      return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
          init3(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
          var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
          var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
          t1 *= dt1;
          t2 *= dt1;
          init3(x1, x2, t1, t2);
        },
        calc: function(t) {
          var t2 = t * t;
          var t3 = t2 * t;
          return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
      };
    }
    var tmp = new Vector3();
    var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    function CatmullRomCurve3(points, closed, curveType, tension) {
      Curve.call(this);
      this.type = "CatmullRomCurve3";
      this.points = points || [];
      this.closed = closed || false;
      this.curveType = curveType || "centripetal";
      this.tension = tension || 0.5;
    }
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector3();
      var points = this.points;
      var l = points.length;
      var p = (l - (this.closed ? 0 : 1)) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      var p0, p1, p2, p3;
      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      p1 = points[intPoint % l];
      p2 = points[(intPoint + 1) % l];
      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }
      if (this.curveType === "centripetal" || this.curveType === "chordal") {
        var pow = this.curveType === "chordal" ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 0.0001)
          dt1 = 1;
        if (dt0 < 0.0001)
          dt0 = dt1;
        if (dt2 < 0.0001)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }
      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    };
    CatmullRomCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.points = [];
      for (var i3 = 0, l = source.points.length; i3 < l; i3++) {
        var point = source.points[i3];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    };
    CatmullRomCurve3.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.points = [];
      for (var i3 = 0, l = this.points.length; i3 < l; i3++) {
        var point = this.points[i3];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    };
    CatmullRomCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.points = [];
      for (var i3 = 0, l = json.points.length; i3 < l; i3++) {
        var point = json.points[i3];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    };
    function CatmullRom(t, p0, p1, p2, p3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t2 = t * t;
      var t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
      var k = 1 - t;
      return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
      return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
      return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
      return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
      var k = 1 - t;
      return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
      var k = 1 - t;
      return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
      return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
      return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
      return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
      Curve.call(this);
      this.type = "CubicBezierCurve";
      this.v0 = v0 || new Vector2();
      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();
      this.v3 = v3 || new Vector2();
    }
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
      return point;
    };
    CubicBezierCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    };
    CubicBezierCurve.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    };
    CubicBezierCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    };
    function CubicBezierCurve3(v0, v1, v2, v3) {
      Curve.call(this);
      this.type = "CubicBezierCurve3";
      this.v0 = v0 || new Vector3();
      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();
      this.v3 = v3 || new Vector3();
    }
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector3();
      var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
      return point;
    };
    CubicBezierCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    };
    CubicBezierCurve3.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    };
    CubicBezierCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    };
    function LineCurve(v1, v2) {
      Curve.call(this);
      this.type = "LineCurve";
      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();
    }
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    };
    LineCurve.prototype.getPointAt = function(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    };
    LineCurve.prototype.getTangent = function() {
      var tangent = this.v2.clone().sub(this.v1);
      return tangent.normalize();
    };
    LineCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    LineCurve.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    LineCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    function LineCurve3(v1, v2) {
      Curve.call(this);
      this.type = "LineCurve3";
      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();
    }
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.isLineCurve3 = true;
    LineCurve3.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector3();
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    };
    LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    };
    LineCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    LineCurve3.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    LineCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    function QuadraticBezierCurve(v0, v1, v2) {
      Curve.call(this);
      this.type = "QuadraticBezierCurve";
      this.v0 = v0 || new Vector2();
      this.v1 = v1 || new Vector2();
      this.v2 = v2 || new Vector2();
    }
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      var v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
      return point;
    };
    QuadraticBezierCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    QuadraticBezierCurve.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    QuadraticBezierCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    function QuadraticBezierCurve3(v0, v1, v2) {
      Curve.call(this);
      this.type = "QuadraticBezierCurve3";
      this.v0 = v0 || new Vector3();
      this.v1 = v1 || new Vector3();
      this.v2 = v2 || new Vector3();
    }
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector3();
      var v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
      return point;
    };
    QuadraticBezierCurve3.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    };
    QuadraticBezierCurve3.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    };
    QuadraticBezierCurve3.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    };
    function SplineCurve(points) {
      Curve.call(this);
      this.type = "SplineCurve";
      this.points = points || [];
    }
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      var points = this.points;
      var p = (points.length - 1) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;
      var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var p1 = points[intPoint];
      var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      return point;
    };
    SplineCurve.prototype.copy = function(source) {
      Curve.prototype.copy.call(this, source);
      this.points = [];
      for (var i3 = 0, l = source.points.length; i3 < l; i3++) {
        var point = source.points[i3];
        this.points.push(point.clone());
      }
      return this;
    };
    SplineCurve.prototype.toJSON = function() {
      var data = Curve.prototype.toJSON.call(this);
      data.points = [];
      for (var i3 = 0, l = this.points.length; i3 < l; i3++) {
        var point = this.points[i3];
        data.points.push(point.toArray());
      }
      return data;
    };
    SplineCurve.prototype.fromJSON = function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.points = [];
      for (var i3 = 0, l = json.points.length; i3 < l; i3++) {
        var point = json.points[i3];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    };
    var Curves = Object.freeze({
      __proto__: null,
      ArcCurve,
      CatmullRomCurve3,
      CubicBezierCurve,
      CubicBezierCurve3,
      EllipseCurve,
      LineCurve,
      LineCurve3,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      SplineCurve
    });
    function CurvePath() {
      Curve.call(this);
      this.type = "CurvePath";
      this.curves = [];
      this.autoClose = false;
    }
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
      constructor: CurvePath,
      add: function(curve) {
        this.curves.push(curve);
      },
      closePath: function() {
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          this.curves.push(new LineCurve(endPoint, startPoint));
        }
      },
      getPoint: function(t) {
        var d2 = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i3 = 0;
        while (i3 < curveLengths.length) {
          if (curveLengths[i3] >= d2) {
            var diff = curveLengths[i3] - d2;
            var curve = this.curves[i3];
            var segmentLength = curve.getLength();
            var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u);
          }
          i3++;
        }
        return null;
      },
      getLength: function() {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      },
      getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        var lengths = [], sums = 0;
        for (var i3 = 0, l = this.curves.length; i3 < l; i3++) {
          sums += this.curves[i3].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      },
      getSpacedPoints: function(divisions) {
        if (divisions === void 0)
          divisions = 40;
        var points = [];
        for (var i3 = 0; i3 <= divisions; i3++) {
          points.push(this.getPoint(i3 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      },
      getPoints: function(divisions) {
        divisions = divisions || 12;
        var points = [], last;
        for (var i3 = 0, curves = this.curves; i3 < curves.length; i3++) {
          var curve = curves[i3];
          var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
          var pts = curve.getPoints(resolution);
          for (var j = 0; j < pts.length; j++) {
            var point = pts[j];
            if (last && last.equals(point))
              continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      },
      copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for (var i3 = 0, l = source.curves.length; i3 < l; i3++) {
          var curve = source.curves[i3];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      },
      toJSON: function() {
        var data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for (var i3 = 0, l = this.curves.length; i3 < l; i3++) {
          var curve = this.curves[i3];
          data.curves.push(curve.toJSON());
        }
        return data;
      },
      fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (var i3 = 0, l = json.curves.length; i3 < l; i3++) {
          var curve = json.curves[i3];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    });
    function Path(points) {
      CurvePath.call(this);
      this.type = "Path";
      this.currentPoint = new Vector2();
      if (points) {
        this.setFromPoints(points);
      }
    }
    Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
      constructor: Path,
      setFromPoints: function(points) {
        this.moveTo(points[0].x, points[0].y);
        for (var i3 = 1, l = points.length; i3 < l; i3++) {
          this.lineTo(points[i3].x, points[i3].y);
        }
        return this;
      },
      moveTo: function(x, y2) {
        this.currentPoint.set(x, y2);
        return this;
      },
      lineTo: function(x, y2) {
        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y2));
        this.curves.push(curve);
        this.currentPoint.set(x, y2);
        return this;
      },
      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      },
      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      },
      splineThru: function(pts) {
        var npts = [this.currentPoint.clone()].concat(pts);
        var curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      },
      arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      },
      absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      },
      ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      },
      absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          var firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      },
      copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      },
      toJSON: function() {
        var data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
      },
      fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    });
    function Shape(points) {
      Path.call(this, points);
      this.uuid = _Math.generateUUID();
      this.type = "Shape";
      this.holes = [];
    }
    Shape.prototype = Object.assign(Object.create(Path.prototype), {
      constructor: Shape,
      getPointsHoles: function(divisions) {
        var holesPts = [];
        for (var i3 = 0, l = this.holes.length; i3 < l; i3++) {
          holesPts[i3] = this.holes[i3].getPoints(divisions);
        }
        return holesPts;
      },
      extractPoints: function(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      },
      copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for (var i3 = 0, l = source.holes.length; i3 < l; i3++) {
          var hole = source.holes[i3];
          this.holes.push(hole.clone());
        }
        return this;
      },
      toJSON: function() {
        var data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for (var i3 = 0, l = this.holes.length; i3 < l; i3++) {
          var hole = this.holes[i3];
          data.holes.push(hole.toJSON());
        }
        return data;
      },
      fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for (var i3 = 0, l = json.holes.length; i3 < l; i3++) {
          var hole = json.holes[i3];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    });
    function Light(color, intensity) {
      Object3D.call(this);
      this.type = "Light";
      this.color = new Color(color);
      this.intensity = intensity !== void 0 ? intensity : 1;
      this.receiveShadow = void 0;
    }
    Light.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Light,
      isLight: true,
      copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      },
      toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      }
    });
    function HemisphereLight(skyColor, groundColor, intensity) {
      Light.call(this, skyColor, intensity);
      this.type = "HemisphereLight";
      this.castShadow = void 0;
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: HemisphereLight,
      isHemisphereLight: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    });
    function LightShadow(camera) {
      this.camera = camera;
      this.bias = 0;
      this.radius = 1;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [new Vector4(0, 0, 1, 1)];
    }
    Object.assign(LightShadow.prototype, {
      _projScreenMatrix: new Matrix4(),
      _lightPositionWorld: new Vector3(),
      _lookTarget: new Vector3(),
      getViewportCount: function() {
        return this._viewportCount;
      },
      getFrustum: function() {
        return this._frustum;
      },
      updateMatrices: function(light) {
        var shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      },
      getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
      },
      getFrameExtents: function() {
        return this._frameExtents;
      },
      copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      toJSON: function() {
        var object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    });
    function SpotLightShadow() {
      LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    }
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: SpotLightShadow,
      isSpotLightShadow: true,
      updateMatrices: function(light) {
        var camera = this.camera;
        var fov2 = _Math.RAD2DEG * 2 * light.angle;
        var aspect2 = this.mapSize.width / this.mapSize.height;
        var far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
          camera.fov = fov2;
          camera.aspect = aspect2;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        LightShadow.prototype.updateMatrices.call(this, light);
      }
    });
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
      Light.call(this, color, intensity);
      this.type = "SpotLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      Object.defineProperty(this, "power", {
        get: function() {
          return this.intensity * Math.PI;
        },
        set: function(power) {
          this.intensity = power / Math.PI;
        }
      });
      this.distance = distance !== void 0 ? distance : 0;
      this.angle = angle !== void 0 ? angle : Math.PI / 3;
      this.penumbra = penumbra !== void 0 ? penumbra : 0;
      this.decay = decay !== void 0 ? decay : 1;
      this.shadow = new SpotLightShadow();
    }
    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: SpotLight,
      isSpotLight: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    function PointLightShadow() {
      LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
      this._frameExtents = new Vector2(4, 2);
      this._viewportCount = 6;
      this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)];
      this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
      this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
    }
    PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: PointLightShadow,
      isPointLightShadow: true,
      updateMatrices: function(light, viewportIndex) {
        if (viewportIndex === void 0)
          viewportIndex = 0;
        var camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromMatrix(projScreenMatrix);
      }
    });
    function PointLight(color, intensity, distance, decay) {
      Light.call(this, color, intensity);
      this.type = "PointLight";
      Object.defineProperty(this, "power", {
        get: function() {
          return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
          this.intensity = power / (4 * Math.PI);
        }
      });
      this.distance = distance !== void 0 ? distance : 0;
      this.decay = decay !== void 0 ? decay : 1;
      this.shadow = new PointLightShadow();
    }
    PointLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: PointLight,
      isPointLight: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    function OrthographicCamera(left, right, top, bottom, near, far) {
      Camera.call(this);
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left !== void 0 ? left : -1;
      this.right = right !== void 0 ? right : 1;
      this.top = top !== void 0 ? top : 1;
      this.bottom = bottom !== void 0 ? bottom : -1;
      this.near = near !== void 0 ? near : 0.1;
      this.far = far !== void 0 ? far : 2000;
      this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
      constructor: OrthographicCamera,
      isOrthographicCamera: true,
      copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      },
      setViewOffset: function(fullWidth, fullHeight, x, y2, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      },
      clearViewOffset: function() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function() {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
          var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
          var scaleW = (this.right - this.left) / this.view.width;
          var scaleH = (this.top - this.bottom) / this.view.height;
          left += scaleW * (this.view.offsetX / zoomW);
          right = left + scaleW * (this.view.width / zoomW);
          top -= scaleH * (this.view.offsetY / zoomH);
          bottom = top - scaleH * (this.view.height / zoomH);
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      }
    });
    function DirectionalLightShadow() {
      LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
      constructor: DirectionalLightShadow,
      isDirectionalLightShadow: true,
      updateMatrices: function(light) {
        LightShadow.prototype.updateMatrices.call(this, light);
      }
    });
    function DirectionalLight(color, intensity) {
      Light.call(this, color, intensity);
      this.type = "DirectionalLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: DirectionalLight,
      isDirectionalLight: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    });
    function AmbientLight(color, intensity) {
      Light.call(this, color, intensity);
      this.type = "AmbientLight";
      this.castShadow = void 0;
    }
    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: AmbientLight,
      isAmbientLight: true
    });
    function RectAreaLight(color, intensity, width, height) {
      Light.call(this, color, intensity);
      this.type = "RectAreaLight";
      this.width = width !== void 0 ? width : 10;
      this.height = height !== void 0 ? height : 10;
    }
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: RectAreaLight,
      isRectAreaLight: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
      },
      toJSON: function(meta) {
        var data = Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    });
    function MaterialLoader(manager2) {
      Loader.call(this, manager2);
      this.textures = {};
    }
    MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: MaterialLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url2, function(text2) {
          onLoad(scope.parse(JSON.parse(text2)));
        }, onProgress, onError);
      },
      parse: function(json) {
        var textures = this.textures;
        function getTexture(name2) {
          if (textures[name2] === void 0) {
            console.warn("THREE.MaterialLoader: Undefined texture", name2);
          }
          return textures[name2];
        }
        var material2 = new Materials[json.type]();
        if (json.uuid !== void 0)
          material2.uuid = json.uuid;
        if (json.name !== void 0)
          material2.name = json.name;
        if (json.color !== void 0)
          material2.color.setHex(json.color);
        if (json.roughness !== void 0)
          material2.roughness = json.roughness;
        if (json.metalness !== void 0)
          material2.metalness = json.metalness;
        if (json.sheen !== void 0)
          material2.sheen = new Color().setHex(json.sheen);
        if (json.emissive !== void 0)
          material2.emissive.setHex(json.emissive);
        if (json.specular !== void 0)
          material2.specular.setHex(json.specular);
        if (json.shininess !== void 0)
          material2.shininess = json.shininess;
        if (json.clearcoat !== void 0)
          material2.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== void 0)
          material2.clearcoatRoughness = json.clearcoatRoughness;
        if (json.vertexColors !== void 0)
          material2.vertexColors = json.vertexColors;
        if (json.fog !== void 0)
          material2.fog = json.fog;
        if (json.flatShading !== void 0)
          material2.flatShading = json.flatShading;
        if (json.blending !== void 0)
          material2.blending = json.blending;
        if (json.combine !== void 0)
          material2.combine = json.combine;
        if (json.side !== void 0)
          material2.side = json.side;
        if (json.opacity !== void 0)
          material2.opacity = json.opacity;
        if (json.transparent !== void 0)
          material2.transparent = json.transparent;
        if (json.alphaTest !== void 0)
          material2.alphaTest = json.alphaTest;
        if (json.depthTest !== void 0)
          material2.depthTest = json.depthTest;
        if (json.depthWrite !== void 0)
          material2.depthWrite = json.depthWrite;
        if (json.colorWrite !== void 0)
          material2.colorWrite = json.colorWrite;
        if (json.stencilWrite !== void 0)
          material2.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== void 0)
          material2.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== void 0)
          material2.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== void 0)
          material2.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== void 0)
          material2.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== void 0)
          material2.stencilFail = json.stencilFail;
        if (json.stencilZFail !== void 0)
          material2.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== void 0)
          material2.stencilZPass = json.stencilZPass;
        if (json.wireframe !== void 0)
          material2.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== void 0)
          material2.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== void 0)
          material2.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== void 0)
          material2.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== void 0)
          material2.rotation = json.rotation;
        if (json.linewidth !== 1)
          material2.linewidth = json.linewidth;
        if (json.dashSize !== void 0)
          material2.dashSize = json.dashSize;
        if (json.gapSize !== void 0)
          material2.gapSize = json.gapSize;
        if (json.scale !== void 0)
          material2.scale = json.scale;
        if (json.polygonOffset !== void 0)
          material2.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== void 0)
          material2.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== void 0)
          material2.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== void 0)
          material2.skinning = json.skinning;
        if (json.morphTargets !== void 0)
          material2.morphTargets = json.morphTargets;
        if (json.morphNormals !== void 0)
          material2.morphNormals = json.morphNormals;
        if (json.dithering !== void 0)
          material2.dithering = json.dithering;
        if (json.visible !== void 0)
          material2.visible = json.visible;
        if (json.toneMapped !== void 0)
          material2.toneMapped = json.toneMapped;
        if (json.userData !== void 0)
          material2.userData = json.userData;
        if (json.uniforms !== void 0) {
          for (var name in json.uniforms) {
            var uniform = json.uniforms[name];
            material2.uniforms[name] = {};
            switch (uniform.type) {
              case "t":
                material2.uniforms[name].value = getTexture(uniform.value);
                break;
              case "c":
                material2.uniforms[name].value = new Color().setHex(uniform.value);
                break;
              case "v2":
                material2.uniforms[name].value = new Vector2().fromArray(uniform.value);
                break;
              case "v3":
                material2.uniforms[name].value = new Vector3().fromArray(uniform.value);
                break;
              case "v4":
                material2.uniforms[name].value = new Vector4().fromArray(uniform.value);
                break;
              case "m3":
                material2.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              case "m4":
                material2.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                break;
              default:
                material2.uniforms[name].value = uniform.value;
            }
          }
        }
        if (json.defines !== void 0)
          material2.defines = json.defines;
        if (json.vertexShader !== void 0)
          material2.vertexShader = json.vertexShader;
        if (json.fragmentShader !== void 0)
          material2.fragmentShader = json.fragmentShader;
        if (json.extensions !== void 0) {
          for (var key in json.extensions) {
            material2.extensions[key] = json.extensions[key];
          }
        }
        if (json.shading !== void 0)
          material2.flatShading = json.shading === 1;
        if (json.size !== void 0)
          material2.size = json.size;
        if (json.sizeAttenuation !== void 0)
          material2.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== void 0)
          material2.map = getTexture(json.map);
        if (json.matcap !== void 0)
          material2.matcap = getTexture(json.matcap);
        if (json.alphaMap !== void 0) {
          material2.alphaMap = getTexture(json.alphaMap);
          material2.transparent = true;
        }
        if (json.bumpMap !== void 0)
          material2.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== void 0)
          material2.bumpScale = json.bumpScale;
        if (json.normalMap !== void 0)
          material2.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== void 0)
          material2.normalMapType = json.normalMapType;
        if (json.normalScale !== void 0) {
          var normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            normalScale = [normalScale, normalScale];
          }
          material2.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== void 0)
          material2.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== void 0)
          material2.displacementScale = json.displacementScale;
        if (json.displacementBias !== void 0)
          material2.displacementBias = json.displacementBias;
        if (json.roughnessMap !== void 0)
          material2.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== void 0)
          material2.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== void 0)
          material2.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== void 0)
          material2.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== void 0)
          material2.specularMap = getTexture(json.specularMap);
        if (json.envMap !== void 0)
          material2.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== void 0)
          material2.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== void 0)
          material2.reflectivity = json.reflectivity;
        if (json.refractionRatio !== void 0)
          material2.refractionRatio = json.refractionRatio;
        if (json.lightMap !== void 0)
          material2.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== void 0)
          material2.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== void 0)
          material2.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== void 0)
          material2.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== void 0)
          material2.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatNormalMap !== void 0)
          material2.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== void 0)
          material2.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        return material2;
      },
      setTextures: function(value2) {
        this.textures = value2;
        return this;
      }
    });
    var LoaderUtils = {
      decodeText: function(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        var s2 = "";
        for (var i3 = 0, il = array.length; i3 < il; i3++) {
          s2 += String.fromCharCode(array[i3]);
        }
        try {
          return decodeURIComponent(escape(s2));
        } catch (e) {
          return s2;
        }
      },
      extractUrlBase: function(url2) {
        var index2 = url2.lastIndexOf("/");
        if (index2 === -1)
          return "./";
        return url2.substr(0, index2 + 1);
      }
    };
    function InstancedBufferGeometry() {
      BufferGeometry.call(this);
      this.type = "InstancedBufferGeometry";
      this.maxInstancedCount = void 0;
    }
    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
      constructor: InstancedBufferGeometry,
      isInstancedBufferGeometry: true,
      copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.maxInstancedCount = source.maxInstancedCount;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      toJSON: function() {
        var data = BufferGeometry.prototype.toJSON.call(this);
        data.maxInstancedCount = this.maxInstancedCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    });
    function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
      if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
      }
      BufferAttribute.call(this, array, itemSize, normalized);
      this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
      constructor: InstancedBufferAttribute,
      isInstancedBufferAttribute: true,
      copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      },
      toJSON: function() {
        var data = BufferAttribute.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    });
    function BufferGeometryLoader(manager2) {
      Loader.call(this, manager2);
    }
    BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: BufferGeometryLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url2, function(text2) {
          onLoad(scope.parse(JSON.parse(text2)));
        }, onProgress, onError);
      },
      parse: function(json) {
        var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        var index2 = json.data.index;
        if (index2 !== void 0) {
          var typedArray = new TYPED_ARRAYS[index2.type](index2.array);
          geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
          var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
          var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          geometry.setAttribute(key, bufferAttribute);
        }
        var morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (var key in morphAttributes) {
            var attributeArray = morphAttributes[key];
            var array = [];
            for (var i3 = 0, il = attributeArray.length; i3 < il; i3++) {
              var attribute = attributeArray[i3];
              var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
              var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
              if (attribute.name !== void 0)
                bufferAttribute.name = attribute.name;
              array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
          }
        }
        var morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== void 0) {
          for (var i3 = 0, n = groups.length; i3 !== n; ++i3) {
            var group = groups[i3];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== void 0) {
          var center = new Vector3();
          if (boundingSphere.center !== void 0) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name)
          geometry.name = json.name;
        if (json.userData)
          geometry.userData = json.userData;
        return geometry;
      }
    });
    var TYPED_ARRAYS = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    };
    function ObjectLoader(manager2) {
      Loader.call(this, manager2);
    }
    ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ObjectLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === "" ? LoaderUtils.extractUrlBase(url2) : this.path;
        this.resourcePath = this.resourcePath || path;
        var loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.load(url2, function(text2) {
          var json = null;
          try {
            json = JSON.parse(text2);
          } catch (error) {
            if (onError !== void 0)
              onError(error);
            console.error("THREE:ObjectLoader: Can't parse " + url2 + ".", error.message);
            return;
          }
          var metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            console.error("THREE.ObjectLoader: Can't load " + url2);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      },
      parse: function(json, onLoad) {
        var shapes = this.parseShape(json.shapes);
        var geometries = this.parseGeometries(json.geometries, shapes);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== void 0)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
          object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === void 0 || json.images.length === 0) {
          if (onLoad !== void 0)
            onLoad(object);
        }
        return object;
      },
      parseShape: function(json) {
        var shapes = {};
        if (json !== void 0) {
          for (var i3 = 0, l = json.length; i3 < l; i3++) {
            var shape = new Shape().fromJSON(json[i3]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      },
      parseGeometries: function(json, shapes) {
        var geometries = {};
        if (json !== void 0) {
          var bufferGeometryLoader = new BufferGeometryLoader();
          for (var i3 = 0, l = json.length; i3 < l; i3++) {
            var geometry;
            var data = json[i3];
            switch (data.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                var geometryShapes = [];
                for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                  var shape = shapes[data.shapes[j]];
                  geometryShapes.push(shape);
                }
                geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                var geometryShapes = [];
                for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                  var shape = shapes[data.shapes[j]];
                  geometryShapes.push(shape);
                }
                var extrudePath = data.options.extrudePath;
                if (extrudePath !== void 0) {
                  data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                }
                geometry = new Geometries[data.type](geometryShapes, data.options);
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                geometry = bufferGeometryLoader.parse(data);
                break;
              case "Geometry":
                if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                  var geometryLoader = new THREE.LegacyJSONLoader();
                  geometry = geometryLoader.parse(data, this.resourcePath).geometry;
                } else {
                  console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                }
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                continue;
            }
            geometry.uuid = data.uuid;
            if (data.name !== void 0)
              geometry.name = data.name;
            if (geometry.isBufferGeometry === true && data.userData !== void 0)
              geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        var cache = {};
        var materials = {};
        if (json !== void 0) {
          var loader = new MaterialLoader();
          loader.setTextures(textures);
          for (var i3 = 0, l = json.length; i3 < l; i3++) {
            var data = json[i3];
            if (data.type === "MultiMaterial") {
              var array = [];
              for (var j = 0; j < data.materials.length; j++) {
                var material2 = data.materials[j];
                if (cache[material2.uuid] === void 0) {
                  cache[material2.uuid] = loader.parse(material2);
                }
                array.push(cache[material2.uuid]);
              }
              materials[data.uuid] = array;
            } else {
              if (cache[data.uuid] === void 0) {
                cache[data.uuid] = loader.parse(data);
              }
              materials[data.uuid] = cache[data.uuid];
            }
          }
        }
        return materials;
      },
      parseAnimations: function(json) {
        var animations = [];
        for (var i3 = 0; i3 < json.length; i3++) {
          var data = json[i3];
          var clip = AnimationClip.parse(data);
          if (data.uuid !== void 0)
            clip.uuid = data.uuid;
          animations.push(clip);
        }
        return animations;
      },
      parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        function loadImage2(url3) {
          scope.manager.itemStart(url3);
          return loader.load(url3, function() {
            scope.manager.itemEnd(url3);
          }, void 0, function() {
            scope.manager.itemError(url3);
            scope.manager.itemEnd(url3);
          });
        }
        if (json !== void 0 && json.length > 0) {
          var manager2 = new LoadingManager(onLoad);
          var loader = new ImageLoader(manager2);
          loader.setCrossOrigin(this.crossOrigin);
          for (var i3 = 0, il = json.length; i3 < il; i3++) {
            var image = json[i3];
            var url2 = image.url;
            if (Array.isArray(url2)) {
              images[image.uuid] = [];
              for (var j = 0, jl = url2.length; j < jl; j++) {
                var currentUrl = url2[j];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
                images[image.uuid].push(loadImage2(path));
              }
            } else {
              var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
              images[image.uuid] = loadImage2(path);
            }
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        function parseConstant(value2, type) {
          if (typeof value2 === "number")
            return value2;
          console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value2);
          return type[value2];
        }
        var textures = {};
        if (json !== void 0) {
          for (var i3 = 0, l = json.length; i3 < l; i3++) {
            var data = json[i3];
            if (data.image === void 0) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined image", data.image);
            }
            var texture;
            if (Array.isArray(images[data.image])) {
              texture = new CubeTexture(images[data.image]);
            } else {
              texture = new Texture(images[data.image]);
            }
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== void 0)
              texture.name = data.name;
            if (data.mapping !== void 0)
              texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== void 0)
              texture.offset.fromArray(data.offset);
            if (data.repeat !== void 0)
              texture.repeat.fromArray(data.repeat);
            if (data.center !== void 0)
              texture.center.fromArray(data.center);
            if (data.rotation !== void 0)
              texture.rotation = data.rotation;
            if (data.wrap !== void 0) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== void 0)
              texture.format = data.format;
            if (data.type !== void 0)
              texture.type = data.type;
            if (data.encoding !== void 0)
              texture.encoding = data.encoding;
            if (data.minFilter !== void 0)
              texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== void 0)
              texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== void 0)
              texture.anisotropy = data.anisotropy;
            if (data.flipY !== void 0)
              texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== void 0)
              texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== void 0)
              texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function(data, geometries, materials) {
        var object;
        function getGeometry(name) {
          if (geometries[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined geometry", name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === void 0)
            return void 0;
          if (Array.isArray(name)) {
            var array = [];
            for (var i4 = 0, l2 = name.length; i4 < l2; i4++) {
              var uuid = name[i4];
              if (materials[uuid] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined material", uuid);
              }
              array.push(materials[uuid]);
            }
            return array;
          }
          if (materials[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", name);
          }
          return materials[name];
        }
        switch (data.type) {
          case "Scene":
            object = new Scene();
            if (data.background !== void 0) {
              if (Number.isInteger(data.background)) {
                object.background = new Color(data.background);
              }
            }
            if (data.fog !== void 0) {
              if (data.fog.type === "Fog") {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === "FogExp2") {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
              }
            }
            break;
          case "PerspectiveCamera":
            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== void 0)
              object.focus = data.focus;
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.filmGauge !== void 0)
              object.filmGauge = data.filmGauge;
            if (data.filmOffset !== void 0)
              object.filmOffset = data.filmOffset;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "OrthographicCamera":
            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "AmbientLight":
            object = new AmbientLight(data.color, data.intensity);
            break;
          case "DirectionalLight":
            object = new DirectionalLight(data.color, data.intensity);
            break;
          case "PointLight":
            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case "RectAreaLight":
            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
            break;
          case "SpotLight":
            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            break;
          case "HemisphereLight":
            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case "SkinnedMesh":
            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
          case "Mesh":
            var geometry = getGeometry(data.geometry);
            var material2 = getMaterial(data.material);
            if (geometry.bones && geometry.bones.length > 0) {
              object = new SkinnedMesh(geometry, material2);
            } else {
              object = new Mesh(geometry, material2);
            }
            break;
          case "InstancedMesh":
            var geometry = getGeometry(data.geometry);
            var material2 = getMaterial(data.material);
            var count = data.count;
            var instanceMatrix = data.instanceMatrix;
            object = new InstancedMesh(geometry, material2, count);
            object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
            break;
          case "LOD":
            object = new LOD();
            break;
          case "Line":
            object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
            break;
          case "LineLoop":
            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineSegments":
            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "PointCloud":
          case "Points":
            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "Sprite":
            object = new Sprite(getMaterial(data.material));
            break;
          case "Group":
            object = new Group();
            break;
          default:
            object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== void 0)
          object.name = data.name;
        if (data.matrix !== void 0) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== void 0)
            object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate)
            object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== void 0)
            object.position.fromArray(data.position);
          if (data.rotation !== void 0)
            object.rotation.fromArray(data.rotation);
          if (data.quaternion !== void 0)
            object.quaternion.fromArray(data.quaternion);
          if (data.scale !== void 0)
            object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== void 0)
          object.castShadow = data.castShadow;
        if (data.receiveShadow !== void 0)
          object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.bias !== void 0)
            object.shadow.bias = data.shadow.bias;
          if (data.shadow.radius !== void 0)
            object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== void 0)
            object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== void 0)
            object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== void 0)
          object.visible = data.visible;
        if (data.frustumCulled !== void 0)
          object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== void 0)
          object.renderOrder = data.renderOrder;
        if (data.userData !== void 0)
          object.userData = data.userData;
        if (data.layers !== void 0)
          object.layers.mask = data.layers;
        if (data.children !== void 0) {
          var children2 = data.children;
          for (var i3 = 0; i3 < children2.length; i3++) {
            object.add(this.parseObject(children2[i3], geometries, materials));
          }
        }
        if (data.type === "LOD") {
          if (data.autoUpdate !== void 0)
            object.autoUpdate = data.autoUpdate;
          var levels = data.levels;
          for (var l = 0; l < levels.length; l++) {
            var level = levels[l];
            var child = object.getObjectByProperty("uuid", level.object);
            if (child !== void 0) {
              object.addLevel(child, level.distance);
            }
          }
        }
        return object;
      }
    });
    var TEXTURE_MAPPING = {
      UVMapping,
      CubeReflectionMapping,
      CubeRefractionMapping,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      SphericalReflectionMapping,
      CubeUVReflectionMapping,
      CubeUVRefractionMapping
    };
    var TEXTURE_WRAPPING = {
      RepeatWrapping,
      ClampToEdgeWrapping,
      MirroredRepeatWrapping
    };
    var TEXTURE_FILTER = {
      NearestFilter,
      NearestMipmapNearestFilter,
      NearestMipmapLinearFilter,
      LinearFilter,
      LinearMipmapNearestFilter,
      LinearMipmapLinearFilter
    };
    function ImageBitmapLoader(manager2) {
      if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
      }
      if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
      }
      Loader.call(this, manager2);
      this.options = void 0;
    }
    ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: ImageBitmapLoader,
      setOptions: function setOptions(options) {
        this.options = options;
        return this;
      },
      load: function(url2, onLoad, onProgress, onError) {
        if (url2 === void 0)
          url2 = "";
        if (this.path !== void 0)
          url2 = this.path + url2;
        url2 = this.manager.resolveURL(url2);
        var scope = this;
        var cached = Cache.get(url2);
        if (cached !== void 0) {
          scope.manager.itemStart(url2);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url2);
          }, 0);
          return cached;
        }
        fetch(url2).then(function(res) {
          return res.blob();
        }).then(function(blob2) {
          if (scope.options === void 0) {
            return createImageBitmap(blob2);
          } else {
            return createImageBitmap(blob2, scope.options);
          }
        }).then(function(imageBitmap) {
          Cache.add(url2, imageBitmap);
          if (onLoad)
            onLoad(imageBitmap);
          scope.manager.itemEnd(url2);
        }).catch(function(e) {
          if (onError)
            onError(e);
          scope.manager.itemError(url2);
          scope.manager.itemEnd(url2);
        });
        scope.manager.itemStart(url2);
      }
    });
    function ShapePath() {
      this.type = "ShapePath";
      this.color = new Color();
      this.subPaths = [];
      this.currentPath = null;
    }
    Object.assign(ShapePath.prototype, {
      moveTo: function(x, y2) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y2);
        return this;
      },
      lineTo: function(x, y2) {
        this.currentPath.lineTo(x, y2);
        return this;
      },
      quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      },
      bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      },
      splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
      },
      toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
          var shapes2 = [];
          for (var i4 = 0, l2 = inSubpaths.length; i4 < l2; i4++) {
            var tmpPath2 = inSubpaths[i4];
            var tmpShape2 = new Shape();
            tmpShape2.curves = tmpPath2.curves;
            shapes2.push(tmpShape2);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          var polyLen = inPolygon.length;
          var inside = false;
          for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            var edgeLowPt = inPolygon[p];
            var edgeHighPt = inPolygon[q];
            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                  return true;
              } else {
                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                  return true;
                if (perpEdge < 0)
                  continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y)
                continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
            }
          }
          return inside;
        }
        var isClockWise = ShapeUtils.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0)
          return [];
        if (noHoles === true)
          return toShapesNoHoles(subPaths);
        var solid, tmpPath, tmpShape, shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (var i3 = 0, l = subPaths.length; i3 < l; i3++) {
          tmpPath = subPaths[i3];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx])
              mainIdx++;
            newShapes[mainIdx] = {
              s: new Shape(),
              p: tmpPoints
            };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst)
              mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({
              h: tmpPath,
              p: tmpPoints[0]
            });
          }
        }
        if (!newShapes[0])
          return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          var ambiguous = false;
          var toChange = [];
          for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            var sho = newShapeHoles[sIdx];
            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
              var ho = sho[hIdx];
              var hole_unassigned = true;
              for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (sIdx !== s2Idx)
                    toChange.push({
                      froms: sIdx,
                      tos: s2Idx,
                      hole: hIdx
                    });
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
              }
            }
          }
          if (toChange.length > 0) {
            if (!ambiguous)
              newShapeHoles = betterShapeHoles;
          }
        }
        var tmpHoles;
        for (var i3 = 0, il = newShapes.length; i3 < il; i3++) {
          tmpShape = newShapes[i3].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[i3];
          for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }
        return shapes;
      }
    });
    function Font(data) {
      this.type = "Font";
      this.data = data;
    }
    Object.assign(Font.prototype, {
      isFont: true,
      generateShapes: function(text2, size) {
        if (size === void 0)
          size = 100;
        var shapes = [];
        var paths = createPaths(text2, size, this.data);
        for (var p = 0, pl = paths.length; p < pl; p++) {
          Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
      }
    });
    function createPaths(text2, size, data) {
      var chars = Array.from ? Array.from(text2) : String(text2).split("");
      var scale = size / data.resolution;
      var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
      var paths = [];
      var offsetX = 0, offsetY = 0;
      for (var i3 = 0; i3 < chars.length; i3++) {
        var char = chars[i3];
        if (char === "\n") {
          offsetX = 0;
          offsetY -= line_height;
        } else {
          var ret = createPath(char, scale, offsetX, offsetY, data);
          offsetX += ret.offsetX;
          paths.push(ret.path);
        }
      }
      return paths;
    }
    function createPath(char, scale, offsetX, offsetY, data) {
      var glyph = data.glyphs[char] || data.glyphs["?"];
      if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
        return;
      }
      var path = new ShapePath();
      var x, y2, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
      if (glyph.o) {
        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for (var i3 = 0, l = outline.length; i3 < l; ) {
          var action = outline[i3++];
          switch (action) {
            case "m":
              x = outline[i3++] * scale + offsetX;
              y2 = outline[i3++] * scale + offsetY;
              path.moveTo(x, y2);
              break;
            case "l":
              x = outline[i3++] * scale + offsetX;
              y2 = outline[i3++] * scale + offsetY;
              path.lineTo(x, y2);
              break;
            case "q":
              cpx = outline[i3++] * scale + offsetX;
              cpy = outline[i3++] * scale + offsetY;
              cpx1 = outline[i3++] * scale + offsetX;
              cpy1 = outline[i3++] * scale + offsetY;
              path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
              break;
            case "b":
              cpx = outline[i3++] * scale + offsetX;
              cpy = outline[i3++] * scale + offsetY;
              cpx1 = outline[i3++] * scale + offsetX;
              cpy1 = outline[i3++] * scale + offsetY;
              cpx2 = outline[i3++] * scale + offsetX;
              cpy2 = outline[i3++] * scale + offsetY;
              path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
              break;
          }
        }
      }
      return {
        offsetX: glyph.ha * scale,
        path
      };
    }
    function FontLoader(manager2) {
      Loader.call(this, manager2);
    }
    FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: FontLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.load(url2, function(text2) {
          var json;
          try {
            json = JSON.parse(text2);
          } catch (e) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
            json = JSON.parse(text2.substring(65, text2.length - 2));
          }
          var font = scope.parse(json);
          if (onLoad)
            onLoad(font);
        }, onProgress, onError);
      },
      parse: function(json) {
        return new Font(json);
      }
    });
    var _context;
    var AudioContext2 = {
      getContext: function() {
        if (_context === void 0) {
          _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
      },
      setContext: function(value2) {
        _context = value2;
      }
    };
    function AudioLoader(manager2) {
      Loader.call(this, manager2);
    }
    AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: AudioLoader,
      load: function(url2, onLoad, onProgress, onError) {
        var loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.load(url2, function(buffer) {
          var bufferCopy = buffer.slice(0);
          var context = AudioContext2.getContext();
          context.decodeAudioData(bufferCopy, function(audioBuffer) {
            onLoad(audioBuffer);
          });
        }, onProgress, onError);
      }
    });
    function SphericalHarmonics3() {
      this.coefficients = [];
      for (var i3 = 0; i3 < 9; i3++) {
        this.coefficients.push(new Vector3());
      }
    }
    Object.assign(SphericalHarmonics3.prototype, {
      isSphericalHarmonics3: true,
      set: function(coefficients) {
        for (var i3 = 0; i3 < 9; i3++) {
          this.coefficients[i3].copy(coefficients[i3]);
        }
        return this;
      },
      zero: function() {
        for (var i3 = 0; i3 < 9; i3++) {
          this.coefficients[i3].set(0, 0, 0);
        }
        return this;
      },
      getAt: function(normal, target) {
        var x = normal.x, y2 = normal.y, z = normal.z;
        var coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScale(coeff[1], 0.488603 * y2);
        target.addScale(coeff[2], 0.488603 * z);
        target.addScale(coeff[3], 0.488603 * x);
        target.addScale(coeff[4], 1.092548 * (x * y2));
        target.addScale(coeff[5], 1.092548 * (y2 * z));
        target.addScale(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScale(coeff[7], 1.092548 * (x * z));
        target.addScale(coeff[8], 0.546274 * (x * x - y2 * y2));
        return target;
      },
      getIrradianceAt: function(normal, target) {
        var x = normal.x, y2 = normal.y, z = normal.z;
        var coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScale(coeff[1], 2 * 0.511664 * y2);
        target.addScale(coeff[2], 2 * 0.511664 * z);
        target.addScale(coeff[3], 2 * 0.511664 * x);
        target.addScale(coeff[4], 2 * 0.429043 * x * y2);
        target.addScale(coeff[5], 2 * 0.429043 * y2 * z);
        target.addScale(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScale(coeff[7], 2 * 0.429043 * x * z);
        target.addScale(coeff[8], 0.429043 * (x * x - y2 * y2));
        return target;
      },
      add: function(sh) {
        for (var i3 = 0; i3 < 9; i3++) {
          this.coefficients[i3].add(sh.coefficients[i3]);
        }
        return this;
      },
      scale: function(s2) {
        for (var i3 = 0; i3 < 9; i3++) {
          this.coefficients[i3].multiplyScalar(s2);
        }
        return this;
      },
      lerp: function(sh, alpha) {
        for (var i3 = 0; i3 < 9; i3++) {
          this.coefficients[i3].lerp(sh.coefficients[i3], alpha);
        }
        return this;
      },
      equals: function(sh) {
        for (var i3 = 0; i3 < 9; i3++) {
          if (!this.coefficients[i3].equals(sh.coefficients[i3])) {
            return false;
          }
        }
        return true;
      },
      copy: function(sh) {
        return this.set(sh.coefficients);
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      fromArray: function(array, offset) {
        if (offset === void 0)
          offset = 0;
        var coefficients = this.coefficients;
        for (var i3 = 0; i3 < 9; i3++) {
          coefficients[i3].fromArray(array, offset + i3 * 3);
        }
        return this;
      },
      toArray: function(array, offset) {
        if (array === void 0)
          array = [];
        if (offset === void 0)
          offset = 0;
        var coefficients = this.coefficients;
        for (var i3 = 0; i3 < 9; i3++) {
          coefficients[i3].toArray(array, offset + i3 * 3);
        }
        return array;
      }
    });
    Object.assign(SphericalHarmonics3, {
      getBasisAt: function(normal, shBasis) {
        var x = normal.x, y2 = normal.y, z = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y2;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y2;
        shBasis[5] = 1.092548 * y2 * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y2 * y2);
      }
    });
    function LightProbe(sh, intensity) {
      Light.call(this, void 0, intensity);
      this.sh = sh !== void 0 ? sh : new SphericalHarmonics3();
    }
    LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
      constructor: LightProbe,
      isLightProbe: true,
      copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        this.intensity = source.intensity;
        return this;
      },
      toJSON: function(meta) {
        var data = Light.prototype.toJSON.call(this, meta);
        return data;
      }
    });
    function HemisphereLightProbe(skyColor, groundColor, intensity) {
      LightProbe.call(this, void 0, intensity);
      var color1 = new Color().set(skyColor);
      var color2 = new Color().set(groundColor);
      var sky = new Vector3(color1.r, color1.g, color1.b);
      var ground = new Vector3(color2.r, color2.g, color2.b);
      var c0 = Math.sqrt(Math.PI);
      var c1 = c0 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
      this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
    HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
      constructor: HemisphereLightProbe,
      isHemisphereLightProbe: true,
      copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
      },
      toJSON: function(meta) {
        var data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
      }
    });
    function AmbientLightProbe(color, intensity) {
      LightProbe.call(this, void 0, intensity);
      var color1 = new Color().set(color);
      this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
      constructor: AmbientLightProbe,
      isAmbientLightProbe: true,
      copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
      },
      toJSON: function(meta) {
        var data = LightProbe.prototype.toJSON.call(this, meta);
        return data;
      }
    });
    var _eyeRight = new Matrix4();
    var _eyeLeft = new Matrix4();
    function StereoCamera() {
      this.type = "StereoCamera";
      this.aspect = 1;
      this.eyeSep = 0.064;
      this.cameraL = new PerspectiveCamera();
      this.cameraL.layers.enable(1);
      this.cameraL.matrixAutoUpdate = false;
      this.cameraR = new PerspectiveCamera();
      this.cameraR.layers.enable(2);
      this.cameraR.matrixAutoUpdate = false;
      this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      };
    }
    Object.assign(StereoCamera.prototype, {
      update: function(camera) {
        var cache = this._cache;
        var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera.focus;
          cache.fov = camera.fov;
          cache.aspect = camera.aspect * this.aspect;
          cache.near = camera.near;
          cache.far = camera.far;
          cache.zoom = camera.zoom;
          cache.eyeSep = this.eyeSep;
          var projectionMatrix = camera.projectionMatrix.clone();
          var eyeSepHalf = cache.eyeSep / 2;
          var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          var ymax = cache.near * Math.tan(_Math.DEG2RAD * cache.fov * 0.5) / cache.zoom;
          var xmin, xmax;
          _eyeLeft.elements[12] = -eyeSepHalf;
          _eyeRight.elements[12] = eyeSepHalf;
          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(projectionMatrix);
          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
      }
    });
    function Clock(autoStart) {
      this.autoStart = autoStart !== void 0 ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    Object.assign(Clock.prototype, {
      start: function() {
        this.startTime = (typeof performance === "undefined" ? Date : performance).now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          var newTime = (typeof performance === "undefined" ? Date : performance).now();
          diff = (newTime - this.oldTime) / 1000;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    });
    var _position$2 = new Vector3();
    var _quaternion$3 = new Quaternion();
    var _scale$1 = new Vector3();
    var _orientation = new Vector3();
    function AudioListener() {
      Object3D.call(this);
      this.type = "AudioListener";
      this.context = AudioContext2.getContext();
      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);
      this.filter = null;
      this.timeDelta = 0;
      this._clock = new Clock();
    }
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: AudioListener,
      getInput: function() {
        return this.gain;
      },
      removeFilter: function() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      },
      getFilter: function() {
        return this.filter;
      },
      setFilter: function(value2) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value2;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      },
      getMasterVolume: function() {
        return this.gain.gain.value;
      },
      setMasterVolume: function(value2) {
        this.gain.gain.setTargetAtTime(value2, this.context.currentTime, 0.01);
        return this;
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
        _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
        if (listener.positionX) {
          var endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
          listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
        }
      }
    });
    function Audio(listener) {
      Object3D.call(this);
      this.type = "Audio";
      this.listener = listener;
      this.context = listener.context;
      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());
      this.autoplay = false;
      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = void 0;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.sourceType = "empty";
      this._startedAt = 0;
      this._pausedAt = 0;
      this.filters = [];
    }
    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
      constructor: Audio,
      getOutput: function() {
        return this.gain;
      },
      setNodeSource: function(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      },
      setMediaElementSource: function(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      },
      setMediaStreamSource: function(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      },
      setBuffer: function(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay)
          this.play();
        return this;
      },
      play: function(delay) {
        if (delay === void 0)
          delay = 0;
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        var source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._pausedAt + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      },
      pause: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      },
      stop: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._pausedAt = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
      },
      connect: function() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (var i3 = 1, l = this.filters.length; i3 < l; i3++) {
            this.filters[i3 - 1].connect(this.filters[i3]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        return this;
      },
      disconnect: function() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var i3 = 1, l = this.filters.length; i3 < l; i3++) {
            this.filters[i3 - 1].disconnect(this.filters[i3]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        return this;
      },
      getFilters: function() {
        return this.filters;
      },
      setFilters: function(value2) {
        if (!value2)
          value2 = [];
        if (this.isPlaying === true) {
          this.disconnect();
          this.filters = value2;
          this.connect();
        } else {
          this.filters = value2;
        }
        return this;
      },
      setDetune: function(value2) {
        this.detune = value2;
        if (this.source.detune === void 0)
          return;
        if (this.isPlaying === true) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      },
      getDetune: function() {
        return this.detune;
      },
      getFilter: function() {
        return this.getFilters()[0];
      },
      setFilter: function(filter) {
        return this.setFilters(filter ? [filter] : []);
      },
      setPlaybackRate: function(value2) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value2;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      },
      getPlaybackRate: function() {
        return this.playbackRate;
      },
      onEnded: function() {
        this.isPlaying = false;
      },
      getLoop: function() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      },
      setLoop: function(value2) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value2;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      },
      setLoopStart: function(value2) {
        this.loopStart = value2;
        return this;
      },
      setLoopEnd: function(value2) {
        this.loopEnd = value2;
        return this;
      },
      getVolume: function() {
        return this.gain.gain.value;
      },
      setVolume: function(value2) {
        this.gain.gain.setTargetAtTime(value2, this.context.currentTime, 0.01);
        return this;
      }
    });
    var _position$3 = new Vector3();
    var _quaternion$4 = new Quaternion();
    var _scale$2 = new Vector3();
    var _orientation$1 = new Vector3();
    function PositionalAudio(listener) {
      Audio.call(this, listener);
      this.panner = this.context.createPanner();
      this.panner.panningModel = "HRTF";
      this.panner.connect(this.gain);
    }
    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
      constructor: PositionalAudio,
      getOutput: function() {
        return this.panner;
      },
      getRefDistance: function() {
        return this.panner.refDistance;
      },
      setRefDistance: function(value2) {
        this.panner.refDistance = value2;
        return this;
      },
      getRolloffFactor: function() {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function(value2) {
        this.panner.rolloffFactor = value2;
        return this;
      },
      getDistanceModel: function() {
        return this.panner.distanceModel;
      },
      setDistanceModel: function(value2) {
        this.panner.distanceModel = value2;
        return this;
      },
      getMaxDistance: function() {
        return this.panner.maxDistance;
      },
      setMaxDistance: function(value2) {
        this.panner.maxDistance = value2;
        return this;
      },
      setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      },
      updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        if (this.hasPlaybackControl === true && this.isPlaying === false)
          return;
        this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
        _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
        var panner = this.panner;
        if (panner.positionX) {
          var endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        } else {
          panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
          panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
        }
      }
    });
    function AudioAnalyser(audio, fftSize) {
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    Object.assign(AudioAnalyser.prototype, {
      getFrequencyData: function() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      },
      getAverageFrequency: function() {
        var value2 = 0, data = this.getFrequencyData();
        for (var i3 = 0; i3 < data.length; i3++) {
          value2 += data[i3];
        }
        return value2 / data.length;
      }
    });
    function PropertyMixer(binding, typeName, valueSize) {
      this.binding = binding;
      this.valueSize = valueSize;
      var bufferType = Float64Array, mixFunction;
      switch (typeName) {
        case "quaternion":
          mixFunction = this._slerp;
          break;
        case "string":
        case "bool":
          bufferType = Array;
          mixFunction = this._select;
          break;
        default:
          mixFunction = this._lerp;
      }
      this.buffer = new bufferType(valueSize * 4);
      this._mixBufferRegion = mixFunction;
      this.cumulativeWeight = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }
    Object.assign(PropertyMixer.prototype, {
      accumulate: function(accuIndex, weight) {
        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (var i3 = 0; i3 !== stride; ++i3) {
            buffer[offset + i3] = buffer[i3];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          var mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      },
      apply: function(accuIndex) {
        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
        this.cumulativeWeight = 0;
        if (weight < 1) {
          var originalValueOffset = stride * 3;
          this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        for (var i3 = stride, e = stride + stride; i3 !== e; ++i3) {
          if (buffer[i3] !== buffer[i3 + stride]) {
            binding.setValue(buffer, offset);
            break;
          }
        }
      },
      saveOriginalState: function() {
        var binding = this.binding;
        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
        binding.getValue(buffer, originalValueOffset);
        for (var i3 = stride, e = originalValueOffset; i3 !== e; ++i3) {
          buffer[i3] = buffer[originalValueOffset + i3 % stride];
        }
        this.cumulativeWeight = 0;
      },
      restoreOriginalState: function() {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      },
      _select: function(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
          for (var i3 = 0; i3 !== stride; ++i3) {
            buffer[dstOffset + i3] = buffer[srcOffset + i3];
          }
        }
      },
      _slerp: function(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
      },
      _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
        var s2 = 1 - t;
        for (var i3 = 0; i3 !== stride; ++i3) {
          var j = dstOffset + i3;
          buffer[j] = buffer[j] * s2 + buffer[srcOffset + i3] * t;
        }
      }
    });
    var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
    var _supportedObjectNames = ["material", "materials", "bones"];
    function Composite(targetGroup, path, optionalParsedPath) {
      var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    Object.assign(Composite.prototype, {
      getValue: function(array, offset) {
        this.bind();
        var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array, offset);
      },
      setValue: function(array, offset) {
        var bindings = this._bindings;
        for (var i3 = this._targetGroup.nCachedObjects_, n = bindings.length; i3 !== n; ++i3) {
          bindings[i3].setValue(array, offset);
        }
      },
      bind: function() {
        var bindings = this._bindings;
        for (var i3 = this._targetGroup.nCachedObjects_, n = bindings.length; i3 !== n; ++i3) {
          bindings[i3].bind();
        }
      },
      unbind: function() {
        var bindings = this._bindings;
        for (var i3 = this._targetGroup.nCachedObjects_, n = bindings.length; i3 !== n; ++i3) {
          bindings[i3].unbind();
        }
      }
    });
    function PropertyBinding(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
      this.rootNode = rootNode;
    }
    Object.assign(PropertyBinding, {
      Composite,
      create: function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      },
      sanitizeNodeName: function(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      },
      parseTrackName: function(trackName) {
        var matches = _trackRe.exec(trackName);
        if (!matches) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        var results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          var objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      },
      findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          var bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          var searchNodeSubtree = function(children2) {
            for (var i3 = 0; i3 < children2.length; i3++) {
              var childNode = children2[i3];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              var result = searchNodeSubtree(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          var subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
    });
    Object.assign(PropertyBinding.prototype, {
      _getValue_unavailable: function() {
      },
      _setValue_unavailable: function() {
      },
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      },
      Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      },
      GetterByBindingType: [function getValue_direct(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
      }, function getValue_array(buffer, offset) {
        var source = this.resolvedProperty;
        for (var i3 = 0, n = source.length; i3 !== n; ++i3) {
          buffer[offset++] = source[i3];
        }
      }, function getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }, function getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }],
      SetterByBindingTypeAndVersioning: [[function setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      }, function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function setValue_array(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i3 = 0, n = dest.length; i3 !== n; ++i3) {
          dest[i3] = buffer[offset++];
        }
      }, function setValue_array_setNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i3 = 0, n = dest.length; i3 !== n; ++i3) {
          dest[i3] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i3 = 0, n = dest.length; i3 !== n; ++i3) {
          dest[i3] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }]],
      getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      },
      setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      },
      bind: function() {
        var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          var objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (var i3 = 0; i3 < targetObject.length; i3++) {
                if (targetObject[i3].name === objectIndex) {
                  objectIndex = i3;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          var nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        var versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (targetObject.geometry.isBufferGeometry) {
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              for (var i3 = 0; i3 < this.node.geometry.morphAttributes.position.length; i3++) {
                if (targetObject.geometry.morphAttributes.position[i3].name === propertyIndex) {
                  propertyIndex = i3;
                  break;
                }
              }
            } else {
              if (!targetObject.geometry.morphTargets) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                return;
              }
              for (var i3 = 0; i3 < this.node.geometry.morphTargets.length; i3++) {
                if (targetObject.geometry.morphTargets[i3].name === propertyIndex) {
                  propertyIndex = i3;
                  break;
                }
              }
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      },
      unbind: function() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    });
    Object.assign(PropertyBinding.prototype, {
      _getValue_unbound: PropertyBinding.prototype.getValue,
      _setValue_unbound: PropertyBinding.prototype.setValue
    });
    function AnimationObjectGroup() {
      this.uuid = _Math.generateUUID();
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0;
      var indices = {};
      this._indicesByUUID = indices;
      for (var i3 = 0, n = arguments.length; i3 !== n; ++i3) {
        indices[arguments[i3].uuid] = i3;
      }
      this._paths = [];
      this._parsedPaths = [];
      this._bindings = [];
      this._bindingsIndicesByPath = {};
      var scope = this;
      this.stats = {
        objects: {
          get total() {
            return scope._objects.length;
          },
          get inUse() {
            return this.total - scope.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return scope._bindings.length;
        }
      };
    }
    Object.assign(AnimationObjectGroup.prototype, {
      isAnimationObjectGroup: true,
      add: function() {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = void 0;
        for (var i3 = 0, n = arguments.length; i3 !== n; ++i3) {
          var object = arguments[i3], uuid = object.uuid, index2 = indicesByUUID[uuid];
          if (index2 === void 0) {
            index2 = nObjects++;
            indicesByUUID[uuid] = index2;
            objects.push(object);
            for (var j = 0, m2 = nBindings; j !== m2; ++j) {
              bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            }
          } else if (index2 < nCachedObjects) {
            knownObject = objects[index2];
            var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index2;
            objects[index2] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (var j = 0, m2 = nBindings; j !== m2; ++j) {
              var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index2];
              bindingsForPath[index2] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index2] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      remove: function() {
        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i3 = 0, n = arguments.length; i3 !== n; ++i3) {
          var object = arguments[i3], uuid = object.uuid, index2 = indicesByUUID[uuid];
          if (index2 !== void 0 && index2 >= nCachedObjects) {
            var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index2;
            objects[index2] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (var j = 0, m2 = nBindings; j !== m2; ++j) {
              var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
              bindingsForPath[index2] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      uncache: function() {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i3 = 0, n = arguments.length; i3 !== n; ++i3) {
          var object = arguments[i3], uuid = object.uuid, index2 = indicesByUUID[uuid];
          if (index2 !== void 0) {
            delete indicesByUUID[uuid];
            if (index2 < nCachedObjects) {
              var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index2;
              objects[index2] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (var j = 0, m2 = nBindings; j !== m2; ++j) {
                var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index2] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              var lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastObject.uuid] = index2;
              objects[index2] = lastObject;
              objects.pop();
              for (var j = 0, m2 = nBindings; j !== m2; ++j) {
                var bindingsForPath = bindings[j];
                bindingsForPath[index2] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      },
      subscribe_: function(path, parsedPath) {
        var indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path], bindings = this._bindings;
        if (index2 !== void 0)
          return bindings[index2];
        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index2 = bindings.length;
        indicesByPath[path] = index2;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (var i3 = nCachedObjects, n = objects.length; i3 !== n; ++i3) {
          var object = objects[i3];
          bindingsForPath[i3] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      },
      unsubscribe_: function(path) {
        var indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path];
        if (index2 !== void 0) {
          var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index2;
          bindings[index2] = lastBindings;
          bindings.pop();
          parsedPaths[index2] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index2] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    });
    function AnimationAction(mixer, clip, localRoot) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot || null;
      var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      var interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (var i3 = 0; i3 !== nTracks; ++i3) {
        var interpolant = tracks[i3].createInterpolant(null);
        interpolants[i3] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    Object.assign(AnimationAction.prototype, {
      play: function() {
        this._mixer._activateAction(this);
        return this;
      },
      stop: function() {
        this._mixer._deactivateAction(this);
        return this.reset();
      },
      reset: function() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      },
      isRunning: function() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      },
      isScheduled: function() {
        return this._mixer._isActiveAction(this);
      },
      startAt: function(time2) {
        this._startTime = time2;
        return this;
      },
      setLoop: function(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      },
      setEffectiveWeight: function(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      },
      getEffectiveWeight: function() {
        return this._effectiveWeight;
      },
      fadeIn: function(duration) {
        return this._scheduleFading(duration, 0, 1);
      },
      fadeOut: function(duration) {
        return this._scheduleFading(duration, 1, 0);
      },
      crossFadeFrom: function(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      },
      crossFadeTo: function(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      },
      stopFading: function() {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      },
      setEffectiveTimeScale: function(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      },
      getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
      },
      setDuration: function(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      },
      syncWith: function(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      },
      halt: function(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      },
      warp: function(startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      },
      stopWarping: function() {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      },
      getMixer: function() {
        return this._mixer;
      },
      getClip: function() {
        return this._clip;
      },
      getRoot: function() {
        return this._localRoot || this._mixer._root;
      },
      _update: function(time2, deltaTime2, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time2);
          return;
        }
        var startTime = this._startTime;
        if (startTime !== null) {
          var timeRunning = (time2 - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            return;
          }
          this._startTime = null;
          deltaTime2 = timeDirection * timeRunning;
        }
        deltaTime2 *= this._updateTimeScale(time2);
        var clipTime = this._updateTime(deltaTime2);
        var weight = this._updateWeight(time2);
        if (weight > 0) {
          var interpolants = this._interpolants;
          var propertyMixers = this._propertyBindings;
          for (var j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
        }
      },
      _updateWeight: function(time2) {
        var weight = 0;
        if (this.enabled) {
          weight = this.weight;
          var interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time2)[0];
            weight *= interpolantValue;
            if (time2 > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      },
      _updateTimeScale: function(time2) {
        var timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          var interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time2)[0];
            timeScale *= interpolantValue;
            if (time2 > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      },
      _updateTime: function(deltaTime2) {
        var time2 = this.time + deltaTime2;
        var duration = this._clip.duration;
        var loop2 = this.loop;
        var loopCount = this._loopCount;
        var pingPong = loop2 === LoopPingPong;
        if (deltaTime2 === 0) {
          if (loopCount === -1)
            return time2;
          return pingPong && (loopCount & 1) === 1 ? duration - time2 : time2;
        }
        if (loop2 === LoopOnce) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time2 >= duration) {
              time2 = duration;
            } else if (time2 < 0) {
              time2 = 0;
            } else {
              this.time = time2;
              break handle_stop;
            }
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            this.time = time2;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime2 < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime2 >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time2 >= duration || time2 < 0) {
            var loopDelta = Math.floor(time2 / duration);
            time2 -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            var pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              time2 = deltaTime2 > 0 ? duration : 0;
              this.time = time2;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime2 > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                var atStart = deltaTime2 < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time2;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time2;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time2;
          }
        }
        return time2;
      },
      _setEndings: function(atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      },
      _scheduleFading: function(duration, weightNow, weightThen) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
      }
    });
    function AnimationMixer(root) {
      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;
      this.time = 0;
      this.timeScale = 1;
    }
    AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
      constructor: AnimationMixer,
      _bindAction: function(action, prototypeAction) {
        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (var i3 = 0; i3 !== nTracks; ++i3) {
          var track = tracks[i3], trackName = track.name, binding = bindingsByName[trackName];
          if (binding !== void 0) {
            bindings[i3] = binding;
          } else {
            binding = bindings[i3];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            var path = prototypeAction && prototypeAction._propertyBindings[i3].binding.parsedPath;
            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i3] = binding;
          }
          interpolants[i3].resultBuffer = binding.buffer;
        }
      },
      _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          var bindings = action._propertyBindings;
          for (var i3 = 0, n = bindings.length; i3 !== n; ++i3) {
            var binding = bindings[i3];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      },
      _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
          var bindings = action._propertyBindings;
          for (var i3 = 0, n = bindings.length; i3 !== n; ++i3) {
            var binding = bindings[i3];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      },
      _initMemoryManager: function() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      },
      _isActiveAction: function(action) {
        var index2 = action._cacheIndex;
        return index2 !== null && index2 < this._nActiveActions;
      },
      _addInactiveAction: function(action, clipUuid, rootUuid) {
        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          var knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      },
      _removeInactiveAction: function(action) {
        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      },
      _removeInactiveBindingsForAction: function(action) {
        var bindings = action._propertyBindings;
        for (var i3 = 0, n = bindings.length; i3 !== n; ++i3) {
          var binding = bindings[i3];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      },
      _lendAction: function(action) {
        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      },
      _takeBackAction: function(action) {
        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      },
      _addInactiveBinding: function(binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      },
      _removeInactiveBinding: function(binding) {
        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      },
      _lendBinding: function(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      },
      _takeBackBinding: function(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      },
      _lendControlInterpolant: function() {
        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      },
      _takeBackControlInterpolant: function(interpolant) {
        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function(clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (actionsForClip !== void 0) {
          var existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
          return null;
        var newAction = new AnimationAction(this, clipObject, optionalRoot);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      },
      existingAction: function(clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      },
      stopAllAction: function() {
        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
        this._nActiveActions = 0;
        this._nActiveBindings = 0;
        for (var i3 = 0; i3 !== nActions; ++i3) {
          actions[i3].reset();
        }
        for (var i3 = 0; i3 !== nBindings; ++i3) {
          bindings[i3].useCount = 0;
        }
        return this;
      },
      update: function(deltaTime2) {
        deltaTime2 *= this.timeScale;
        var actions = this._actions, nActions = this._nActiveActions, time2 = this.time += deltaTime2, timeDirection = Math.sign(deltaTime2), accuIndex = this._accuIndex ^= 1;
        for (var i3 = 0; i3 !== nActions; ++i3) {
          var action = actions[i3];
          action._update(time2, deltaTime2, timeDirection, accuIndex);
        }
        var bindings = this._bindings, nBindings = this._nActiveBindings;
        for (var i3 = 0; i3 !== nBindings; ++i3) {
          bindings[i3].apply(accuIndex);
        }
        return this;
      },
      setTime: function(timeInSeconds) {
        this.time = 0;
        for (var i3 = 0; i3 < this._actions.length; i3++) {
          this._actions[i3].time = 0;
        }
        return this.update(timeInSeconds);
      },
      getRoot: function() {
        return this._root;
      },
      uncacheClip: function(clip) {
        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          var actionsToRemove = actionsForClip.knownActions;
          for (var i3 = 0, n = actionsToRemove.length; i3 !== n; ++i3) {
            var action = actionsToRemove[i3];
            this._deactivateAction(action);
            var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      },
      uncacheRoot: function(root) {
        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (var clipUuid in actionsByClip) {
          var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (var trackName in bindingByName) {
            var binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      },
      uncacheAction: function(clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    });
    function Uniform(value2) {
      if (typeof value2 === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value2 = arguments[1];
      }
      this.value = value2;
    }
    Uniform.prototype.clone = function() {
      return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    };
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
      InterleavedBuffer.call(this, array, stride);
      this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
      constructor: InstancedInterleavedBuffer,
      isInstancedInterleavedBuffer: true,
      copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
    });
    function Raycaster(origin, direction, near, far) {
      this.ray = new Ray(origin, direction);
      this.near = near || 0;
      this.far = far || Infinity;
      this.camera = null;
      this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function() {
            console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
            return this.Points;
          }
        }
      });
    }
    function ascSort(a, b) {
      return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects2, recursive) {
      if (object.visible === false)
        return;
      object.raycast(raycaster, intersects2);
      if (recursive === true) {
        var children2 = object.children;
        for (var i3 = 0, l = children2.length; i3 < l; i3++) {
          intersectObject(children2[i3], raycaster, intersects2, true);
        }
      }
    }
    Object.assign(Raycaster.prototype, {
      linePrecision: 1,
      set: function(origin, direction) {
        this.ray.set(origin, direction);
      },
      setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type.");
        }
      },
      intersectObject: function(object, recursive, optionalTarget) {
        var intersects2 = optionalTarget || [];
        intersectObject(object, this, intersects2, recursive);
        intersects2.sort(ascSort);
        return intersects2;
      },
      intersectObjects: function(objects, recursive, optionalTarget) {
        var intersects2 = optionalTarget || [];
        if (Array.isArray(objects) === false) {
          console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
          return intersects2;
        }
        for (var i3 = 0, l = objects.length; i3 < l; i3++) {
          intersectObject(objects[i3], this, intersects2, recursive);
        }
        intersects2.sort(ascSort);
        return intersects2;
      }
    });
    function Spherical(radius, phi, theta) {
      this.radius = radius !== void 0 ? radius : 1;
      this.phi = phi !== void 0 ? phi : 0;
      this.theta = theta !== void 0 ? theta : 0;
      return this;
    }
    Object.assign(Spherical.prototype, {
      set: function(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      },
      makeSafe: function() {
        var EPS = 1e-06;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      },
      setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      },
      setFromCartesianCoords: function(x, y2, z) {
        this.radius = Math.sqrt(x * x + y2 * y2 + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(_Math.clamp(y2 / this.radius, -1, 1));
        }
        return this;
      }
    });
    function Cylindrical(radius, theta, y2) {
      this.radius = radius !== void 0 ? radius : 1;
      this.theta = theta !== void 0 ? theta : 0;
      this.y = y2 !== void 0 ? y2 : 0;
      return this;
    }
    Object.assign(Cylindrical.prototype, {
      set: function(radius, theta, y2) {
        this.radius = radius;
        this.theta = theta;
        this.y = y2;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      },
      setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      },
      setFromCartesianCoords: function(x, y2, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y2;
        return this;
      }
    });
    var _vector$8 = new Vector2();
    function Box2(min, max) {
      this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
      this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
    }
    Object.assign(Box2.prototype, {
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i3 = 0, il = points.length; i3 < il; i3++) {
          this.expandByPoint(points[i3]);
        }
        return this;
      },
      setFromCenterAndSize: function(center, size) {
        var halfSize = _vector$8.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getCenter() target is now required");
          target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      getSize: function(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getSize() target is now required");
          target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
      },
      containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      },
      getParameter: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getParameter() target is now required");
          target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      intersectsBox: function(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
      },
      clampPoint: function(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .clampPoint() target is now required");
          target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function(point) {
        var clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      },
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    });
    var _startP = new Vector3();
    var _startEnd = new Vector3();
    function Line3(start, end) {
      this.start = start !== void 0 ? start : new Vector3();
      this.end = end !== void 0 ? end : new Vector3();
    }
    Object.assign(Line3.prototype, {
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      getCenter: function(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .getCenter() target is now required");
          target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .delta() target is now required");
          target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t, target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .at() target is now required");
          target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: function(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        var startEnd2 = _startEnd.dot(_startEnd);
        var startEnd_startP = _startEnd.dot(_startP);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = _Math.clamp(t, 0, 1);
        }
        return t;
      },
      closestPointToPoint: function(point, clampToLine, target) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        if (target === void 0) {
          console.warn("THREE.Line3: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
    });
    function ImmediateRenderObject(material2) {
      Object3D.call(this);
      this.material = material2;
      this.render = function() {
      };
    }
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    var _vector$9 = new Vector3();
    function SpotLightHelper(light, color) {
      Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.color = color;
      var geometry = new BufferGeometry();
      var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (var i3 = 0, j = 1, l = 32; i3 < l; i3++, j++) {
        var p1 = i3 / l * Math.PI * 2;
        var p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
      var material2 = new LineBasicMaterial({
        fog: false
      });
      this.cone = new LineSegments(geometry, material2);
      this.add(this.cone);
      this.update();
    }
    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    SpotLightHelper.prototype.update = function() {
      this.light.updateMatrixWorld();
      var coneLength = this.light.distance ? this.light.distance : 1000;
      var coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(_vector$9);
      if (this.color !== void 0) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    };
    var _vector$a = new Vector3();
    var _boneMatrix = new Matrix4();
    var _matrixWorldInv = new Matrix4();
    function getBoneList(object) {
      var boneList = [];
      if (object && object.isBone) {
        boneList.push(object);
      }
      for (var i3 = 0; i3 < object.children.length; i3++) {
        boneList.push.apply(boneList, getBoneList(object.children[i3]));
      }
      return boneList;
    }
    function SkeletonHelper(object) {
      var bones = getBoneList(object);
      var geometry = new BufferGeometry();
      var vertices = [];
      var colors = [];
      var color1 = new Color(0, 0, 1);
      var color2 = new Color(0, 1, 0);
      for (var i3 = 0; i3 < bones.length; i3++) {
        var bone = bones[i3];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      var material2 = new LineBasicMaterial({
        vertexColors: VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      LineSegments.call(this, geometry, material2);
      this.root = object;
      this.bones = bones;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    }
    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    SkeletonHelper.prototype.updateMatrixWorld = function(force) {
      var bones = this.bones;
      var geometry = this.geometry;
      var position = geometry.getAttribute("position");
      _matrixWorldInv.getInverse(this.root.matrixWorld);
      for (var i3 = 0, j = 0; i3 < bones.length; i3++) {
        var bone = bones[i3];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$a.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$a.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
          j += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    function PointLightHelper(light, sphereSize, color) {
      this.light = light;
      this.light.updateMatrixWorld();
      this.color = color;
      var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
      var material2 = new MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      Mesh.call(this, geometry, material2);
      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.update();
    }
    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;
    PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    PointLightHelper.prototype.update = function() {
      if (this.color !== void 0) {
        this.material.color.set(this.color);
      } else {
        this.material.color.copy(this.light.color);
      }
    };
    var _vector$b = new Vector3();
    var _color1 = new Color();
    var _color2 = new Color();
    function HemisphereLightHelper(light, size, color) {
      Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.color = color;
      var geometry = new OctahedronBufferGeometry(size);
      geometry.rotateY(Math.PI * 0.5);
      this.material = new MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      if (this.color === void 0)
        this.material.vertexColors = VertexColors;
      var position = geometry.getAttribute("position");
      var colors = new Float32Array(position.count * 3);
      geometry.setAttribute("color", new BufferAttribute(colors, 3));
      this.add(new Mesh(geometry, this.material));
      this.update();
    }
    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    HemisphereLightHelper.prototype.dispose = function() {
      this.children[0].geometry.dispose();
      this.children[0].material.dispose();
    };
    HemisphereLightHelper.prototype.update = function() {
      var mesh = this.children[0];
      if (this.color !== void 0) {
        this.material.color.set(this.color);
      } else {
        var colors = mesh.geometry.getAttribute("color");
        _color1.copy(this.light.color);
        _color2.copy(this.light.groundColor);
        for (var i3 = 0, l = colors.count; i3 < l; i3++) {
          var color = i3 < l / 2 ? _color1 : _color2;
          colors.setXYZ(i3, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
      }
      mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
    function GridHelper(size, divisions, color1, color2) {
      size = size || 10;
      divisions = divisions || 10;
      color1 = new Color(color1 !== void 0 ? color1 : 4473924);
      color2 = new Color(color2 !== void 0 ? color2 : 8947848);
      var center = divisions / 2;
      var step = size / divisions;
      var halfSize = size / 2;
      var vertices = [], colors = [];
      for (var i3 = 0, j = 0, k = -halfSize; i3 <= divisions; i3++, k += step) {
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        var color = i3 === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
      }
      var geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      var material2 = new LineBasicMaterial({
        vertexColors: VertexColors
      });
      LineSegments.call(this, geometry, material2);
    }
    GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
      constructor: GridHelper,
      copy: function(source) {
        LineSegments.prototype.copy.call(this, source);
        this.geometry.copy(source.geometry);
        this.material.copy(source.material);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    });
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
      radius = radius || 10;
      radials = radials || 16;
      circles = circles || 8;
      divisions = divisions || 64;
      color1 = new Color(color1 !== void 0 ? color1 : 4473924);
      color2 = new Color(color2 !== void 0 ? color2 : 8947848);
      var vertices = [];
      var colors = [];
      var x, z;
      var v, i3, j, r, color;
      for (i3 = 0; i3 <= radials; i3++) {
        v = i3 / radials * (Math.PI * 2);
        x = Math.sin(v) * radius;
        z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        color = i3 & 1 ? color1 : color2;
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
      }
      for (i3 = 0; i3 <= circles; i3++) {
        color = i3 & 1 ? color1 : color2;
        r = radius - radius / circles * i3;
        for (j = 0; j < divisions; j++) {
          v = j / divisions * (Math.PI * 2);
          x = Math.sin(v) * r;
          z = Math.cos(v) * r;
          vertices.push(x, 0, z);
          colors.push(color.r, color.g, color.b);
          v = (j + 1) / divisions * (Math.PI * 2);
          x = Math.sin(v) * r;
          z = Math.cos(v) * r;
          vertices.push(x, 0, z);
          colors.push(color.r, color.g, color.b);
        }
      }
      var geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      var material2 = new LineBasicMaterial({
        vertexColors: VertexColors
      });
      LineSegments.call(this, geometry, material2);
    }
    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;
    var _v1$5 = new Vector3();
    var _v2$3 = new Vector3();
    var _v3$1 = new Vector3();
    function DirectionalLightHelper(light, size, color) {
      Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.color = color;
      if (size === void 0)
        size = 1;
      var geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
      var material2 = new LineBasicMaterial({
        fog: false
      });
      this.lightPlane = new Line(geometry, material2);
      this.add(this.lightPlane);
      geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
      this.targetLine = new Line(geometry, material2);
      this.add(this.targetLine);
      this.update();
    }
    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    DirectionalLightHelper.prototype.update = function() {
      _v1$5.setFromMatrixPosition(this.light.matrixWorld);
      _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
      _v3$1.subVectors(_v2$3, _v1$5);
      this.lightPlane.lookAt(_v2$3);
      if (this.color !== void 0) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }
      this.targetLine.lookAt(_v2$3);
      this.targetLine.scale.z = _v3$1.length();
    };
    var _vector$c = new Vector3();
    var _camera = new Camera();
    function CameraHelper(camera) {
      var geometry = new BufferGeometry();
      var material2 = new LineBasicMaterial({
        color: 16777215,
        vertexColors: FaceColors
      });
      var vertices = [];
      var colors = [];
      var pointMap = {};
      var colorFrustum = new Color(16755200);
      var colorCone = new Color(16711680);
      var colorUp = new Color(43775);
      var colorTarget = new Color(16777215);
      var colorCross = new Color(3355443);
      addLine("n1", "n2", colorFrustum);
      addLine("n2", "n4", colorFrustum);
      addLine("n4", "n3", colorFrustum);
      addLine("n3", "n1", colorFrustum);
      addLine("f1", "f2", colorFrustum);
      addLine("f2", "f4", colorFrustum);
      addLine("f4", "f3", colorFrustum);
      addLine("f3", "f1", colorFrustum);
      addLine("n1", "f1", colorFrustum);
      addLine("n2", "f2", colorFrustum);
      addLine("n3", "f3", colorFrustum);
      addLine("n4", "f4", colorFrustum);
      addLine("p", "n1", colorCone);
      addLine("p", "n2", colorCone);
      addLine("p", "n3", colorCone);
      addLine("p", "n4", colorCone);
      addLine("u1", "u2", colorUp);
      addLine("u2", "u3", colorUp);
      addLine("u3", "u1", colorUp);
      addLine("c", "t", colorTarget);
      addLine("p", "c", colorCross);
      addLine("cn1", "cn2", colorCross);
      addLine("cn3", "cn4", colorCross);
      addLine("cf1", "cf2", colorCross);
      addLine("cf3", "cf4", colorCross);
      function addLine(a, b, color) {
        addPoint(a, color);
        addPoint(b, color);
      }
      function addPoint(id, color) {
        vertices.push(0, 0, 0);
        colors.push(color.r, color.g, color.b);
        if (pointMap[id] === void 0) {
          pointMap[id] = [];
        }
        pointMap[id].push(vertices.length / 3 - 1);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      LineSegments.call(this, geometry, material2);
      this.camera = camera;
      if (this.camera.updateProjectionMatrix)
        this.camera.updateProjectionMatrix();
      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;
      this.pointMap = pointMap;
      this.update();
    }
    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;
    CameraHelper.prototype.update = function() {
      var geometry = this.geometry;
      var pointMap = this.pointMap;
      var w2 = 1, h2 = 1;
      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
      setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
      setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
      setPoint("n1", pointMap, geometry, _camera, -w2, -h2, -1);
      setPoint("n2", pointMap, geometry, _camera, w2, -h2, -1);
      setPoint("n3", pointMap, geometry, _camera, -w2, h2, -1);
      setPoint("n4", pointMap, geometry, _camera, w2, h2, -1);
      setPoint("f1", pointMap, geometry, _camera, -w2, -h2, 1);
      setPoint("f2", pointMap, geometry, _camera, w2, -h2, 1);
      setPoint("f3", pointMap, geometry, _camera, -w2, h2, 1);
      setPoint("f4", pointMap, geometry, _camera, w2, h2, 1);
      setPoint("u1", pointMap, geometry, _camera, w2 * 0.7, h2 * 1.1, -1);
      setPoint("u2", pointMap, geometry, _camera, -w2 * 0.7, h2 * 1.1, -1);
      setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
      setPoint("cf1", pointMap, geometry, _camera, -w2, 0, 1);
      setPoint("cf2", pointMap, geometry, _camera, w2, 0, 1);
      setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
      setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
      setPoint("cn1", pointMap, geometry, _camera, -w2, 0, -1);
      setPoint("cn2", pointMap, geometry, _camera, w2, 0, -1);
      setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
      setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
      geometry.getAttribute("position").needsUpdate = true;
    };
    function setPoint(point, pointMap, geometry, camera, x, y2, z) {
      _vector$c.set(x, y2, z).unproject(camera);
      var points = pointMap[point];
      if (points !== void 0) {
        var position = geometry.getAttribute("position");
        for (var i3 = 0, l = points.length; i3 < l; i3++) {
          position.setXYZ(points[i3], _vector$c.x, _vector$c.y, _vector$c.z);
        }
      }
    }
    var _box$3 = new Box3();
    function BoxHelper(object, color) {
      this.object = object;
      if (color === void 0)
        color = 16776960;
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = new Float32Array(8 * 3);
      var geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute("position", new BufferAttribute(positions, 3));
      LineSegments.call(this, geometry, new LineBasicMaterial({
        color
      }));
      this.matrixAutoUpdate = false;
      this.update();
    }
    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;
    BoxHelper.prototype.update = function(object) {
      if (object !== void 0) {
        console.warn("THREE.BoxHelper: .update() has no longer arguments.");
      }
      if (this.object !== void 0) {
        _box$3.setFromObject(this.object);
      }
      if (_box$3.isEmpty())
        return;
      var min = _box$3.min;
      var max = _box$3.max;
      var position = this.geometry.attributes.position;
      var array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    };
    BoxHelper.prototype.setFromObject = function(object) {
      this.object = object;
      this.update();
      return this;
    };
    BoxHelper.prototype.copy = function(source) {
      LineSegments.prototype.copy.call(this, source);
      this.object = source.object;
      return this;
    };
    BoxHelper.prototype.clone = function() {
      return new this.constructor().copy(this);
    };
    function Box3Helper(box, color) {
      this.type = "Box3Helper";
      this.box = box;
      color = color || 16776960;
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
      var geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
      LineSegments.call(this, geometry, new LineBasicMaterial({
        color
      }));
      this.geometry.computeBoundingSphere();
    }
    Box3Helper.prototype = Object.create(LineSegments.prototype);
    Box3Helper.prototype.constructor = Box3Helper;
    Box3Helper.prototype.updateMatrixWorld = function(force) {
      var box = this.box;
      if (box.isEmpty())
        return;
      box.getCenter(this.position);
      box.getSize(this.scale);
      this.scale.multiplyScalar(0.5);
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    function PlaneHelper(plane, size, hex) {
      this.type = "PlaneHelper";
      this.plane = plane;
      this.size = size === void 0 ? 1 : size;
      var color = hex !== void 0 ? hex : 16776960;
      var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
      var geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
      geometry.computeBoundingSphere();
      Line.call(this, geometry, new LineBasicMaterial({
        color
      }));
      var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
      var geometry2 = new BufferGeometry();
      geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
      geometry2.computeBoundingSphere();
      this.add(new Mesh(geometry2, new MeshBasicMaterial({
        color,
        opacity: 0.2,
        transparent: true,
        depthWrite: false
      })));
    }
    PlaneHelper.prototype = Object.create(Line.prototype);
    PlaneHelper.prototype.constructor = PlaneHelper;
    PlaneHelper.prototype.updateMatrixWorld = function(force) {
      var scale = -this.plane.constant;
      if (Math.abs(scale) < 1e-08)
        scale = 1e-08;
      this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
      this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
      this.lookAt(this.plane.normal);
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    var _axis = new Vector3();
    var _lineGeometry, _coneGeometry;
    function ArrowHelper(dir, origin, length2, color, headLength, headWidth) {
      Object3D.call(this);
      if (dir === void 0)
        dir = new Vector3(0, 0, 1);
      if (origin === void 0)
        origin = new Vector3(0, 0, 0);
      if (length2 === void 0)
        length2 = 1;
      if (color === void 0)
        color = 16776960;
      if (headLength === void 0)
        headLength = 0.2 * length2;
      if (headWidth === void 0)
        headWidth = 0.2 * headLength;
      if (_lineGeometry === void 0) {
        _lineGeometry = new BufferGeometry();
        _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
        _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
        _coneGeometry.translate(0, -0.5, 0);
      }
      this.position.copy(origin);
      this.line = new Line(_lineGeometry, new LineBasicMaterial({
        color
      }));
      this.line.matrixAutoUpdate = false;
      this.add(this.line);
      this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
        color
      }));
      this.cone.matrixAutoUpdate = false;
      this.add(this.cone);
      this.setDirection(dir);
      this.setLength(length2, headLength, headWidth);
    }
    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;
    ArrowHelper.prototype.setDirection = function(dir) {
      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        _axis.set(dir.z, 0, -dir.x).normalize();
        var radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(_axis, radians);
      }
    };
    ArrowHelper.prototype.setLength = function(length2, headLength, headWidth) {
      if (headLength === void 0)
        headLength = 0.2 * length2;
      if (headWidth === void 0)
        headWidth = 0.2 * headLength;
      this.line.scale.set(1, Math.max(0.0001, length2 - headLength), 1);
      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length2;
      this.cone.updateMatrix();
    };
    ArrowHelper.prototype.setColor = function(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    ArrowHelper.prototype.copy = function(source) {
      Object3D.prototype.copy.call(this, source, false);
      this.line.copy(source.line);
      this.cone.copy(source.cone);
      return this;
    };
    ArrowHelper.prototype.clone = function() {
      return new this.constructor().copy(this);
    };
    function AxesHelper(size) {
      size = size || 1;
      var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
      var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
      var geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      var material2 = new LineBasicMaterial({
        vertexColors: VertexColors
      });
      LineSegments.call(this, geometry, material2);
    }
    AxesHelper.prototype = Object.create(LineSegments.prototype);
    AxesHelper.prototype.constructor = AxesHelper;
    var LOD_MIN = 4;
    var LOD_MAX = 8;
    var SIZE_MAX = Math.pow(2, LOD_MAX);
    var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    var MAX_SAMPLES = 20;
    var ENCODINGS = {
      [LinearEncoding]: 0,
      [sRGBEncoding]: 1,
      [RGBEEncoding]: 2,
      [RGBM7Encoding]: 3,
      [RGBM16Encoding]: 4,
      [RGBDEncoding]: 5,
      [GammaEncoding]: 6
    };
    var _flatCamera = new OrthographicCamera();
    var _blurMaterial = _getBlurShader(MAX_SAMPLES);
    var _equirectShader = null;
    var _cubemapShader = null;
    var {_lodPlanes, _sizeLods, _sigmas} = _createPlanes();
    var _pingPongRenderTarget = null;
    var _renderer = null;
    var PHI = (1 + Math.sqrt(5)) / 2;
    var INV_PHI = 1 / PHI;
    var _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
    function PMREMGenerator(renderer) {
      _renderer = renderer;
      _compileMaterial(_blurMaterial);
    }
    PMREMGenerator.prototype = {
      constructor: PMREMGenerator,
      fromScene: function(scene, sigma = 0, near = 0.1, far = 100) {
        var cubeUVRenderTarget = _allocateTargets();
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          _blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        _applyPMREM(cubeUVRenderTarget);
        _cleanup();
        cubeUVRenderTarget.scissorTest = false;
        return cubeUVRenderTarget;
      },
      fromEquirectangular: function(equirectangular) {
        equirectangular.magFilter = NearestFilter;
        equirectangular.minFilter = NearestFilter;
        equirectangular.generateMipmaps = false;
        return this.fromCubemap(equirectangular);
      },
      fromCubemap: function(cubemap) {
        var cubeUVRenderTarget = _allocateTargets(cubemap);
        _textureToCubeUV(cubemap, cubeUVRenderTarget);
        _applyPMREM(cubeUVRenderTarget);
        _cleanup();
        cubeUVRenderTarget.scissorTest = false;
        return cubeUVRenderTarget;
      },
      compileCubemapShader: function() {
        if (_cubemapShader == null) {
          _cubemapShader = _getCubemapShader();
          _compileMaterial(_cubemapShader);
        }
      },
      compileEquirectangularShader: function() {
        if (_equirectShader == null) {
          _equirectShader = _getEquirectShader();
          _compileMaterial(_equirectShader);
        }
      },
      dispose: function() {
        _blurMaterial.dispose();
        if (_cubemapShader != null)
          _cubemapShader.dispose();
        if (_equirectShader != null)
          _equirectShader.dispose();
        for (var i3 = 0; i3 < _lodPlanes.length; i3++) {
          _lodPlanes[i3].dispose();
        }
      }
    };
    function _createPlanes() {
      var _lodPlanes2 = [];
      var _sizeLods2 = [];
      var _sigmas2 = [];
      var lod = LOD_MAX;
      for (var i3 = 0; i3 < TOTAL_LODS; i3++) {
        var sizeLod = Math.pow(2, lod);
        _sizeLods2.push(sizeLod);
        var sigma = 1 / sizeLod;
        if (i3 > LOD_MAX - LOD_MIN) {
          sigma = EXTRA_LOD_SIGMA[i3 - LOD_MAX + LOD_MIN - 1];
        } else if (i3 == 0) {
          sigma = 0;
        }
        _sigmas2.push(sigma);
        var texelSize = 1 / (sizeLod - 1);
        var min = -texelSize / 2;
        var max = 1 + texelSize / 2;
        var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
        var cubeFaces = 6;
        var vertices = 6;
        var positionSize = 3;
        var uvSize = 2;
        var faceIndexSize = 1;
        var position = new Float32Array(positionSize * vertices * cubeFaces);
        var uv = new Float32Array(uvSize * vertices * cubeFaces);
        var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for (var face = 0; face < cubeFaces; face++) {
          var x = face % 3 * 2 / 3 - 1;
          var y2 = face > 2 ? 0 : -1;
          var coordinates = [x, y2, 0, x + 2 / 3, y2, 0, x + 2 / 3, y2 + 1, 0, x, y2, 0, x + 2 / 3, y2 + 1, 0, x, y2 + 1, 0];
          position.set(coordinates, positionSize * vertices * face);
          uv.set(uv1, uvSize * vertices * face);
          var fill = [face, face, face, face, face, face];
          faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        var planes = new BufferGeometry();
        planes.setAttribute("position", new BufferAttribute(position, positionSize));
        planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
        planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
        _lodPlanes2.push(planes);
        if (lod > LOD_MIN) {
          lod--;
        }
      }
      return {
        _lodPlanes: _lodPlanes2,
        _sizeLods: _sizeLods2,
        _sigmas: _sigmas2
      };
    }
    function _allocateTargets(equirectangular) {
      var params2 = {
        magFilter: NearestFilter,
        minFilter: NearestFilter,
        generateMipmaps: false,
        type: equirectangular ? equirectangular.type : UnsignedByteType,
        format: equirectangular ? equirectangular.format : RGBEFormat,
        encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
        depthBuffer: false,
        stencilBuffer: false
      };
      var cubeUVRenderTarget = _createRenderTarget(params2);
      cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
      _pingPongRenderTarget = _createRenderTarget(params2);
      return cubeUVRenderTarget;
    }
    function _cleanup() {
      _pingPongRenderTarget.dispose();
      _renderer.setRenderTarget(null);
      var size = _renderer.getSize(new Vector2());
      _renderer.setViewport(0, 0, size.x, size.y);
    }
    function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      var fov2 = 90;
      var aspect2 = 1;
      var cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      var upSign = [1, 1, 1, 1, -1, 1];
      var forwardSign = [1, 1, -1, -1, -1, 1];
      var outputEncoding = _renderer.outputEncoding;
      var toneMapping = _renderer.toneMapping;
      var toneMappingExposure = _renderer.toneMappingExposure;
      var clearColor = _renderer.getClearColor();
      var clearAlpha = _renderer.getClearAlpha();
      _renderer.toneMapping = LinearToneMapping;
      _renderer.toneMappingExposure = 1;
      _renderer.outputEncoding = LinearEncoding;
      scene.scale.z *= -1;
      var background = scene.background;
      if (background && background.isColor) {
        background.convertSRGBToLinear();
        var maxComponent = Math.max(background.r, background.g, background.b);
        var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
        background = background.multiplyScalar(Math.pow(2, -fExp));
        var alpha = (fExp + 128) / 255;
        _renderer.setClearColor(background, alpha);
        scene.background = null;
      }
      _renderer.setRenderTarget(cubeUVRenderTarget);
      for (var i3 = 0; i3 < 6; i3++) {
        var col = i3 % 3;
        if (col == 0) {
          cubeCamera.up.set(0, upSign[i3], 0);
          cubeCamera.lookAt(forwardSign[i3], 0, 0);
        } else if (col == 1) {
          cubeCamera.up.set(0, 0, upSign[i3]);
          cubeCamera.lookAt(0, forwardSign[i3], 0);
        } else {
          cubeCamera.up.set(0, upSign[i3], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i3]);
        }
        _setViewport(col * SIZE_MAX, i3 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
        _renderer.render(scene, cubeCamera);
      }
      _renderer.toneMapping = toneMapping;
      _renderer.toneMappingExposure = toneMappingExposure;
      _renderer.outputEncoding = outputEncoding;
      _renderer.setClearColor(clearColor, clearAlpha);
      scene.scale.z *= -1;
    }
    function _textureToCubeUV(texture, cubeUVRenderTarget) {
      var scene = new Scene();
      if (texture.isCubeTexture) {
        if (_cubemapShader == null) {
          _cubemapShader = _getCubemapShader();
        }
      } else {
        if (_equirectShader == null) {
          _equirectShader = _getEquirectShader();
        }
      }
      var material2 = texture.isCubeTexture ? _cubemapShader : _equirectShader;
      scene.add(new Mesh(_lodPlanes[0], material2));
      var uniforms = material2.uniforms;
      uniforms["envMap"].value = texture;
      if (!texture.isCubeTexture) {
        uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
      }
      uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
      uniforms["outputEncoding"].value = ENCODINGS[texture.encoding];
      _renderer.setRenderTarget(cubeUVRenderTarget);
      _setViewport(0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
      _renderer.render(scene, _flatCamera);
    }
    function _compileMaterial(material2) {
      var tmpScene = new Scene();
      tmpScene.add(new Mesh(_lodPlanes[0], material2));
      _renderer.compile(tmpScene, _flatCamera);
    }
    function _createRenderTarget(params2) {
      var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params2);
      cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
      cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
      cubeUVRenderTarget.scissorTest = true;
      return cubeUVRenderTarget;
    }
    function _setViewport(x, y2, width, height) {
      var invDpr = 1 / _renderer.getPixelRatio();
      x *= invDpr;
      y2 *= invDpr;
      width *= invDpr;
      height *= invDpr;
      _renderer.setViewport(x, y2, width, height);
      _renderer.setScissor(x, y2, width, height);
    }
    function _applyPMREM(cubeUVRenderTarget) {
      var autoClear = _renderer.autoClear;
      _renderer.autoClear = false;
      for (var i3 = 1; i3 < TOTAL_LODS; i3++) {
        var sigma = Math.sqrt(_sigmas[i3] * _sigmas[i3] - _sigmas[i3 - 1] * _sigmas[i3 - 1]);
        var poleAxis = _axisDirections[(i3 - 1) % _axisDirections.length];
        _blur(cubeUVRenderTarget, i3 - 1, i3, sigma, poleAxis);
      }
      _renderer.autoClear = autoClear;
    }
    function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      _halfBlur(cubeUVRenderTarget, _pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
      _halfBlur(_pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
    }
    function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error("blur direction must be either latitudinal or longitudinal!");
      }
      var STANDARD_DEVIATIONS = 3;
      var blurScene = new Scene();
      blurScene.add(new Mesh(_lodPlanes[lodOut], _blurMaterial));
      var blurUniforms = _blurMaterial.uniforms;
      var pixels = _sizeLods[lodIn] - 1;
      var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      var sigmaPixels = sigmaRadians / radiansPerPixel;
      var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      var weights = [];
      var sum = 0;
      for (var i3 = 0; i3 < MAX_SAMPLES; ++i3) {
        var x = i3 / sigmaPixels;
        var weight = Math.exp(-x * x / 2);
        weights.push(weight);
        if (i3 == 0) {
          sum += weight;
        } else if (i3 < samples) {
          sum += 2 * weight;
        }
      }
      for (var i3 = 0; i3 < weights.length; i3++) {
        weights[i3] = weights[i3] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = LOD_MAX - lodIn;
      blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
      blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
      var outputSize = _sizeLods[lodOut];
      var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
      var y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
      _renderer.setRenderTarget(targetOut);
      _setViewport(x, y2, 3 * outputSize, 2 * outputSize);
      _renderer.render(blurScene, _flatCamera);
    }
    function _getBlurShader(maxSamples) {
      var weights = new Float32Array(maxSamples);
      var poleAxis = new Vector3(0, 1, 0);
      var shaderMaterial = new RawShaderMaterial({
        defines: {
          n: maxSamples
        },
        uniforms: {
          envMap: {
            value: null
          },
          samples: {
            value: 1
          },
          weights: {
            value: weights
          },
          latitudinal: {
            value: false
          },
          dTheta: {
            value: 0
          },
          mipInt: {
            value: 0
          },
          poleAxis: {
            value: poleAxis
          },
          inputEncoding: {
            value: ENCODINGS[LinearEncoding]
          },
          outputEncoding: {
            value: ENCODINGS[LinearEncoding]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

void main() {
	gl_FragColor = vec4(0.0);
	for (int i = 0; i < n; i++) {
		if (i >= samples)
			break;
		for (int dir = -1; dir < 2; dir += 2) {
			if (i == 0 && dir == 1)
				continue;
			vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
			if (all(equal(axis, vec3(0.0))))
				axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);
			axis = normalize(axis);
			float theta = dTheta * float(dir * i);
			float cosTheta = cos(theta);
			// Rodrigues' axis-angle rotation
			vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross(axis, vOutputDirection) * sin(theta)
					+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
			gl_FragColor.rgb +=
					weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);
		}
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      shaderMaterial.type = "SphericalGaussianBlur";
      return shaderMaterial;
    }
    function _getEquirectShader() {
      var texelSize = new Vector2(1, 1);
      var shaderMaterial = new RawShaderMaterial({
        uniforms: {
          envMap: {
            value: null
          },
          texelSize: {
            value: texelSize
          },
          inputEncoding: {
            value: ENCODINGS[LinearEncoding]
          },
          outputEncoding: {
            value: ENCODINGS[LinearEncoding]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv;
	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      shaderMaterial.type = "EquirectangularToCubeUV";
      return shaderMaterial;
    }
    function _getCubemapShader() {
      var shaderMaterial = new RawShaderMaterial({
        uniforms: {
          envMap: {
            value: null
          },
          inputEncoding: {
            value: ENCODINGS[LinearEncoding]
          },
          outputEncoding: {
            value: ENCODINGS[LinearEncoding]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
      });
      shaderMaterial.type = "CubemapToCubeUV";
      return shaderMaterial;
    }
    function _getCommonVertexShader() {
      return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx;
		direction.z *= -1.0;
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.z *= -1.0;
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.x *= -1.0;
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.y *= -1.0;
	} else if (face == 5.0) {
		direction.xz *= -1.0;
	}
	return direction;
}
void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
    }
    function _getEncodings() {
      return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
    }
    function Face4(a, b, c, d2, normal, color, materialIndex) {
      console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
      return new Face3(a, b, c, normal, color, materialIndex);
    }
    var LineStrip = 0;
    var LinePieces = 1;
    function MeshFaceMaterial(materials) {
      console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
      return materials;
    }
    function MultiMaterial(materials) {
      if (materials === void 0)
        materials = [];
      console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
      materials.isMultiMaterial = true;
      materials.materials = materials;
      materials.clone = function() {
        return materials.slice();
      };
      return materials;
    }
    function PointCloud(geometry, material2) {
      console.warn("THREE.PointCloud has been renamed to THREE.Points.");
      return new Points(geometry, material2);
    }
    function Particle(material2) {
      console.warn("THREE.Particle has been renamed to THREE.Sprite.");
      return new Sprite(material2);
    }
    function ParticleSystem(geometry, material2) {
      console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
      return new Points(geometry, material2);
    }
    function PointCloudMaterial(parameters) {
      console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
      console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
      console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial(parameters);
    }
    function Vertex(x, y2, z) {
      console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
      return new Vector3(x, y2, z);
    }
    function DynamicBufferAttribute(array, itemSize) {
      console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
      return new BufferAttribute(array, itemSize).setDynamic(true);
    }
    function Int8Attribute(array, itemSize) {
      console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
      return new Int8BufferAttribute(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
      console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
      return new Uint8BufferAttribute(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
      console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
      return new Uint8ClampedBufferAttribute(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
      console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
      return new Int16BufferAttribute(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
      console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
      return new Uint16BufferAttribute(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
      console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
      return new Int32BufferAttribute(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
      console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
      return new Uint32BufferAttribute(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
      console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
      return new Float32BufferAttribute(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
      console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
      return new Float64BufferAttribute(array, itemSize);
    }
    Curve.create = function(construct, getPoint) {
      console.log("THREE.Curve.create() has been deprecated");
      construct.prototype = Object.create(Curve.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;
      return construct;
    };
    Object.assign(CurvePath.prototype, {
      createPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var pts = this.getPoints(divisions);
        return this.createGeometry(pts);
      },
      createSpacedPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
      },
      createGeometry: function(points) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var geometry = new Geometry();
        for (var i3 = 0, l = points.length; i3 < l; i3++) {
          var point = points[i3];
          geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
      }
    });
    Object.assign(Path.prototype, {
      fromPoints: function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      }
    });
    function ClosedSplineCurve3(points) {
      console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
      CatmullRomCurve3.call(this, points);
      this.type = "catmullrom";
      this.closed = true;
    }
    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
    function SplineCurve3(points) {
      console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
      CatmullRomCurve3.call(this, points);
      this.type = "catmullrom";
    }
    SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
    function Spline(points) {
      console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
      CatmullRomCurve3.call(this, points);
      this.type = "catmullrom";
    }
    Spline.prototype = Object.create(CatmullRomCurve3.prototype);
    Object.assign(Spline.prototype, {
      initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      },
      getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
      },
      reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
      }
    });
    function AxisHelper(size) {
      console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
      return new AxesHelper(size);
    }
    function BoundingBoxHelper(object, color) {
      console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
      return new BoxHelper(object, color);
    }
    function EdgesHelper(object, hex) {
      console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
      return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== void 0 ? hex : 16777215
      }));
    }
    GridHelper.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    };
    SkeletonHelper.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    };
    function WireframeHelper(object, hex) {
      console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
      return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== void 0 ? hex : 16777215
      }));
    }
    Object.assign(Loader.prototype, {
      extractUrlBase: function(url2) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url2);
      }
    });
    Loader.Handlers = {
      add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      },
      get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      }
    };
    function XHRLoader(manager2) {
      console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
      return new FileLoader(manager2);
    }
    function BinaryTextureLoader(manager2) {
      console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
      return new DataTextureLoader(manager2);
    }
    Object.assign(ObjectLoader.prototype, {
      setTexturePath: function(value2) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value2);
      }
    });
    Object.assign(Box2.prototype, {
      center: function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      },
      empty: function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      },
      isIntersectionBox: function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      size: function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      }
    });
    Object.assign(Box3.prototype, {
      center: function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      },
      empty: function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      },
      isIntersectionBox: function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      isIntersectionSphere: function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      },
      size: function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      }
    });
    Line3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Object.assign(_Math, {
      random16: function() {
        console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
        return Math.random();
      },
      nearestPowerOfTwo: function(value2) {
        console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
        return _Math.floorPowerOfTwo(value2);
      },
      nextPowerOfTwo: function(value2) {
        console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
        return _Math.ceilPowerOfTwo(value2);
      }
    });
    Object.assign(Matrix3.prototype, {
      flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      },
      multiplyVector3: function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      },
      applyToBuffer: function(buffer) {
        console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(buffer);
      },
      applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      }
    });
    Object.assign(Matrix4.prototype, {
      extractPosition: function(m2) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m2);
      },
      flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      },
      getPosition: function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
      },
      setRotationFromQuaternion: function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      },
      multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      },
      multiplyVector3: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      multiplyVector4: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      },
      rotateAxis: function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      },
      translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      },
      rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      },
      rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      },
      rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      },
      rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      },
      applyToBuffer: function(buffer) {
        console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(buffer);
      },
      applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      },
      makeFrustum: function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      }
    });
    Plane.prototype.isIntersectionLine = function(line) {
      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
      return this.intersectsLine(line);
    };
    Quaternion.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    };
    Object.assign(Ray.prototype, {
      isIntersectionBox: function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      },
      isIntersectionPlane: function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      },
      isIntersectionSphere: function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      }
    });
    Object.assign(Triangle.prototype, {
      area: function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      },
      barycoordFromPoint: function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      },
      midpoint: function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      },
      normal: function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      },
      plane: function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      }
    });
    Object.assign(Triangle, {
      barycoordFromPoint: function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
      },
      normal: function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
      }
    });
    Object.assign(Shape.prototype, {
      extractAllPoints: function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      },
      extrude: function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
      },
      makeGeometry: function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
      }
    });
    Object.assign(Vector2.prototype, {
      fromAttribute: function(attribute, index2, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      },
      distanceToManhattan: function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Vector3.prototype, {
      setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      },
      setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      },
      getPositionFromMatrix: function(m2) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m2);
      },
      getScaleFromMatrix: function(m2) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m2);
      },
      getColumnFromMatrix: function(index2, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index2);
      },
      applyProjection: function(m2) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m2);
      },
      fromAttribute: function(attribute, index2, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      },
      distanceToManhattan: function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Vector4.prototype, {
      fromAttribute: function(attribute, index2, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      },
      lengthManhattan: function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      }
    });
    Object.assign(Geometry.prototype, {
      computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      },
      computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
      }
    });
    Object.assign(Object3D.prototype, {
      getChildByName: function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      },
      renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      },
      translate: function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      },
      getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      }
    });
    Object.defineProperties(Object3D.prototype, {
      eulerOrder: {
        get: function() {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          return this.rotation.order;
        },
        set: function(value2) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          this.rotation.order = value2;
        }
      },
      useQuaternion: {
        get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
      }
    });
    Object.assign(Mesh.prototype, {
      setDrawMode: function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    });
    Object.defineProperties(Mesh.prototype, {
      drawMode: {
        get: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
          return TrianglesDrawMode;
        },
        set: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
      }
    });
    Object.defineProperties(LOD.prototype, {
      objects: {
        get: function() {
          console.warn("THREE.LOD: .objects has been renamed to .levels.");
          return this.levels;
        }
      }
    });
    Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
      get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
      set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      }
    });
    SkinnedMesh.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    };
    Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
      get: function() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions;
      },
      set: function(value2) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = value2;
      }
    });
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
      if (filmGauge !== void 0)
        this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light.prototype, {
      onlyShadow: {
        set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        }
      },
      shadowCameraFov: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
          this.shadow.camera.fov = value2;
        }
      },
      shadowCameraLeft: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
          this.shadow.camera.left = value2;
        }
      },
      shadowCameraRight: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
          this.shadow.camera.right = value2;
        }
      },
      shadowCameraTop: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
          this.shadow.camera.top = value2;
        }
      },
      shadowCameraBottom: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
          this.shadow.camera.bottom = value2;
        }
      },
      shadowCameraNear: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
          this.shadow.camera.near = value2;
        }
      },
      shadowCameraFar: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
          this.shadow.camera.far = value2;
        }
      },
      shadowCameraVisible: {
        set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
      },
      shadowBias: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
          this.shadow.bias = value2;
        }
      },
      shadowDarkness: {
        set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
      },
      shadowMapWidth: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
          this.shadow.mapSize.width = value2;
        }
      },
      shadowMapHeight: {
        set: function(value2) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
          this.shadow.mapSize.height = value2;
        }
      }
    });
    Object.defineProperties(BufferAttribute.prototype, {
      length: {
        get: function() {
          console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
          return this.array.length;
        }
      },
      dynamic: {
        get: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          this.setUsage(DynamicDrawUsage);
        }
      }
    });
    Object.assign(BufferAttribute.prototype, {
      setDynamic: function(value2) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value2 === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      },
      copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      },
      setArray: function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }
    });
    Object.assign(BufferGeometry.prototype, {
      addIndex: function(index2) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index2);
      },
      addAttribute: function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      },
      addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      },
      clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      },
      computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
      },
      computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      },
      removeAttribute: function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      }
    });
    Object.defineProperties(BufferGeometry.prototype, {
      drawcalls: {
        get: function() {
          console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
          return this.groups;
        }
      },
      offsets: {
        get: function() {
          console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
          return this.groups;
        }
      }
    });
    Object.defineProperties(InterleavedBuffer.prototype, {
      dynamic: {
        get: function() {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function(value2) {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          this.setUsage(value2);
        }
      }
    });
    Object.assign(InterleavedBuffer.prototype, {
      setDynamic: function(value2) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value2 === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      },
      setArray: function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }
    });
    Object.assign(ExtrudeBufferGeometry.prototype, {
      getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
      },
      addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
      },
      addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
      }
    });
    Object.defineProperties(Uniform.prototype, {
      dynamic: {
        set: function() {
          console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        }
      },
      onUpdate: {
        value: function() {
          console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
          return this;
        }
      }
    });
    Object.defineProperties(Material.prototype, {
      wrapAround: {
        get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }
      },
      overdraw: {
        get: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }
      },
      wrapRGB: {
        get: function() {
          console.warn("THREE.Material: .wrapRGB has been removed.");
          return new Color();
        }
      },
      shading: {
        get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value2) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = value2 === FlatShading;
        }
      },
      stencilMask: {
        get: function() {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          return this.stencilFuncMask;
        },
        set: function(value2) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          this.stencilFuncMask = value2;
        }
      }
    });
    Object.defineProperties(MeshPhongMaterial.prototype, {
      metal: {
        get: function() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
      }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
      derivatives: {
        get: function() {
          console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          return this.extensions.derivatives;
        },
        set: function(value2) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          this.extensions.derivatives = value2;
        }
      }
    });
    Object.assign(WebGLRenderer.prototype, {
      clearTarget: function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      },
      animate: function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      },
      getCurrentRenderTarget: function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      },
      getMaxAnisotropy: function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      },
      getPrecision: function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      },
      resetGLState: function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      },
      supportsFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      },
      supportsHalfFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      },
      supportsStandardDerivatives: function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      },
      supportsCompressedTextureS3TC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      },
      supportsCompressedTexturePVRTC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      },
      supportsBlendMinMax: function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      },
      supportsVertexTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      },
      supportsInstancedArrays: function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      },
      enableScissorTest: function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      },
      initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      },
      addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      },
      addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      },
      updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      },
      setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      },
      allocTextureUnit: function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      },
      setTexture: function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      },
      setTexture2D: function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      },
      setTextureCube: function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      },
      getActiveMipMapLevel: function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      }
    });
    Object.defineProperties(WebGLRenderer.prototype, {
      shadowMapEnabled: {
        get: function() {
          return this.shadowMap.enabled;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
          this.shadowMap.enabled = value2;
        }
      },
      shadowMapType: {
        get: function() {
          return this.shadowMap.type;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
          this.shadowMap.type = value2;
        }
      },
      shadowMapCullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      context: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
          return this.getContext();
        }
      },
      vr: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
          return this.xr;
        }
      },
      gammaInput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
      },
      gammaOutput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          return false;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          this.outputEncoding = value2 === true ? sRGBEncoding : LinearEncoding;
        }
      }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
      cullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      renderReverseSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
      },
      renderSingleSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
      }
    });
    Object.defineProperties(WebGLRenderTargetCube.prototype, {
      activeCubeFace: {
        set: function() {
          console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().");
        }
      },
      activeMipMapLevel: {
        set: function() {
          console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().");
        }
      }
    });
    Object.defineProperties(WebGLRenderTarget.prototype, {
      wrapS: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          return this.texture.wrapS;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          this.texture.wrapS = value2;
        }
      },
      wrapT: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          return this.texture.wrapT;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          this.texture.wrapT = value2;
        }
      },
      magFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          return this.texture.magFilter;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          this.texture.magFilter = value2;
        }
      },
      minFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          return this.texture.minFilter;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          this.texture.minFilter = value2;
        }
      },
      anisotropy: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          return this.texture.anisotropy;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          this.texture.anisotropy = value2;
        }
      },
      offset: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          return this.texture.offset;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          this.texture.offset = value2;
        }
      },
      repeat: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          return this.texture.repeat;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          this.texture.repeat = value2;
        }
      },
      format: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          return this.texture.format;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          this.texture.format = value2;
        }
      },
      type: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          return this.texture.type;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          this.texture.type = value2;
        }
      },
      generateMipmaps: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          return this.texture.generateMipmaps;
        },
        set: function(value2) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          this.texture.generateMipmaps = value2;
        }
      }
    });
    Object.defineProperties(Audio.prototype, {
      load: {
        value: function(file2) {
          console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
          var scope = this;
          var audioLoader = new AudioLoader();
          audioLoader.load(file2, function(buffer) {
            scope.setBuffer(buffer);
          });
          return this;
        }
      },
      startTime: {
        set: function() {
          console.warn("THREE.Audio: .startTime is now .play( delay ).");
        }
      }
    });
    AudioAnalyser.prototype.getData = function() {
      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
      return this.getFrequencyData();
    };
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
      return this.update(renderer, scene);
    };
    var GeometryUtils = {
      merge: function(geometry1, geometry2, materialIndexOffset) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var matrix;
        if (geometry2.isMesh) {
          geometry2.matrixAutoUpdate && geometry2.updateMatrix();
          matrix = geometry2.matrix;
          geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
      },
      center: function(geometry) {
        console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
        return geometry.center();
      }
    };
    ImageUtils.crossOrigin = void 0;
    ImageUtils.loadTexture = function(url2, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      var loader = new TextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(url2, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      var loader = new CubeTextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(urls, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    function CanvasRenderer() {
      console.error("THREE.CanvasRenderer has been removed");
    }
    function JSONLoader() {
      console.error("THREE.JSONLoader has been removed.");
    }
    var SceneUtils = {
      createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      },
      detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      },
      attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      }
    };
    function LensFlare() {
      console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
    }
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: REVISION
        }
      }));
    }

    // node_modules/three/examples/jsm/controls/OrbitControls.js
    var OrbitControls2 = function(object, domElement) {
      if (domElement === void 0)
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
      if (domElement === document)
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      this.object = object;
      this.domElement = domElement;
      this.enabled = true;
      this.target = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = false;
      this.keyPanSpeed = 7;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.enableKeys = true;
      this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
      };
      this.mouseButtons = {
        LEFT: MOUSE.ROTATE,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.PAN
      };
      this.touches = {
        ONE: TOUCH.ROTATE,
        TWO: TOUCH.DOLLY_PAN
      };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);
        scope.update();
        state = STATE.NONE;
      };
      this.update = function() {
        var offset = new Vector3();
        var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        var quatInverse = quat.clone().inverse();
        var lastPosition = new Vector3();
        var lastQuaternion = new Quaternion();
        return function update2() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, false);
        scope.domElement.removeEventListener("mousedown", onMouseDown, false);
        scope.domElement.removeEventListener("wheel", onMouseWheel, false);
        scope.domElement.removeEventListener("touchstart", onTouchStart, false);
        scope.domElement.removeEventListener("touchend", onTouchEnd, false);
        scope.domElement.removeEventListener("touchmove", onTouchMove, false);
        document.removeEventListener("mousemove", onMouseMove, false);
        document.removeEventListener("mouseup", onMouseUp, false);
        scope.domElement.removeEventListener("keydown", onKeyDown, false);
      };
      var scope = this;
      var changeEvent = {
        type: "change"
      };
      var startEvent = {
        type: "start"
      };
      var endEvent = {
        type: "end"
      };
      var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      var state = STATE.NONE;
      var EPS = 1e-06;
      var spherical = new Spherical();
      var sphericalDelta = new Spherical();
      var scale = 1;
      var panOffset = new Vector3();
      var zoomChanged = false;
      var rotateStart = new Vector2();
      var rotateEnd = new Vector2();
      var rotateDelta = new Vector2();
      var panStart = new Vector2();
      var panEnd = new Vector2();
      var panDelta = new Vector2();
      var dollyStart = new Vector2();
      var dollyEnd = new Vector2();
      var dollyDelta = new Vector2();
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      var panLeft = function() {
        var v = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.multiplyScalar(-distance);
          panOffset.add(v);
        };
      }();
      var panUp = function() {
        var v = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.crossVectors(scope.object.up, v);
          }
          v.multiplyScalar(distance);
          panOffset.add(v);
        };
      }();
      var pan = function() {
        var offset = new Vector3();
        return function pan2(deltaX, deltaY) {
          var element2 = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            var targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element2.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element2.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element2.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element2.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function handleMouseDownRotate(event2) {
        rotateStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseDownDolly(event2) {
        dollyStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseDownPan(event2) {
        panStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseMoveRotate(event2) {
        rotateEnd.set(event2.clientX, event2.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element2 = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event2) {
        dollyEnd.set(event2.clientX, event2.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyIn(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyOut(getZoomScale());
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event2) {
        panEnd.set(event2.clientX, event2.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseUp() {
      }
      function handleMouseWheel(event2) {
        if (event2.deltaY < 0) {
          dollyOut(getZoomScale());
        } else if (event2.deltaY > 0) {
          dollyIn(getZoomScale());
        }
        scope.update();
      }
      function handleKeyDown(event2) {
        var needsUpdate = false;
        switch (event2.keyCode) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event2.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate(event2) {
        if (event2.touches.length == 1) {
          rotateStart.set(event2.touches[0].pageX, event2.touches[0].pageY);
        } else {
          var x = 0.5 * (event2.touches[0].pageX + event2.touches[1].pageX);
          var y2 = 0.5 * (event2.touches[0].pageY + event2.touches[1].pageY);
          rotateStart.set(x, y2);
        }
      }
      function handleTouchStartPan(event2) {
        if (event2.touches.length == 1) {
          panStart.set(event2.touches[0].pageX, event2.touches[0].pageY);
        } else {
          var x = 0.5 * (event2.touches[0].pageX + event2.touches[1].pageX);
          var y2 = 0.5 * (event2.touches[0].pageY + event2.touches[1].pageY);
          panStart.set(x, y2);
        }
      }
      function handleTouchStartDolly(event2) {
        var dx = event2.touches[0].pageX - event2.touches[1].pageX;
        var dy = event2.touches[0].pageY - event2.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan(event2) {
        if (scope.enableZoom)
          handleTouchStartDolly(event2);
        if (scope.enablePan)
          handleTouchStartPan(event2);
      }
      function handleTouchStartDollyRotate(event2) {
        if (scope.enableZoom)
          handleTouchStartDolly(event2);
        if (scope.enableRotate)
          handleTouchStartRotate(event2);
      }
      function handleTouchMoveRotate(event2) {
        if (event2.touches.length == 1) {
          rotateEnd.set(event2.touches[0].pageX, event2.touches[0].pageY);
        } else {
          var x = 0.5 * (event2.touches[0].pageX + event2.touches[1].pageX);
          var y2 = 0.5 * (event2.touches[0].pageY + event2.touches[1].pageY);
          rotateEnd.set(x, y2);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element2 = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event2) {
        if (event2.touches.length == 1) {
          panEnd.set(event2.touches[0].pageX, event2.touches[0].pageY);
        } else {
          var x = 0.5 * (event2.touches[0].pageX + event2.touches[1].pageX);
          var y2 = 0.5 * (event2.touches[0].pageY + event2.touches[1].pageY);
          panEnd.set(x, y2);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event2) {
        var dx = event2.touches[0].pageX - event2.touches[1].pageX;
        var dy = event2.touches[0].pageY - event2.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyIn(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }
      function handleTouchMoveDollyPan(event2) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event2);
        if (scope.enablePan)
          handleTouchMovePan(event2);
      }
      function handleTouchMoveDollyRotate(event2) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event2);
        if (scope.enableRotate)
          handleTouchMoveRotate(event2);
      }
      function handleTouchEnd() {
      }
      function onMouseDown(event2) {
        if (scope.enabled === false)
          return;
        event2.preventDefault();
        scope.domElement.focus ? scope.domElement.focus() : window.focus();
        switch (event2.button) {
          case 0:
            switch (scope.mouseButtons.LEFT) {
              case MOUSE.ROTATE:
                if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
                  if (scope.enablePan === false)
                    return;
                  handleMouseDownPan(event2);
                  state = STATE.PAN;
                } else {
                  if (scope.enableRotate === false)
                    return;
                  handleMouseDownRotate(event2);
                  state = STATE.ROTATE;
                }
                break;
              case MOUSE.PAN:
                if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
                  if (scope.enableRotate === false)
                    return;
                  handleMouseDownRotate(event2);
                  state = STATE.ROTATE;
                } else {
                  if (scope.enablePan === false)
                    return;
                  handleMouseDownPan(event2);
                  state = STATE.PAN;
                }
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 1:
            switch (scope.mouseButtons.MIDDLE) {
              case MOUSE.DOLLY:
                if (scope.enableZoom === false)
                  return;
                handleMouseDownDolly(event2);
                state = STATE.DOLLY;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.mouseButtons.RIGHT) {
              case MOUSE.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleMouseDownRotate(event2);
                state = STATE.ROTATE;
                break;
              case MOUSE.PAN:
                if (scope.enablePan === false)
                  return;
                handleMouseDownPan(event2);
                state = STATE.PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
        }
        if (state !== STATE.NONE) {
          document.addEventListener("mousemove", onMouseMove, false);
          document.addEventListener("mouseup", onMouseUp, false);
          scope.dispatchEvent(startEvent);
        }
      }
      function onMouseMove(event2) {
        if (scope.enabled === false)
          return;
        event2.preventDefault();
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleMouseMoveRotate(event2);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseMoveDolly(event2);
            break;
          case STATE.PAN:
            if (scope.enablePan === false)
              return;
            handleMouseMovePan(event2);
            break;
        }
      }
      function onMouseUp(event2) {
        if (scope.enabled === false)
          return;
        handleMouseUp(event2);
        document.removeEventListener("mousemove", onMouseMove, false);
        document.removeEventListener("mouseup", onMouseUp, false);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onMouseWheel(event2) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
          return;
        event2.preventDefault();
        event2.stopPropagation();
        scope.dispatchEvent(startEvent);
        handleMouseWheel(event2);
        scope.dispatchEvent(endEvent);
      }
      function onKeyDown(event2) {
        if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false)
          return;
        handleKeyDown(event2);
      }
      function onTouchStart(event2) {
        if (scope.enabled === false)
          return;
        event2.preventDefault();
        switch (event2.touches.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchStartRotate(event2);
                state = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchStartPan(event2);
                state = STATE.TOUCH_PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchStartDollyPan(event2);
                state = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchStartDollyRotate(event2);
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(startEvent);
        }
      }
      function onTouchMove(event2) {
        if (scope.enabled === false)
          return;
        event2.preventDefault();
        event2.stopPropagation();
        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchMoveRotate(event2);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false)
              return;
            handleTouchMovePan(event2);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchMoveDollyPan(event2);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchMoveDollyRotate(event2);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function onTouchEnd(event2) {
        if (scope.enabled === false)
          return;
        handleTouchEnd(event2);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onContextMenu(event2) {
        if (scope.enabled === false)
          return;
        event2.preventDefault();
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu, false);
      scope.domElement.addEventListener("mousedown", onMouseDown, false);
      scope.domElement.addEventListener("wheel", onMouseWheel, false);
      scope.domElement.addEventListener("touchstart", onTouchStart, false);
      scope.domElement.addEventListener("touchend", onTouchEnd, false);
      scope.domElement.addEventListener("touchmove", onTouchMove, false);
      scope.domElement.addEventListener("keydown", onKeyDown, false);
      if (scope.domElement.tabIndex === -1) {
        scope.domElement.tabIndex = 0;
      }
      this.update();
    };
    OrbitControls2.prototype = Object.create(EventDispatcher.prototype);
    OrbitControls2.prototype.constructor = OrbitControls2;
    var MapControls = function(object, domElement) {
      OrbitControls2.call(this, object, domElement);
      this.mouseButtons.LEFT = MOUSE.PAN;
      this.mouseButtons.RIGHT = MOUSE.ROTATE;
      this.touches.ONE = TOUCH.PAN;
      this.touches.TWO = TOUCH.DOLLY_ROTATE;
    };
    MapControls.prototype = Object.create(EventDispatcher.prototype);
    MapControls.prototype.constructor = MapControls;

    // public/stages/Tampa.js
    function Tampa2({props, renderer}) {
      let scene = new THREE.Scene();
      scene.position.y = -default5.height * 0.5;
      let camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
      camera.position.set(0, 3, 4);
      camera.lookAt(new THREE.Vector3());
      let shape = default7();
      scene.add(shape.transform);
      const lights = default9();
      scene.add(lights.transform);
      const room = default5();
      scene.add(room.transform);
      const hole = default6();
      scene.add(hole.transform);
      const ceiling = default8();
      scene.add(ceiling.transform);
      const floor = default4();
      scene.add(floor.transform);
      const particles = default10();
      scene.add(particles.transform);
      const controls = new OrbitControls2(camera, document.querySelector(".output"));
      props.roomDiffuse.onChange = ({value: value2}) => {
        default11.get("roomDiffuse").value = new THREE.Color(props.roomDiffuse.value);
      };
      function update2({time: time2, deltaTime: deltaTime2}) {
        default11.update({
          time: time2,
          deltaTime: deltaTime2
        });
        controls.update();
      }
      function render({renderer: renderer2}) {
        renderer2.setClearColor("#000", 1);
        renderer2.render(scene, camera);
      }
      function resize() {
      }
      return {
        canvas: renderer.canvas,
        update: update2,
        render,
        resize
      };
    }
    const default12 = {
      name: "Tampa",
      scene: Tampa2,
      props: {
        roomDiffuse: {
          type: "color",
          value: "#ff0000"
        }
      }
    };

    // public/stages/Cubes.js
    function Cubes2({props, renderer}) {
      let scene, camera, mesh;
      function init3() {
        camera = new THREE.PerspectiveCamera(45, renderer.dimensions.width / renderer.dimensions.height, 1, 1000);
        camera.position.z = 5;
        camera.lookAt(new THREE.Vector3());
        scene = new THREE.Scene();
        scene.background = new THREE.Color(65280);
        let geometry = new THREE.BoxGeometry(2, 2, 2);
        let material2 = new THREE.MeshBasicMaterial({
          color: 65280,
          map: new THREE.Texture()
        });
        mesh = new THREE.Mesh(geometry, material2);
        scene.add(mesh);
        props.texture.onChange = ({image}) => {
          material2.map.image = image;
          material2.map.needsUpdate = true;
        };
      }
      function update2() {
        if (props.move.value) {
          mesh.rotation.x += 0.01 * props.speed.value;
          mesh.rotation.y += 0.01 * props.speed.value;
          mesh.rotation.z += 0.01 * props.speed.value;
        }
        if (props.texture.needsUpdate) {
          material.map.needsUpdate = true;
        }
      }
      function render({renderer: renderer2}) {
        renderer2.render(scene, camera);
      }
      function resize({width, height}) {
      }
      init3();
      return {
        canvas: renderer.canvas,
        update: update2,
        render,
        resize
      };
    }
    const default3 = {
      name: "Cubes",
      scene: Cubes2,
      props: {
        speed: {
          min: 0,
          max: 20,
          value: 1,
          triggers: []
        },
        move: {
          value: true,
          triggers: []
        },
        texture: {
          type: "image",
          value: "assets/images/render.png"
        }
      }
    };

    // public/stages/index.js
    var exports = {};
    require(exports, {
      Cubes: () => default3,
      Tampa: () => default12
    });

    // public/index.js
    function init2() {
      default2({
        renderer: THREERenderer(window.THREE, {
          width: 1280 * 1,
          height: 720 * 1,
          dpr: 1
        }),
        stages: exports
      });
    }
    if (document.body) {
      init2();
    } else {
      window.addEventListener("DOMContentLoaded", () => {
        init2();
      });
    }
  },

  2(require, exports, module) {
    // node_modules/seed-random/index.js
    "use strict";
    var width = 256;
    var chunks = 6;
    var digits = 52;
    var pool = [];
    var GLOBAL = typeof global === "undefined" ? window : global;
    var startdenom = Math.pow(width, chunks), significance = Math.pow(2, digits), overflow = significance * 2, mask = width - 1;
    var oldRandom = Math.random;
    module.exports = function(seed, options) {
      if (options && options.global === true) {
        options.global = false;
        Math.random = module.exports(seed, options);
        options.global = true;
        return Math.random;
      }
      var use_entropy = options && options.entropy || false;
      var key = [];
      var shortseed = mixkey(flatten(use_entropy ? [seed, tostring(pool)] : 0 in arguments ? seed : autoseed(), 3), key);
      var arc4 = new ARC4(key);
      mixkey(tostring(arc4.S), pool);
      return function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
    };
    module.exports.resetGlobal = function() {
      Math.random = oldRandom;
    };
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
        while (count--) {
          t2 = s2[i2 = mask & i2 + 1];
          r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i2;
        me.j = j2;
        return r;
      })(width);
    }
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj)[0], prop;
      if (depth && typ == "o") {
        for (prop in obj) {
          try {
            result.push(flatten(obj[prop], depth - 1));
          } catch (e) {
          }
        }
      }
      return result.length ? result : typ == "s" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed(seed) {
      try {
        GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));
        return tostring(seed);
      } catch (e) {
        return [+new Date(), GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins, GLOBAL.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(Math.random(), pool);
  },

  3(require, exports, module) {
    // node_modules/simplex-noise/simplex-noise.js
    (function() {
      "use strict";
      var F2 = 0.5 * (Math.sqrt(3) - 1);
      var G2 = (3 - Math.sqrt(3)) / 6;
      var F3 = 1 / 3;
      var G3 = 1 / 6;
      var F4 = (Math.sqrt(5) - 1) / 4;
      var G4 = (5 - Math.sqrt(5)) / 20;
      function SimplexNoise(randomOrSeed) {
        var random;
        if (typeof randomOrSeed == "function") {
          random = randomOrSeed;
        } else if (randomOrSeed) {
          random = alea(randomOrSeed);
        } else {
          random = Math.random;
        }
        this.p = buildPermutationTable(random);
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (var i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
      }
      SimplexNoise.prototype = {
        grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
        grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
        noise2D: function(xin, yin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0 = 0;
          var n1 = 0;
          var n2 = 0;
          var s = (xin + yin) * F2;
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var t = (i + j) * G2;
          var X0 = i - t;
          var Y0 = j - t;
          var x0 = xin - X0;
          var y0 = yin - Y0;
          var i1, j1;
          if (x0 > y0) {
            i1 = 1;
            j1 = 0;
          } else {
            i1 = 0;
            j1 = 1;
          }
          var x1 = x0 - i1 + G2;
          var y1 = y0 - j1 + G2;
          var x2 = x0 - 1 + 2 * G2;
          var y2 = y0 - 1 + 2 * G2;
          var ii = i & 255;
          var jj = j & 255;
          var t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) {
            var gi0 = permMod12[ii + perm[jj]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);
          }
          var t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) {
            var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
          }
          var t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) {
            var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
          }
          return 70 * (n0 + n1 + n2);
        },
        noise3D: function(xin, yin, zin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0, n1, n2, n3;
          var s = (xin + yin + zin) * F3;
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var k = Math.floor(zin + s);
          var t = (i + j + k) * G3;
          var X0 = i - t;
          var Y0 = j - t;
          var Z0 = k - t;
          var x0 = xin - X0;
          var y0 = yin - Y0;
          var z0 = zin - Z0;
          var i1, j1, k1;
          var i2, j2, k2;
          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            }
          } else {
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            }
          }
          var x1 = x0 - i1 + G3;
          var y1 = y0 - j1 + G3;
          var z1 = z0 - k1 + G3;
          var x2 = x0 - i2 + 2 * G3;
          var y2 = y0 - j2 + 2 * G3;
          var z2 = z0 - k2 + 2 * G3;
          var x3 = x0 - 1 + 3 * G3;
          var y3 = y0 - 1 + 3 * G3;
          var z3 = z0 - 1 + 3 * G3;
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 < 0)
            n0 = 0;
          else {
            var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 < 0)
            n1 = 0;
          else {
            var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 < 0)
            n2 = 0;
          else {
            var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 < 0)
            n3 = 0;
          else {
            var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
            t3 *= t3;
            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
          }
          return 32 * (n0 + n1 + n2 + n3);
        },
        noise4D: function(x, y, z, w) {
          var perm = this.perm;
          var grad4 = this.grad4;
          var n0, n1, n2, n3, n4;
          var s = (x + y + z + w) * F4;
          var i = Math.floor(x + s);
          var j = Math.floor(y + s);
          var k = Math.floor(z + s);
          var l = Math.floor(w + s);
          var t = (i + j + k + l) * G4;
          var X0 = i - t;
          var Y0 = j - t;
          var Z0 = k - t;
          var W0 = l - t;
          var x0 = x - X0;
          var y0 = y - Y0;
          var z0 = z - Z0;
          var w0 = w - W0;
          var rankx = 0;
          var ranky = 0;
          var rankz = 0;
          var rankw = 0;
          if (x0 > y0)
            rankx++;
          else
            ranky++;
          if (x0 > z0)
            rankx++;
          else
            rankz++;
          if (x0 > w0)
            rankx++;
          else
            rankw++;
          if (y0 > z0)
            ranky++;
          else
            rankz++;
          if (y0 > w0)
            ranky++;
          else
            rankw++;
          if (z0 > w0)
            rankz++;
          else
            rankw++;
          var i1, j1, k1, l1;
          var i2, j2, k2, l2;
          var i3, j3, k3, l3;
          i1 = rankx >= 3 ? 1 : 0;
          j1 = ranky >= 3 ? 1 : 0;
          k1 = rankz >= 3 ? 1 : 0;
          l1 = rankw >= 3 ? 1 : 0;
          i2 = rankx >= 2 ? 1 : 0;
          j2 = ranky >= 2 ? 1 : 0;
          k2 = rankz >= 2 ? 1 : 0;
          l2 = rankw >= 2 ? 1 : 0;
          i3 = rankx >= 1 ? 1 : 0;
          j3 = ranky >= 1 ? 1 : 0;
          k3 = rankz >= 1 ? 1 : 0;
          l3 = rankw >= 1 ? 1 : 0;
          var x1 = x0 - i1 + G4;
          var y1 = y0 - j1 + G4;
          var z1 = z0 - k1 + G4;
          var w1 = w0 - l1 + G4;
          var x2 = x0 - i2 + 2 * G4;
          var y2 = y0 - j2 + 2 * G4;
          var z2 = z0 - k2 + 2 * G4;
          var w2 = w0 - l2 + 2 * G4;
          var x3 = x0 - i3 + 3 * G4;
          var y3 = y0 - j3 + 3 * G4;
          var z3 = z0 - k3 + 3 * G4;
          var w3 = w0 - l3 + 3 * G4;
          var x4 = x0 - 1 + 4 * G4;
          var y4 = y0 - 1 + 4 * G4;
          var z4 = z0 - 1 + 4 * G4;
          var w4 = w0 - 1 + 4 * G4;
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          var ll = l & 255;
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
          if (t0 < 0)
            n0 = 0;
          else {
            var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32 * 4;
            t0 *= t0;
            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
          if (t1 < 0)
            n1 = 0;
          else {
            var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32 * 4;
            t1 *= t1;
            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
          if (t2 < 0)
            n2 = 0;
          else {
            var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32 * 4;
            t2 *= t2;
            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
          if (t3 < 0)
            n3 = 0;
          else {
            var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32 * 4;
            t3 *= t3;
            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
          }
          var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
          if (t4 < 0)
            n4 = 0;
          else {
            var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32 * 4;
            t4 *= t4;
            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
          }
          return 27 * (n0 + n1 + n2 + n3 + n4);
        }
      };
      function buildPermutationTable(random) {
        var i;
        var p = new Uint8Array(256);
        for (i = 0; i < 256; i++) {
          p[i] = i;
        }
        for (i = 0; i < 255; i++) {
          var r = i + ~~(random() * (256 - i));
          var aux = p[i];
          p[i] = p[r];
          p[r] = aux;
        }
        return p;
      }
      SimplexNoise._buildPermutationTable = buildPermutationTable;
      function alea() {
        var s0 = 0;
        var s1 = 0;
        var s2 = 0;
        var c = 1;
        var mash = masher();
        s0 = mash(" ");
        s1 = mash(" ");
        s2 = mash(" ");
        for (var i = 0; i < arguments.length; i++) {
          s0 -= mash(arguments[i]);
          if (s0 < 0) {
            s0 += 1;
          }
          s1 -= mash(arguments[i]);
          if (s1 < 0) {
            s1 += 1;
          }
          s2 -= mash(arguments[i]);
          if (s2 < 0) {
            s2 += 1;
          }
        }
        mash = null;
        return function() {
          var t = 2091639 * s0 + c * 2.3283064365386963e-10;
          s0 = s1;
          s1 = s2;
          return s2 = t - (c = t | 0);
        };
      }
      function masher() {
        var n = 4022871197;
        return function(data) {
          data = data.toString();
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4.294967296e+09;
          }
          return (n >>> 0) * 2.3283064365386963e-10;
        };
      }
      if (typeof define !== "undefined" && define.amd)
        define(function() {
          return SimplexNoise;
        });
      if (typeof exports !== "undefined")
        exports.SimplexNoise = SimplexNoise;
      else if (typeof window !== "undefined")
        window.SimplexNoise = SimplexNoise;
      if (typeof module !== "undefined") {
        module.exports = SimplexNoise;
      }
    })();
  },

  1(require, exports, module) {
    // node_modules/defined/index.js
    module.exports = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== void 0)
          return arguments[i];
      }
    };
  },

  0(require, exports, module) {
    // node_modules/canvas-sketch-util/random.js
    var seedRandom = require(2 /* seed-random */);
    var SimplexNoise = require(3 /* simplex-noise */);
    var defined = require(1 /* defined */);
    function createRandom(defaultSeed) {
      defaultSeed = defined(defaultSeed, null);
      var defaultRandom = Math.random;
      var currentSeed;
      var currentRandom;
      var noiseGenerator;
      var _nextGaussian = null;
      var _hasNextGaussian = false;
      setSeed(defaultSeed);
      return {
        value,
        createRandom: function(defaultSeed2) {
          return createRandom(defaultSeed2);
        },
        setSeed,
        getSeed,
        getRandomSeed,
        valueNonZero,
        permuteNoise,
        noise1D,
        noise2D,
        noise3D,
        noise4D,
        sign,
        boolean,
        chance,
        range,
        rangeFloor,
        pick,
        shuffle,
        onCircle,
        insideCircle,
        onSphere,
        insideSphere,
        quaternion,
        weighted,
        weightedSet,
        weightedSetIndex,
        gaussian
      };
      function setSeed(seed, opt) {
        if (typeof seed === "number" || typeof seed === "string") {
          currentSeed = seed;
          currentRandom = seedRandom(currentSeed, opt);
        } else {
          currentSeed = void 0;
          currentRandom = defaultRandom;
        }
        noiseGenerator = createNoise();
        _nextGaussian = null;
        _hasNextGaussian = false;
      }
      function value() {
        return currentRandom();
      }
      function valueNonZero() {
        var u = 0;
        while (u === 0)
          u = value();
        return u;
      }
      function getSeed() {
        return currentSeed;
      }
      function getRandomSeed() {
        var seed = String(Math.floor(Math.random() * 1000000));
        return seed;
      }
      function createNoise() {
        return new SimplexNoise(currentRandom);
      }
      function permuteNoise() {
        noiseGenerator = createNoise();
      }
      function noise1D(x, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise2D(x * frequency, 0);
      }
      function noise2D(x, y, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise2D(x * frequency, y * frequency);
      }
      function noise3D(x, y, z, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        if (!isFinite(z))
          throw new TypeError("z component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise3D(x * frequency, y * frequency, z * frequency);
      }
      function noise4D(x, y, z, w, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        if (!isFinite(z))
          throw new TypeError("z component for noise() must be finite");
        if (!isFinite(w))
          throw new TypeError("w component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise4D(x * frequency, y * frequency, z * frequency, w * frequency);
      }
      function sign() {
        return boolean() ? 1 : -1;
      }
      function boolean() {
        return value() > 0.5;
      }
      function chance(n) {
        n = defined(n, 0.5);
        if (typeof n !== "number")
          throw new TypeError("expected n to be a number");
        return value() < n;
      }
      function range(min, max) {
        if (max === void 0) {
          max = min;
          min = 0;
        }
        if (typeof min !== "number" || typeof max !== "number") {
          throw new TypeError("Expected all arguments to be numbers");
        }
        return value() * (max - min) + min;
      }
      function rangeFloor(min, max) {
        if (max === void 0) {
          max = min;
          min = 0;
        }
        if (typeof min !== "number" || typeof max !== "number") {
          throw new TypeError("Expected all arguments to be numbers");
        }
        return Math.floor(range(min, max));
      }
      function pick(array) {
        if (array.length === 0)
          return void 0;
        return array[rangeFloor(0, array.length)];
      }
      function shuffle(arr) {
        if (!Array.isArray(arr)) {
          throw new TypeError("Expected Array, got " + typeof arr);
        }
        var rand;
        var tmp;
        var len = arr.length;
        var ret = arr.slice();
        while (len) {
          rand = Math.floor(value() * len--);
          tmp = ret[len];
          ret[len] = ret[rand];
          ret[rand] = tmp;
        }
        return ret;
      }
      function onCircle(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var theta = value() * 2 * Math.PI;
        out[0] = radius * Math.cos(theta);
        out[1] = radius * Math.sin(theta);
        return out;
      }
      function insideCircle(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        onCircle(1, out);
        var r = radius * Math.sqrt(value());
        out[0] *= r;
        out[1] *= r;
        return out;
      }
      function onSphere(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var u = value() * Math.PI * 2;
        var v = value() * 2 - 1;
        var phi = u;
        var theta = Math.acos(v);
        out[0] = radius * Math.sin(theta) * Math.cos(phi);
        out[1] = radius * Math.sin(theta) * Math.sin(phi);
        out[2] = radius * Math.cos(theta);
        return out;
      }
      function insideSphere(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var u = value() * Math.PI * 2;
        var v = value() * 2 - 1;
        var k = value();
        var phi = u;
        var theta = Math.acos(v);
        var r = radius * Math.cbrt(k);
        out[0] = r * Math.sin(theta) * Math.cos(phi);
        out[1] = r * Math.sin(theta) * Math.sin(phi);
        out[2] = r * Math.cos(theta);
        return out;
      }
      function quaternion(out) {
        out = out || [];
        var u1 = value();
        var u2 = value();
        var u3 = value();
        var sq1 = Math.sqrt(1 - u1);
        var sq2 = Math.sqrt(u1);
        var theta1 = Math.PI * 2 * u2;
        var theta2 = Math.PI * 2 * u3;
        var x = Math.sin(theta1) * sq1;
        var y = Math.cos(theta1) * sq1;
        var z = Math.sin(theta2) * sq2;
        var w = Math.cos(theta2) * sq2;
        out[0] = x;
        out[1] = y;
        out[2] = z;
        out[3] = w;
        return out;
      }
      function weightedSet(set) {
        set = set || [];
        if (set.length === 0)
          return null;
        return set[weightedSetIndex(set)].value;
      }
      function weightedSetIndex(set) {
        set = set || [];
        if (set.length === 0)
          return -1;
        return weighted(set.map(function(s) {
          return s.weight;
        }));
      }
      function weighted(weights) {
        weights = weights || [];
        if (weights.length === 0)
          return -1;
        var totalWeight = 0;
        var i;
        for (i = 0; i < weights.length; i++) {
          totalWeight += weights[i];
        }
        if (totalWeight <= 0)
          throw new Error("Weights must sum to > 0");
        var random = value() * totalWeight;
        for (i = 0; i < weights.length; i++) {
          if (random < weights[i]) {
            return i;
          }
          random -= weights[i];
        }
        return 0;
      }
      function gaussian(mean, standardDerivation) {
        mean = defined(mean, 0);
        standardDerivation = defined(standardDerivation, 1);
        if (_hasNextGaussian) {
          _hasNextGaussian = false;
          var result = _nextGaussian;
          _nextGaussian = null;
          return mean + standardDerivation * result;
        } else {
          var v1 = 0;
          var v2 = 0;
          var s = 0;
          do {
            v1 = value() * 2 - 1;
            v2 = value() * 2 - 1;
            s = v1 * v1 + v2 * v2;
          } while (s >= 1 || s === 0);
          var multiplier = Math.sqrt(-2 * Math.log(s) / s);
          _nextGaussian = v2 * multiplier;
          _hasNextGaussian = true;
          return mean + standardDerivation * (v1 * multiplier);
        }
      }
    }
    module.exports = createRandom();
  }
}, 7);
//# sourceMappingURL=app.js.map
