import fs from "fs/promises";
import fsBase from "fs";
import path from "path";
import { mkdirp, watch } from "../../utils/filesystem.js";
import esbuild from "esbuild";
import log from "../../log.js";

function trim(str) {
    return str.replace(/^\t\t/gm, '').trim();
}

async function send(file, res) {
    let stats = await fs.stat(file);
    let headers = {
        'Content-Length': stats.size,
        'Content-Type': "application/javascript",
        'Last-Modified': stats.mtime.toUTCString(),
    };

    res.writeHead(200, headers);
    res.end(fsBase.readFileSync(file));
};

export default function bundler({ entry, cwd, wss }) {
    const filename = "entry.js";
    const buildDir = path.resolve(cwd, `.fragment`);
    const file = path.join(buildDir, filename);

    const stats = fsBase.lstatSync(entry);
    const entries = stats.isFile() ? [entry] : fsBase.readdirSync(entry);

    const entriesMap = new Map();

    entries.forEach(entry => {
        const filepath = path.relative(buildDir, path.join(cwd, entry));
        const id = path.basename(filepath);

        entriesMap.set(`${id}`, filepath);
    });
    const keys = [...entriesMap.keys()];
    const values = [...entriesMap.values()];

    const writeFile = () => {

        const code = trim(`
// This file is generated by Fragment. Do not edit it.
const scenes = [
    ${keys.map((key, index) => {
        return `{ load: () => import ("${values[index]}") }`
    }).join(',')
    }
];

Promise.all(scenes.map(scene => scene.load()))
    .then((all) => {
        all.forEach(scene => {
            console.log(scene, scene.hot);
            console.log(scene.name, scene.init, scene.update, scene.enabled);
            scene.init();
        })
    });
        `);

        mkdirp(path.dirname(file));
        fsBase.writeFileSync(file, code);
    };

    const watchFiles = () => {
        const filepaths = [...entriesMap.values()];

        watch(filepaths, (filepath) => {
            const index = filepaths.indexOf(filepath);
            const key = keys[index];

            console.log(`Scene ${key} has changed.`);
        });
    };

    const bundle = async () => {
        try {
            const { warnings } = await esbuild.build({
                entryPoints: [file],
                outfile: path.join(buildDir, 'bundle.js'),
                bundle: true,
                logLevel: 'silent',
                define: {
                    'process.env.NODE_ENV': `"${process.env.NODE_ENV}"`,
                    '$fragment': "hello",
                },
            })

            log.success(`Esbuild :: bundled`);
        } catch(err) {
            log.error(`Esbuild :: cannot bundle`);
            console.log(err);
        }
    };

    writeFile();
    bundle();
    watchFiles();

    const bundlePath = path.join(buildDir, 'bundle.js')

    return async (req, res, next) => {
        if (req.url === "/bundle.js")Â {
            await send(bundlePath, res);
        }

        const keys = [...entriesMap.keys()];

        let url = req.url.split('/')[1];

        if (keys.includes(url)) {
            const file = entriesMap.get(url);

            await send(file, res);
        }

        next();
    };
}
