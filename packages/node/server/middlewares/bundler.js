import fs from "fs/promises";
import fsBase from "fs";
import path from "path";
import { mkdirp, watch } from "../../utils/filesystem.js";
import esbuild from "esbuild";
import log from "../../log.js";

function trim(str) {
    return str.replace(/^\t\t/gm, '').trim();
}

async function send(file, res) {
    let stats = await fs.stat(file);
    let headers = {
        'Content-Length': stats.size,
        'Content-Type': "application/javascript",
        'Last-Modified': stats.mtime.toUTCString(),
    };

    res.writeHead(200, headers);
    res.end(fsBase.readFileSync(file));
};

export default function bundler({ entry, cwd, wss }) {
    const filename = "entry.js";
    const buildDir = path.resolve(cwd, `.fragment`);
    const file = path.join(buildDir, filename);

    const stats = fsBase.lstatSync(entry);
    const entries = stats.isFile() ? [entry] : fsBase.readdirSync(entry);

    const entriesMap = new Map();

    entries.forEach(entry => {
        const filepath = path.relative(buildDir, path.join(cwd, entry));
        const id = path.basename(filepath);

        entriesMap.set(`${id}`, filepath);
    });
    const keys = [...entriesMap.keys()];
    const values = [...entriesMap.values()];

    const writeFile = () => {

        const code = trim(`
// This file is generated by Fragment. Do not edit it.
const scenes = [
    ${keys.map((key, index) => {
        return `{ load: () => import("${values[index]}") }`
    }).join(',')
    }
];

const load = () => {
    Promise.all(scenes.map(scene => scene.load()))
        .then((all) => {
            all.forEach(scene => {
                console.log(scene.fps);
                scene.init();
            })
        });
};

load();

setInterval(() => {
    load();
}, 2000);

        `);

        mkdirp(path.dirname(file));
        fsBase.writeFileSync(file, code);
    };

    const watchFiles = () => {
        const filepaths = [...entriesMap.keys()].map(filepath => path.join(cwd, filepath));

        console.log(cwd, filepaths);

        watch(filepaths, (filepath) => {
            console.log("Filepath changed.", filepath);
            // const index = filepaths.indexOf(filepath);
            // const key = keys[index];

            // console.log(`Scene ${key} has changed.`);
        });
    };

    /* STEPS
    - Make sure esbuild lets the dynamic imports as is
    - On HTTP request, build module and serve generated file
    - On socket change event, trigger a new dynamic import + rerender Svelte
    */

    const bundle = async () => {
        try {
            const data = await esbuild.build({
                entryPoints: [file],
                outdir: path.join(buildDir, 'out'),
                splitting: true,
                format: 'esm',
                bundle: true,
                // logLevel: 'silent',
                define: {
                    'process.env.NODE_ENV': `"${process.env.NODE_ENV}"`,
                    '$fragment': "hello",
                },
                watch: {
                    onRebuild(error, result) {
                        console.log(error);
                        console.log(result);
                    }
                }
            });

            log.success(`Esbuild :: bundled`);
            console.log(data);
        } catch(err) {
            log.error(`Esbuild :: cannot bundle`);
            console.log(err);
        }
    };

    writeFile();
    bundle();
    watchFiles();

    const bundlePath = path.join(buildDir, 'bundle.js')

    return async (req, res, next) => {
        if (req.url === "/bundle.js")Â {
            await send(bundlePath, res);
        }

        const keys = [...entriesMap.keys()];

        let url = req.url.split('/')[1];

        if (keys.includes(url)) {
            const file = entriesMap.get(url);

            await send(file, res);
        }

        next();
    };
}
